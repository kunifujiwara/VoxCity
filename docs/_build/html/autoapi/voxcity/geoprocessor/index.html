<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="voxcity.geoprocessor.draw" href="draw/index.html" /><link rel="prev" title="voxcity.generator" href="../generator/index.html" />

    <link rel="shortcut icon" href="../../../_static/favicon.ico"/><!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>voxcity.geoprocessor - VoxCity Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=7edd21af" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">VoxCity Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.png" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.png" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">VoxCity Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../example.html"><strong>VoxCity Demo</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step1-prepare-environment">Step1. Prepare environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step2-set-target-area-by-a-rectangle">Step2. Set target area by a rectangle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step3-set-variables">Step3 Set variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step4-get-voxcity-output">Step4 Get voxcity output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step5-export-files">Step5 Export files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step6-urban-simulations">Step6 Urban simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#solar-radiation">6.1. Solar radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#landmark-visibility">6.3. Landmark visibility</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../index.html">API Reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current has-children"><a class="reference internal" href="../index.html">voxcity</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of voxcity</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3 has-children"><a class="reference internal" href="../downloader/index.html">voxcity.downloader</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of voxcity.downloader</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../downloader/citygml/index.html">voxcity.downloader.citygml</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/eubucco/index.html">voxcity.downloader.eubucco</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/gee/index.html">voxcity.downloader.gee</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/mbfp/index.html">voxcity.downloader.mbfp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/oemj/index.html">voxcity.downloader.oemj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/osm/index.html">voxcity.downloader.osm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/overture/index.html">voxcity.downloader.overture</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../exporter/index.html">voxcity.exporter</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of voxcity.exporter</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../exporter/envimet/index.html">voxcity.exporter.envimet</a></li>
<li class="toctree-l4"><a class="reference internal" href="../exporter/magicavoxel/index.html">voxcity.exporter.magicavoxel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../exporter/obj/index.html">voxcity.exporter.obj</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../generator/index.html">voxcity.generator</a></li>
<li class="toctree-l3 current has-children current-page"><a class="current reference internal" href="#">voxcity.geoprocessor</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of voxcity.geoprocessor</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="draw/index.html">voxcity.geoprocessor.draw</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid/index.html">voxcity.geoprocessor.grid</a></li>
<li class="toctree-l4"><a class="reference internal" href="mesh/index.html">voxcity.geoprocessor.mesh</a></li>
<li class="toctree-l4"><a class="reference internal" href="network/index.html">voxcity.geoprocessor.network</a></li>
<li class="toctree-l4"><a class="reference internal" href="polygon/index.html">voxcity.geoprocessor.polygon</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../simulator/index.html">voxcity.simulator</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of voxcity.simulator</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../simulator/solar/index.html">voxcity.simulator.solar</a></li>
<li class="toctree-l4"><a class="reference internal" href="../simulator/view/index.html">voxcity.simulator.view</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial:</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../examples/index.html">Use cases of VoxCity</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Use cases of VoxCity</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html"><strong>VoxCity Demo</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step1-prepare-environment">Step1. Prepare environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step2-set-target-area-by-a-rectangle">Step2. Set target area by a rectangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step3-set-variables">Step3 Set variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step4-get-voxcity-output">Step4 Get voxcity output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step5-export-files">Step5 Export files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step6-urban-simulations">Step6 Urban simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#solar-radiation">6.1. Solar radiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#landmark-visibility">6.3. Landmark visibility</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Information:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">=======
History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">============
Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conduct.html">====================================
Contributor Covenant Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../../../_sources/autoapi/voxcity/geoprocessor/index.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-voxcity.geoprocessor">
<span id="voxcity-geoprocessor"></span><h1>voxcity.geoprocessor<a class="headerlink" href="#module-voxcity.geoprocessor" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="draw/index.html">voxcity.geoprocessor.draw</a></li>
<li class="toctree-l1"><a class="reference internal" href="grid/index.html">voxcity.geoprocessor.grid</a></li>
<li class="toctree-l1"><a class="reference internal" href="mesh/index.html">voxcity.geoprocessor.mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="network/index.html">voxcity.geoprocessor.network</a></li>
<li class="toctree-l1"><a class="reference internal" href="polygon/index.html">voxcity.geoprocessor.polygon</a></li>
</ul>
</div>
</section>
<section id="attributes">
<h2>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.floor_height" title="voxcity.geoprocessor.floor_height"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor_height</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#id4" title="voxcity.geoprocessor.get_coordinates_from_cityname"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coordinates_from_cityname</span></code></a>(place_name)</p></td>
<td><p>Geocode a city name to get its coordinates using OpenStreetMap's Nominatim service.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.rotate_rectangle" title="voxcity.geoprocessor.rotate_rectangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_rectangle</span></code></a>(m, rectangle_vertices, angle)</p></td>
<td><p>Project rectangle to Mercator, rotate, and re-project to lat-lon coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.draw_rectangle_map" title="voxcity.geoprocessor.draw_rectangle_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_rectangle_map</span></code></a>([center, zoom])</p></td>
<td><p>Create an interactive map for drawing rectangles with ipyleaflet.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.draw_rectangle_map_cityname" title="voxcity.geoprocessor.draw_rectangle_map_cityname"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_rectangle_map_cityname</span></code></a>(cityname[, zoom])</p></td>
<td><p>Create an interactive map centered on a specified city for drawing rectangles.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.center_location_map_cityname" title="voxcity.geoprocessor.center_location_map_cityname"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center_location_map_cityname</span></code></a>(cityname, ...[, zoom])</p></td>
<td><p>Create an interactive map centered on a city where clicking creates a rectangle of specified dimensions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.display_buildings_and_draw_polygon" title="voxcity.geoprocessor.display_buildings_and_draw_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">display_buildings_and_draw_polygon</span></code></a>([building_gdf, ...])</p></td>
<td><p>Displays building footprints and enables polygon drawing on an interactive map.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="voxcity.geoprocessor.initialize_geod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_geod</span></code></a>()</p></td>
<td><p>Initialize a Geod object for geodetic calculations using WGS84 ellipsoid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id1" title="voxcity.geoprocessor.calculate_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_distance</span></code></a>(geod, lon1, lat1, lon2, lat2)</p></td>
<td><p>Calculate geodetic distance between two points on the Earth's surface.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id2" title="voxcity.geoprocessor.normalize_to_one_meter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_to_one_meter</span></code></a>(vector, distance_in_meters)</p></td>
<td><p>Normalize a vector to represent one meter in geographic space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id5" title="voxcity.geoprocessor.create_building_polygons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_building_polygons</span></code></a>(filtered_buildings)</p></td>
<td><p>Create building polygons with properties from filtered GeoJSON features.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id3" title="voxcity.geoprocessor.convert_format_lat_lon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_format_lat_lon</span></code></a>(input_coords)</p></td>
<td><p>Convert coordinate format and close polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id10" title="voxcity.geoprocessor.filter_buildings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_buildings</span></code></a>(geojson_data, plotting_box)</p></td>
<td><p>Filter building features that intersect with a given bounding box.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id11" title="voxcity.geoprocessor.extract_building_heights_from_geotiff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_building_heights_from_geotiff</span></code></a>(geotiff_path, gdf)</p></td>
<td><p>Extract building heights from a GeoTIFF raster for building footprints in a GeoDataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id8" title="voxcity.geoprocessor.extract_building_heights_from_gdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_building_heights_from_gdf</span></code></a>(→ geopandas.GeoDataFrame)</p></td>
<td><p>Extract building heights from one GeoDataFrame and apply them to another based on spatial overlap.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id9" title="voxcity.geoprocessor.complement_building_heights_from_gdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complement_building_heights_from_gdf</span></code></a>(gdf_0, gdf_1[, ...])</p></td>
<td><p>Use a vectorized approach with GeoPandas to:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id12" title="voxcity.geoprocessor.process_building_footprints_by_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_building_footprints_by_overlap</span></code></a>(filtered_gdf[, ...])</p></td>
<td><p>Process building footprints to merge overlapping buildings based on area overlap ratio.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_class_priority" title="voxcity.geoprocessor.get_class_priority"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_class_priority</span></code></a>(source)</p></td>
<td><p>Get priority rankings for land cover classes to resolve conflicts during classification.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_land_cover_polygons" title="voxcity.geoprocessor.create_land_cover_polygons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_land_cover_polygons</span></code></a>(land_cover_geojson)</p></td>
<td><p>Create polygon geometries and spatial index from land cover GeoJSON data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_dominant_class" title="voxcity.geoprocessor.get_dominant_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dominant_class</span></code></a>(cell_data, land_cover_classes)</p></td>
<td><p>Determine the dominant land cover class in a cell based on pixel majority.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_roi" title="voxcity.geoprocessor.get_roi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_roi</span></code></a>(input_coords)</p></td>
<td><p>Create an Earth Engine region of interest polygon from coordinates.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.save_geotiff_open_buildings_temporal" title="voxcity.geoprocessor.save_geotiff_open_buildings_temporal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_geotiff_open_buildings_temporal</span></code></a>(aoi, geotiff_path)</p></td>
<td><p>Save Open Buildings temporal data as a GeoTIFF.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.apply_operation" title="voxcity.geoprocessor.apply_operation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_operation</span></code></a>(arr, meshsize)</p></td>
<td><p>Applies a sequence of operations to an array based on a mesh size to normalize and discretize values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.translate_array" title="voxcity.geoprocessor.translate_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate_array</span></code></a>(input_array, translation_dict)</p></td>
<td><p>Translates values in an array according to a dictionary mapping.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.group_and_label_cells" title="voxcity.geoprocessor.group_and_label_cells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group_and_label_cells</span></code></a>(array)</p></td>
<td><p>Convert non-zero numbers in a 2D numpy array to sequential IDs starting from 1.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.process_grid" title="voxcity.geoprocessor.process_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_grid</span></code></a>(grid_bi, dem_grid)</p></td>
<td><p>Process a binary grid and DEM grid to create averaged elevation values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.calculate_grid_size" title="voxcity.geoprocessor.calculate_grid_size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_grid_size</span></code></a>(side_1, side_2, u_vec, v_vec, meshsize)</p></td>
<td><p>Calculate grid size and adjusted mesh size based on input parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_coordinate_mesh" title="voxcity.geoprocessor.create_coordinate_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_coordinate_mesh</span></code></a>(origin, grid_size, ...)</p></td>
<td><p>Create a coordinate mesh based on input parameters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_cell_polygon" title="voxcity.geoprocessor.create_cell_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_cell_polygon</span></code></a>(origin, i, j, adjusted_meshsize, ...)</p></td>
<td><p>Create a polygon representing a grid cell.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.tree_height_grid_from_land_cover" title="voxcity.geoprocessor.tree_height_grid_from_land_cover"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tree_height_grid_from_land_cover</span></code></a>(land_cover_grid_ori)</p></td>
<td><p>Convert a land cover grid to a tree height grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_land_cover_grid_from_geotiff_polygon" title="voxcity.geoprocessor.create_land_cover_grid_from_geotiff_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_land_cover_grid_from_geotiff_polygon</span></code></a>(tiff_path, ...)</p></td>
<td><p>Create a land cover grid from a GeoTIFF file within a polygon boundary.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_land_cover_grid_from_gdf_polygon" title="voxcity.geoprocessor.create_land_cover_grid_from_gdf_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_land_cover_grid_from_gdf_polygon</span></code></a>(gdf, meshsize, ...)</p></td>
<td><p>Create a grid of land cover classes from GeoDataFrame polygon data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_height_grid_from_geotiff_polygon" title="voxcity.geoprocessor.create_height_grid_from_geotiff_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_height_grid_from_geotiff_polygon</span></code></a>(tiff_path, ...)</p></td>
<td><p>Create a height grid from a GeoTIFF file within a polygon boundary.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_building_height_grid_from_gdf_polygon" title="voxcity.geoprocessor.create_building_height_grid_from_gdf_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_building_height_grid_from_gdf_polygon</span></code></a>(gdf, ...)</p></td>
<td><p>Create a building height grid from GeoDataFrame data within a polygon boundary.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_building_height_grid_from_open_building_temporal_polygon" title="voxcity.geoprocessor.create_building_height_grid_from_open_building_temporal_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_building_height_grid_from_open_building_temporal_polygon</span></code></a>(...)</p></td>
<td><p>Create a building height grid from OpenBuildings temporal data within a polygon.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_dem_grid_from_geotiff_polygon" title="voxcity.geoprocessor.create_dem_grid_from_geotiff_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_dem_grid_from_geotiff_polygon</span></code></a>(tiff_path, ...[, ...])</p></td>
<td><p>Create a Digital Elevation Model (DEM) grid from a GeoTIFF file within a polygon boundary.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id6" title="voxcity.geoprocessor.grid_to_geodataframe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_to_geodataframe</span></code></a>(grid_ori, rectangle_vertices, ...)</p></td>
<td><p>Converts a 2D grid to a GeoDataFrame with cell polygons and values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.grid_to_point_geodataframe" title="voxcity.geoprocessor.grid_to_point_geodataframe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_to_point_geodataframe</span></code></a>(grid_ori, ...)</p></td>
<td><p>Converts a 2D grid to a GeoDataFrame with point geometries at cell centers and values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_vegetation_height_grid_from_gdf_polygon" title="voxcity.geoprocessor.create_vegetation_height_grid_from_gdf_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_vegetation_height_grid_from_gdf_polygon</span></code></a>(...)</p></td>
<td><p>Create a vegetation height grid from a GeoDataFrame of vegetation polygons/objects</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_dem_grid_from_gdf_polygon" title="voxcity.geoprocessor.create_dem_grid_from_gdf_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_dem_grid_from_gdf_polygon</span></code></a>(terrain_gdf, ...)</p></td>
<td><p>Create a height grid from a terrain GeoDataFrame within the bounding box</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.tile_from_lat_lon" title="voxcity.geoprocessor.tile_from_lat_lon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile_from_lat_lon</span></code></a>(lat, lon, level_of_detail)</p></td>
<td><p>Convert latitude/longitude coordinates to tile coordinates at a given zoom level.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.quadkey_to_tile" title="voxcity.geoprocessor.quadkey_to_tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quadkey_to_tile</span></code></a>(quadkey)</p></td>
<td><p>Convert a quadkey string to tile coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id0" title="voxcity.geoprocessor.initialize_geod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_geod</span></code></a>()</p></td>
<td><p>Initialize a Geod object for geodetic calculations using WGS84 ellipsoid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id1" title="voxcity.geoprocessor.calculate_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_distance</span></code></a>(geod, lon1, lat1, lon2, lat2)</p></td>
<td><p>Calculate geodetic distance between two points on the Earth's surface.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id2" title="voxcity.geoprocessor.normalize_to_one_meter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_to_one_meter</span></code></a>(vector, distance_in_meters)</p></td>
<td><p>Normalize a vector to represent one meter in geographic space.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.setup_transformer" title="voxcity.geoprocessor.setup_transformer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setup_transformer</span></code></a>(from_crs, to_crs)</p></td>
<td><p>Set up a coordinate transformer between two Coordinate Reference Systems (CRS).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.transform_coords" title="voxcity.geoprocessor.transform_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform_coords</span></code></a>(transformer, lon, lat)</p></td>
<td><p>Transform coordinates using provided transformer with error handling.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_polygon" title="voxcity.geoprocessor.create_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_polygon</span></code></a>(vertices)</p></td>
<td><p>Create a Shapely polygon from a list of vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_geodataframe" title="voxcity.geoprocessor.create_geodataframe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_geodataframe</span></code></a>(polygon[, crs])</p></td>
<td><p>Create a GeoDataFrame from a Shapely polygon.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.haversine_distance" title="voxcity.geoprocessor.haversine_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">haversine_distance</span></code></a>(lon1, lat1, lon2, lat2)</p></td>
<td><p>Calculate great-circle distance between two points using Haversine formula.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_raster_bbox" title="voxcity.geoprocessor.get_raster_bbox"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_raster_bbox</span></code></a>(raster_path)</p></td>
<td><p>Get the bounding box of a raster file in its native coordinate system.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.raster_intersects_polygon" title="voxcity.geoprocessor.raster_intersects_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">raster_intersects_polygon</span></code></a>(raster_path, polygon)</p></td>
<td><p>Check if a raster file's extent intersects with a given polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.save_raster" title="voxcity.geoprocessor.save_raster"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_raster</span></code></a>(input_path, output_path)</p></td>
<td><p>Create a copy of a raster file at a new location.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.merge_geotiffs" title="voxcity.geoprocessor.merge_geotiffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge_geotiffs</span></code></a>(geotiff_files, output_dir)</p></td>
<td><p>Merge multiple GeoTIFF files into a single mosaic.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id3" title="voxcity.geoprocessor.convert_format_lat_lon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_format_lat_lon</span></code></a>(input_coords)</p></td>
<td><p>Convert coordinate format and close polygon.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id4" title="voxcity.geoprocessor.get_coordinates_from_cityname"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coordinates_from_cityname</span></code></a>(place_name)</p></td>
<td><p>Geocode a city name to get its coordinates using OpenStreetMap's Nominatim service.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_city_country_name_from_rectangle" title="voxcity.geoprocessor.get_city_country_name_from_rectangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_city_country_name_from_rectangle</span></code></a>(coordinates)</p></td>
<td><p>Get the city and country name for a location defined by a rectangle.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_timezone_info" title="voxcity.geoprocessor.get_timezone_info"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_timezone_info</span></code></a>(rectangle_coords)</p></td>
<td><p>Get timezone and central meridian information for a location.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="voxcity.geoprocessor.validate_polygon_coordinates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">validate_polygon_coordinates</span></code></a>(geometry)</p></td>
<td><p>Validate and ensure proper closure of polygon coordinate rings.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id5" title="voxcity.geoprocessor.create_building_polygons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_building_polygons</span></code></a>(filtered_buildings)</p></td>
<td><p>Create building polygons with properties from filtered GeoJSON features.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_country_name" title="voxcity.geoprocessor.get_country_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_country_name</span></code></a>(lon, lat)</p></td>
<td><p>Get country name from coordinates using reverse geocoding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id6" title="voxcity.geoprocessor.grid_to_geodataframe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_to_geodataframe</span></code></a>(grid_ori, rectangle_vertices, ...)</p></td>
<td><p>Converts a 2D grid to a GeoDataFrame with cell polygons and values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.vectorized_edge_values" title="voxcity.geoprocessor.vectorized_edge_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vectorized_edge_values</span></code></a>(G, polygons_gdf[, value_col])</p></td>
<td><p>Compute average polygon values along each edge in a network graph using vectorized operations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_network_values" title="voxcity.geoprocessor.get_network_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_network_values</span></code></a>(grid, rectangle_vertices, meshsize)</p></td>
<td><p>Extract and visualize values from a grid along a street network.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.interpolate_points_along_line" title="voxcity.geoprocessor.interpolate_points_along_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_points_along_line</span></code></a>(line, interval)</p></td>
<td><p>Interpolate points along a single LineString at a given interval (in meters).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.gather_interpolation_points" title="voxcity.geoprocessor.gather_interpolation_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gather_interpolation_points</span></code></a>(G[, interval, n_jobs])</p></td>
<td><p>Gather all interpolation points for each edge in the graph into a single GeoDataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.fetch_elevations_for_points" title="voxcity.geoprocessor.fetch_elevations_for_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_elevations_for_points</span></code></a>(points_gdf_3857, dem_gdf_3857)</p></td>
<td><p>Perform a spatial join to fetch DEM elevations for interpolated points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.compute_slope_for_group" title="voxcity.geoprocessor.compute_slope_for_group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_slope_for_group</span></code></a>(df)</p></td>
<td><p>Compute average slope between consecutive points along a single edge.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.calculate_edge_slopes_from_join" title="voxcity.geoprocessor.calculate_edge_slopes_from_join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_edge_slopes_from_join</span></code></a>(joined_points_gdf, n_edges)</p></td>
<td><p>Calculate average slopes for all edges in the network from interpolated points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.analyze_network_slopes" title="voxcity.geoprocessor.analyze_network_slopes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">analyze_network_slopes</span></code></a>(dem_grid, meshsize[, ...])</p></td>
<td><p>Analyze and visualize street network slopes using Digital Elevation Model (DEM) data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="voxcity.geoprocessor.validate_polygon_coordinates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">validate_polygon_coordinates</span></code></a>(geometry)</p></td>
<td><p>Validate and ensure proper closure of polygon coordinate rings.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.filter_and_convert_gdf_to_geojson" title="voxcity.geoprocessor.filter_and_convert_gdf_to_geojson"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_and_convert_gdf_to_geojson</span></code></a>(gdf, rectangle_vertices)</p></td>
<td><p>Filter a GeoDataFrame by a bounding rectangle and convert to GeoJSON format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_geojson_from_gpkg" title="voxcity.geoprocessor.get_geojson_from_gpkg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_geojson_from_gpkg</span></code></a>(gpkg_path, rectangle_vertices)</p></td>
<td><p>Read a GeoPackage file and convert it to GeoJSON format within a bounding rectangle.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id8" title="voxcity.geoprocessor.extract_building_heights_from_gdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_building_heights_from_gdf</span></code></a>(→ geopandas.GeoDataFrame)</p></td>
<td><p>Extract building heights from one GeoDataFrame and apply them to another based on spatial overlap.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.geojson_to_gdf" title="voxcity.geoprocessor.geojson_to_gdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geojson_to_gdf</span></code></a>(geojson_data[, id_col])</p></td>
<td><p>Convert a list of GeoJSON-like dict features into a GeoDataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id9" title="voxcity.geoprocessor.complement_building_heights_from_gdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complement_building_heights_from_gdf</span></code></a>(gdf_0, gdf_1[, ...])</p></td>
<td><p>Use a vectorized approach with GeoPandas to:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.gdf_to_geojson_dicts" title="voxcity.geoprocessor.gdf_to_geojson_dicts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gdf_to_geojson_dicts</span></code></a>(gdf[, id_col])</p></td>
<td><p>Convert a GeoDataFrame to a list of dicts similar to GeoJSON features.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.load_gdf_from_multiple_gz" title="voxcity.geoprocessor.load_gdf_from_multiple_gz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_gdf_from_multiple_gz</span></code></a>(file_paths)</p></td>
<td><p>Load GeoJSON features from multiple gzipped files into a single GeoDataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id10" title="voxcity.geoprocessor.filter_buildings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_buildings</span></code></a>(geojson_data, plotting_box)</p></td>
<td><p>Filter building features that intersect with a given bounding box.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id11" title="voxcity.geoprocessor.extract_building_heights_from_geotiff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_building_heights_from_geotiff</span></code></a>(geotiff_path, gdf)</p></td>
<td><p>Extract building heights from a GeoTIFF raster for building footprints in a GeoDataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_gdf_from_gpkg" title="voxcity.geoprocessor.get_gdf_from_gpkg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_gdf_from_gpkg</span></code></a>(gpkg_path, rectangle_vertices)</p></td>
<td><p>Read a GeoPackage file and convert it to a GeoDataFrame with consistent CRS.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.swap_coordinates" title="voxcity.geoprocessor.swap_coordinates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap_coordinates</span></code></a>(features)</p></td>
<td><p>Swap coordinate ordering in GeoJSON features from (lat, lon) to (lon, lat).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.save_geojson" title="voxcity.geoprocessor.save_geojson"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_geojson</span></code></a>(features, save_path)</p></td>
<td><p>Save GeoJSON features to a file with coordinate swapping and pretty printing.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.find_building_containing_point" title="voxcity.geoprocessor.find_building_containing_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_building_containing_point</span></code></a>(building_gdf, target_point)</p></td>
<td><p>Find building IDs that contain a given point in their footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.get_buildings_in_drawn_polygon" title="voxcity.geoprocessor.get_buildings_in_drawn_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_buildings_in_drawn_polygon</span></code></a>(building_gdf, ...[, ...])</p></td>
<td><p>Find buildings that intersect with or are contained within a user-drawn polygon.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id12" title="voxcity.geoprocessor.process_building_footprints_by_overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">process_building_footprints_by_overlap</span></code></a>(filtered_gdf[, ...])</p></td>
<td><p>Process building footprints to merge overlapping buildings based on area overlap ratio.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_voxel_mesh" title="voxcity.geoprocessor.create_voxel_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_voxel_mesh</span></code></a>(voxel_array, class_id[, meshsize, ...])</p></td>
<td><p>Create a 3D mesh from voxels preserving sharp edges, scaled by meshsize.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_sim_surface_mesh" title="voxcity.geoprocessor.create_sim_surface_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_sim_surface_mesh</span></code></a>(sim_grid, dem_grid[, ...])</p></td>
<td><p>Create a colored planar surface mesh from simulation data, positioned above a DEM.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.create_city_meshes" title="voxcity.geoprocessor.create_city_meshes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_city_meshes</span></code></a>(voxel_array, vox_dict[, meshsize])</p></td>
<td><p>Create a collection of colored 3D meshes representing different city elements.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.export_meshes" title="voxcity.geoprocessor.export_meshes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_meshes</span></code></a>(meshes, output_directory, base_filename)</p></td>
<td><p>Export a collection of meshes to both OBJ (with MTL) and STL formats.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.geoprocessor.split_vertices_manual" title="voxcity.geoprocessor.split_vertices_manual"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_vertices_manual</span></code></a>(mesh)</p></td>
<td><p>Split a mesh into independent faces by duplicating shared vertices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.geoprocessor.save_obj_from_colored_mesh" title="voxcity.geoprocessor.save_obj_from_colored_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_obj_from_colored_mesh</span></code></a>(meshes, output_path, ...)</p></td>
<td><p>Save a collection of colored meshes as OBJ and MTL files with material support.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_coordinates_from_cityname">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_coordinates_from_cityname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">place_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#get_coordinates_from_cityname"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_coordinates_from_cityname" title="Link to this definition">¶</a></dt>
<dd><p>Geocode a city name to get its coordinates using OpenStreetMap’s Nominatim service.
Includes rate limiting and error handling to comply with Nominatim’s usage policy.</p>
<p>Note:
- Results may vary based on the specificity of the place name
- For better results, include country or state information
- Service has usage limits and may timeout</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>place_name</strong> (<em>str</em>) – Name of the city to geocode (e.g., “Tokyo, Japan”)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(latitude, longitude) coordinates or None if geocoding fails</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">get_coordinates_from_cityname</span><span class="p">(</span><span class="s2">&quot;Paris, France&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">coords</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Paris coordinates: </span><span class="si">{</span><span class="n">lat</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">lon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.rotate_rectangle">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">rotate_rectangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/draw.html#rotate_rectangle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.rotate_rectangle" title="Link to this definition">¶</a></dt>
<dd><p>Project rectangle to Mercator, rotate, and re-project to lat-lon coordinates.</p>
<p>This function performs a rotation of a rectangle in geographic space by:
1. Converting coordinates from WGS84 (lat/lon) to Web Mercator projection
2. Performing the rotation in the projected space for accurate distance preservation
3. Converting back to WGS84 coordinates
4. Visualizing the result on the provided map</p>
<p>The rotation is performed around the rectangle’s centroid using a standard 2D rotation matrix.
The function handles coordinate system transformations to ensure geometrically accurate rotations
despite the distortions inherent in geographic projections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>ipyleaflet.Map</em>) – Map object to draw the rotated rectangle on.
The map must be initialized and have a valid center and zoom level.</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of (lon, lat) tuples defining the rectangle vertices.
The vertices should be ordered in a counter-clockwise direction.
Example: [(lon1,lat1), (lon2,lat2), (lon3,lat3), (lon4,lat4)]</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – Rotation angle in degrees.
Positive angles rotate counter-clockwise.
Negative angles rotate clockwise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>List of rotated (lon, lat) tuples defining the new rectangle vertices.</dt><dd><p>The vertices maintain their original ordering.
Returns None if no rectangle vertices are provided.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function uses EPSG:4326 (WGS84) for geographic coordinates and
EPSG:3857 (Web Mercator) for the rotation calculations.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.draw_rectangle_map">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">draw_rectangle_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(40,</span> <span class="pre">-100)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/draw.html#draw_rectangle_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.draw_rectangle_map" title="Link to this definition">¶</a></dt>
<dd><p>Create an interactive map for drawing rectangles with ipyleaflet.</p>
<p>This function initializes an interactive map that allows users to draw rectangles
by clicking and dragging on the map surface. The drawn rectangles are captured
and their vertices are stored in geographic coordinates.</p>
<p>The map interface provides:
- A rectangle drawing tool activated by default
- Real-time coordinate capture of drawn shapes
- Automatic vertex ordering in counter-clockwise direction
- Console output of vertex coordinates for verification</p>
<p>Drawing Controls:
- Click and drag to draw a rectangle
- Release to complete the rectangle
- Only one rectangle can be active at a time
- Drawing a new rectangle clears the previous one</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>tuple</em>) – Center coordinates (lat, lon) for the map view.
Defaults to (40, -100) which centers on the continental United States.
Format: (latitude, longitude) in decimal degrees.</p></li>
<li><p><strong>zoom</strong> (<em>int</em>) – Initial zoom level for the map. Defaults to 4.
Range: 0 (most zoomed out) to 18 (most zoomed in).
Recommended: 3-6 for countries, 10-15 for cities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(Map object, list of rectangle vertices)</dt><dd><ul class="simple">
<li><p>Map object: ipyleaflet.Map instance for displaying and interacting with the map</p></li>
<li><p>rectangle_vertices: Empty list that will be populated with (lon,lat) tuples
when a rectangle is drawn. Coordinates are stored in GeoJSON order (lon,lat).</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function disables all drawing tools except rectangles to ensure
consistent shape creation. The rectangle vertices are automatically
converted to (lon,lat) format when stored, regardless of the input
center coordinate order.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.draw_rectangle_map_cityname">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">draw_rectangle_map_cityname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cityname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/draw.html#draw_rectangle_map_cityname"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.draw_rectangle_map_cityname" title="Link to this definition">¶</a></dt>
<dd><p>Create an interactive map centered on a specified city for drawing rectangles.</p>
<p>This function extends draw_rectangle_map() by automatically centering the map
on a specified city using geocoding. It provides a convenient way to focus
the drawing interface on a particular urban area without needing to know
its exact coordinates.</p>
<p>The function uses the utils.get_coordinates_from_cityname() function to
geocode the city name and obtain its coordinates. The resulting map is
zoomed to an appropriate level for urban-scale analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cityname</strong> (<em>str</em>) – Name of the city to center the map on.
Can include country or state for better accuracy.
Examples: “Tokyo, Japan”, “New York, NY”, “Paris, France”</p></li>
<li><p><strong>zoom</strong> (<em>int</em>) – Initial zoom level for the map. Defaults to 15.
Range: 0 (most zoomed out) to 18 (most zoomed in).
Default of 15 is optimized for city-level visualization.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(Map object, list of rectangle vertices)</dt><dd><ul class="simple">
<li><p>Map object: ipyleaflet.Map instance centered on the specified city</p></li>
<li><p>rectangle_vertices: Empty list that will be populated with (lon,lat)
tuples when a rectangle is drawn</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the city name cannot be geocoded, the function will raise an error.
For better results, provide specific city names with country/state context.
The function inherits all drawing controls and behavior from draw_rectangle_map().</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.center_location_map_cityname">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">center_location_map_cityname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cityname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">east_west_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">north_south_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/draw.html#center_location_map_cityname"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.center_location_map_cityname" title="Link to this definition">¶</a></dt>
<dd><p>Create an interactive map centered on a city where clicking creates a rectangle of specified dimensions.</p>
<p>This function provides a specialized interface for creating fixed-size rectangles
centered on user-selected points. Instead of drawing rectangles by dragging,
users click a point on the map and a rectangle of the specified dimensions
is automatically created centered on that point.</p>
<p>The function handles:
- Automatic city geocoding and map centering
- Distance calculations in meters using geopy
- Conversion between geographic and metric distances
- Rectangle creation with specified dimensions
- Visualization of created rectangles</p>
<p>Workflow:
1. Map is centered on the specified city
2. User clicks a point on the map
3. A rectangle is created centered on that point
4. Rectangle dimensions are maintained in meters regardless of latitude
5. Previous rectangles are automatically cleared</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cityname</strong> (<em>str</em>) – Name of the city to center the map on.
Can include country or state for better accuracy.
Examples: “Tokyo, Japan”, “New York, NY”</p></li>
<li><p><strong>east_west_length</strong> (<em>float</em>) – Width of the rectangle in meters.
This is the dimension along the east-west direction.
The actual ground distance is maintained regardless of projection distortion.</p></li>
<li><p><strong>north_south_length</strong> (<em>float</em>) – Height of the rectangle in meters.
This is the dimension along the north-south direction.
The actual ground distance is maintained regardless of projection distortion.</p></li>
<li><p><strong>zoom</strong> (<em>int</em>) – Initial zoom level for the map. Defaults to 15.
Range: 0 (most zoomed out) to 18 (most zoomed in).
Default of 15 is optimized for city-level visualization.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(Map object, list of rectangle vertices)</dt><dd><ul class="simple">
<li><p>Map object: ipyleaflet.Map instance centered on the specified city</p></li>
<li><p>rectangle_vertices: Empty list that will be populated with (lon,lat)
tuples when a point is clicked and the rectangle is created</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Rectangle dimensions are specified in meters but stored as geographic coordinates</p></li>
<li><p>The function uses geopy’s distance calculations for accurate metric distances</p></li>
<li><p>Only one rectangle can exist at a time; clicking a new point removes the previous rectangle</p></li>
<li><p>Rectangle vertices are returned in GeoJSON (lon,lat) order</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.display_buildings_and_draw_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">display_buildings_and_draw_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">building_gdf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">17</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/draw.html#display_buildings_and_draw_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.display_buildings_and_draw_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Displays building footprints and enables polygon drawing on an interactive map.</p>
<p>This function creates an interactive map that visualizes building footprints and
allows users to draw arbitrary polygons. It’s particularly useful for selecting
specific buildings or areas within an urban context.</p>
<p>The function provides three key features:
1. Building Footprint Visualization:</p>
<blockquote>
<div><ul class="simple">
<li><p>Displays building polygons from a GeoDataFrame</p></li>
<li><p>Uses consistent styling for all buildings</p></li>
<li><p>Handles simple polygon geometries only</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Interactive Polygon Drawing:
- Enables free-form polygon drawing
- Captures vertices in consistent (lon,lat) format
- Maintains GeoJSON compatibility</p></li>
<li><p>Map Initialization:
- Automatic centering based on input data
- Fallback to default location if no data provided
- Support for both building data and rectangle bounds</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>building_gdf</strong> (<em>GeoDataFrame</em><em>, </em><em>optional</em>) – A GeoDataFrame containing building footprints.
Must have geometry column with Polygon type features.
Geometries should be in [lon, lat] coordinate order.
If None, only the base map is displayed.</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em><em>, </em><em>optional</em>) – List of [lon, lat] coordinates defining rectangle corners.
Used to set the initial map view extent.
Takes precedence over building_gdf for determining map center.</p></li>
<li><p><strong>zoom</strong> (<em>int</em>) – Initial zoom level for the map. Default=17.
Range: 0 (most zoomed out) to 18 (most zoomed in).
Default of 17 is optimized for building-level detail.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(map_object, drawn_polygon_vertices)</dt><dd><ul class="simple">
<li><p>map_object: ipyleaflet Map instance with building footprints and drawing controls</p></li>
<li><p>drawn_polygon_vertices: List that gets updated with (lon,lat) coordinates
whenever a new polygon is drawn. Coordinates are in GeoJSON order.</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Building footprints are displayed in blue with 20% opacity</p></li>
<li><p>Only simple Polygon geometries are supported (no MultiPolygons)</p></li>
<li><p>Drawing tools are restricted to polygon creation only</p></li>
<li><p>All coordinates are handled in (lon,lat) order internally</p></li>
<li><p>The function automatically determines appropriate map bounds</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.initialize_geod">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">initialize_geod</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#initialize_geod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.initialize_geod" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a Geod object for geodetic calculations using WGS84 ellipsoid.
The WGS84 ellipsoid (EPSG:4326) is the standard reference system used by GPS
and most modern mapping applications.</p>
<p>The Geod object provides methods for:
- Forward geodetic calculations (direct)
- Inverse geodetic calculations (inverse)
- Area calculations
- Line length calculations</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Initialized Geod object for WGS84 calculations</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Geod</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geod</span> <span class="o">=</span> <span class="n">initialize_geod</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fwd_az</span><span class="p">,</span> <span class="n">back_az</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.calculate_distance">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">calculate_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#calculate_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.calculate_distance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate geodetic distance between two points on the Earth’s surface.
Uses inverse geodetic computation to find the shortest distance along the ellipsoid,
which is more accurate than great circle (spherical) calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geod</strong> (<em>Geod</em>) – Geod object for calculations, initialized with WGS84</p></li>
<li><p><strong>lon1</strong> (<em>float</em>) – Coordinates of first point in decimal degrees</p></li>
<li><p><strong>lat1</strong> (<em>float</em>) – Coordinates of first point in decimal degrees</p></li>
<li><p><strong>lon2</strong> (<em>float</em>) – Coordinates of second point in decimal degrees</p></li>
<li><p><strong>lat2</strong> (<em>float</em>) – Coordinates of second point in decimal degrees</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Distance in meters between the two points along the ellipsoid</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geod</span> <span class="o">=</span> <span class="n">initialize_geod</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span> <span class="o">=</span> <span class="n">calculate_distance</span><span class="p">(</span><span class="n">geod</span><span class="p">,</span> <span class="mf">139.6503</span><span class="p">,</span> <span class="mf">35.6762</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="o">-</span><span class="mf">74.0060</span><span class="p">,</span> <span class="mf">40.7128</span><span class="p">)</span>  <span class="c1"># Tokyo to NYC</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.normalize_to_one_meter">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">normalize_to_one_meter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_in_meters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#normalize_to_one_meter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.normalize_to_one_meter" title="Link to this definition">¶</a></dt>
<dd><p>Normalize a vector to represent one meter in geographic space.
Useful for creating unit vectors in geographic calculations, particularly
when working with distance-based operations or scaling geographic features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vector</strong> (<em>numpy.ndarray</em>) – Vector to normalize, typically a direction vector</p></li>
<li><p><strong>distance_in_meters</strong> (<em>float</em>) – Current distance in meters that the vector represents</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normalized vector where magnitude represents 1 meter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">])</span>  <span class="c1"># Vector of length 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unit_meter</span> <span class="o">=</span> <span class="n">normalize_to_one_meter</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_building_polygons">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_building_polygons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filtered_buildings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#create_building_polygons"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_building_polygons" title="Link to this definition">¶</a></dt>
<dd><p>Create building polygons with properties from filtered GeoJSON features.
Processes a list of GeoJSON building features to create Shapely polygons
with associated height and other properties, while also building a spatial index.</p>
<p>Processing steps:
1. Extract and validate coordinates
2. Create Shapely polygons
3. Process building properties (height, levels, etc.)
4. Build spatial index for efficient querying</p>
<p>Height calculation rules:
- Use explicit height if available
- Calculate from levels * floor_height if height not available
- Calculate from floors * floor_height if levels not available
- Use NaN if no height information available</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filtered_buildings</strong> (<em>list</em>) – List of GeoJSON building features with properties</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(</dt><dd><p>list of tuples (polygon, height, min_height, is_inner, feature_id),
rtree spatial index for the polygons</p>
</dd>
</dl>
<p>)</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buildings</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Feature&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">]},</span>
<span class="gp">... </span>        <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;levels&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span>    <span class="c1"># ... more buildings ...</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygons</span><span class="p">,</span> <span class="n">spatial_idx</span> <span class="o">=</span> <span class="n">create_building_polygons</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.convert_format_lat_lon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">convert_format_lat_lon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_coords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#convert_format_lat_lon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.convert_format_lat_lon" title="Link to this definition">¶</a></dt>
<dd><p>Convert coordinate format and close polygon.
Input coordinates are already in [lon, lat] format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_coords</strong> (<em>list</em>) – List of [lon, lat] coordinates</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of [lon, lat] coordinates with first point repeated at end</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.filter_buildings">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">filter_buildings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geojson_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plotting_box</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#filter_buildings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.filter_buildings" title="Link to this definition">¶</a></dt>
<dd><p>Filter building features that intersect with a given bounding box.</p>
<p>This function filters a list of GeoJSON building features to keep only those
that intersect with a specified bounding box. It performs geometry validation
and handles invalid geometries gracefully.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geojson_data</strong> (<em>list</em>) – List of GeoJSON features representing buildings
Each feature must have valid ‘geometry’ property
Coordinates must be in same CRS as plotting_box
Invalid geometries will be skipped with warning</p></li>
<li><p><strong>plotting_box</strong> (<em>Polygon</em>) – Shapely polygon defining the bounding box
Must be a valid Shapely Polygon object
Must be in same coordinate system as geojson_data
Used for spatial intersection testing</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Filtered list of GeoJSON features that intersect with the bounding box</dt><dd><p>Features maintain their original structure
Invalid features are excluded
Order of features is preserved</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Validates polygon coordinates before processing</p></li>
<li><p>Skips features with invalid geometries</p></li>
<li><p>Reports validation and geometry errors</p></li>
<li><p>No coordinate system transformation is performed</p></li>
<li><p>Memory efficient as it creates new list only for valid features</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.extract_building_heights_from_geotiff">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">extract_building_heights_from_geotiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geotiff_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#extract_building_heights_from_geotiff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.extract_building_heights_from_geotiff" title="Link to this definition">¶</a></dt>
<dd><p>Extract building heights from a GeoTIFF raster for building footprints in a GeoDataFrame.</p>
<p>This function processes building footprints to extract height information from a GeoTIFF
raster file. It handles coordinate transformation between WGS84 (EPSG:4326) and the raster’s
CRS, and calculates average heights for each building footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geotiff_path</strong> (<em>str</em>) – Path to the GeoTIFF height raster file containing elevation data</p></li>
<li><p><strong>gdf</strong> (<em>gpd.GeoDataFrame</em>) – GeoDataFrame containing building footprints with geometry column
The GeoDataFrame should be in WGS84 (EPSG:4326) coordinate system</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Updated GeoDataFrame with extracted heights in the ‘height’ column</dt><dd><ul class="simple">
<li><p>Buildings with valid height data will have their height values updated</p></li>
<li><p>Buildings with no valid height data will have NaN values</p></li>
<li><p>Original buildings with existing valid heights are preserved</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<dl class="simple">
<dt>Statistics Reported:</dt><dd><ul class="simple">
<li><p>Total number of buildings without height data</p></li>
<li><p>Number of buildings successfully updated with height data</p></li>
<li><p>Number of buildings where no height data could be found</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The function only processes Polygon geometries (not MultiPolygons or other types)</p></li>
<li><p>Buildings are considered to need height processing if they have no height or height &lt;= 0</p></li>
<li><p>Heights are calculated as the mean of all valid raster values within the building footprint</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.extract_building_heights_from_gdf">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">extract_building_heights_from_gdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf_0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">geopandas.GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf_1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">geopandas.GeoDataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">geopandas.GeoDataFrame</span></span></span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#extract_building_heights_from_gdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.extract_building_heights_from_gdf" title="Link to this definition">¶</a></dt>
<dd><p>Extract building heights from one GeoDataFrame and apply them to another based on spatial overlap.</p>
<p>This function transfers height information from a reference GeoDataFrame to a primary GeoDataFrame
based on the spatial overlap between building footprints. For each building in the primary dataset
that needs height data, it calculates a weighted average height from overlapping buildings in the
reference dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf_0</strong> (<em>gpd.GeoDataFrame</em>) – Primary GeoDataFrame to update with heights
Must have ‘geometry’ column with building footprints
Will be updated with height values where missing or zero</p></li>
<li><p><strong>gdf_1</strong> (<em>gpd.GeoDataFrame</em>) – Reference GeoDataFrame containing height data
Must have ‘geometry’ column with building footprints
Must have ‘height’ column with valid height values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Updated primary GeoDataFrame with extracted heights</dt><dd><p>Buildings with overlapping reference data get weighted average heights
Buildings without overlapping data retain original height or get NaN</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<dl class="simple">
<dt>Statistics Tracked:</dt><dd><ul class="simple">
<li><p>count_0: Number of buildings without height in primary dataset</p></li>
<li><p>count_1: Number of buildings successfully updated with height</p></li>
<li><p>count_2: Number of buildings where no reference height data found</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Uses R-tree spatial indexing for efficient overlap detection</p></li>
<li><p>Handles invalid geometries by attempting to fix them with buffer(0)</p></li>
<li><p>Weighted average is based on the area of overlap between buildings</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.complement_building_heights_from_gdf">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">complement_building_heights_from_gdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">primary_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'id'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'id'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#complement_building_heights_from_gdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.complement_building_heights_from_gdf" title="Link to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Use a vectorized approach with GeoPandas to:</dt><dd><ol class="arabic simple">
<li><p>Find intersections and compute weighted average heights</p></li>
<li><p>Update heights in the primary dataset</p></li>
<li><p>Add non-intersecting buildings from the reference dataset</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf_0</strong> (<em>gpd.GeoDataFrame</em>) – Primary GeoDataFrame</p></li>
<li><p><strong>gdf_1</strong> (<em>gpd.GeoDataFrame</em>) – Reference GeoDataFrame</p></li>
<li><p><strong>primary_id</strong> (<em>str</em>) – Name of the unique identifier in primary dataset’s properties</p></li>
<li><p><strong>ref_id</strong> (<em>str</em>) – Name of the unique identifier in reference dataset’s properties</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Updated GeoDataFrame (including new buildings).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.process_building_footprints_by_overlap">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">process_building_footprints_by_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filtered_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#process_building_footprints_by_overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.process_building_footprints_by_overlap" title="Link to this definition">¶</a></dt>
<dd><p>Process building footprints to merge overlapping buildings based on area overlap ratio.</p>
<p>This function identifies and merges building footprints that significantly overlap with each other.
Buildings are processed in order of decreasing area, and smaller buildings that overlap significantly
with larger ones are assigned the ID of the larger building, effectively merging them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filtered_gdf</strong> (<em>geopandas.GeoDataFrame</em>) – GeoDataFrame containing building footprints
Must have ‘geometry’ column with building polygons
If CRS is set, areas will be calculated in Web Mercator projection</p></li>
<li><p><strong>overlap_threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – Threshold for overlap ratio (0.0-1.0) to merge buildings
Default is 0.5 (50% overlap)
Higher values require more overlap for merging
Lower values will result in more aggressive merging</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Processed GeoDataFrame with updated IDs</dt><dd><p>Overlapping buildings will share the same ID
Original geometries are preserved, only IDs are updated
All other columns remain unchanged</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>geopandas.GeoDataFrame</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Uses R-tree spatial indexing for efficient overlap detection</p></li>
<li><p>Projects to Web Mercator (EPSG:3857) for accurate area calculation if CRS is set</p></li>
<li><p>Handles invalid geometries by attempting to fix them with buffer(0)</p></li>
<li><p>Processes buildings in order of decreasing area (largest first)</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_class_priority">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_class_priority</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/utils/lc.html#get_class_priority"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_class_priority" title="Link to this definition">¶</a></dt>
<dd><p>Get priority rankings for land cover classes to resolve conflicts during classification.</p>
<p>When multiple land cover classes are present in the same area, this priority system
determines which class should take precedence. Higher priority values indicate
classes that should override lower priority classes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>source</strong> (<em>str</em>) – Name of the land cover data source</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dictionary mapping class names to priority values (higher = more priority)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<dl class="simple">
<dt>Priority Logic for OpenStreetMap:</dt><dd><ul class="simple">
<li><p>Built Environment: Highest priority (most definitive structures)</p></li>
<li><p>Water Bodies: High priority (clearly defined features)</p></li>
<li><p>Vegetation: Medium priority (managed vs natural)</p></li>
<li><p>Natural Non-Vegetation: Lower priority (often default classifications)</p></li>
<li><p>Uncertain/No Data: Lowest priority</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_land_cover_polygons">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_land_cover_polygons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">land_cover_geojson</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/utils/lc.html#create_land_cover_polygons"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_land_cover_polygons" title="Link to this definition">¶</a></dt>
<dd><p>Create polygon geometries and spatial index from land cover GeoJSON data.</p>
<p>This function processes GeoJSON land cover data to create Shapely polygon
geometries and builds an R-tree spatial index for efficient spatial queries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>land_cover_geojson</strong> (<em>list</em>) – List of GeoJSON feature dictionaries containing
land cover polygons with geometry and properties</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple containing:</dt><dd><ul class="simple">
<li><p>land_cover_polygons (list): List of tuples (polygon, class_name)</p></li>
<li><p>idx (rtree.index.Index): Spatial index for efficient polygon lookup</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each GeoJSON feature should have:
- geometry.coordinates[0]: List of coordinate pairs defining the polygon
- properties.class: String indicating the land cover class</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_dominant_class">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_dominant_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">land_cover_classes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/utils/lc.html#get_dominant_class"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_dominant_class" title="Link to this definition">¶</a></dt>
<dd><p>Determine the dominant land cover class in a cell based on pixel majority.</p>
<p>This function analyzes all pixels within a cell, classifies each pixel to its
nearest land cover class, and returns the most frequently occurring class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_data</strong> (<em>numpy.ndarray</em>) – 3D array of RGB pixel data for the cell</p></li>
<li><p><strong>land_cover_classes</strong> (<em>dict</em>) – Dictionary mapping RGB tuples to class names</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Name of the dominant land cover class in the cell</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the cell contains no data, returns ‘No Data’</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_roi">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_roi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_coords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/downloader/gee.html#get_roi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_roi" title="Link to this definition">¶</a></dt>
<dd><p>Create an Earth Engine region of interest polygon from coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_coords</strong> – List of coordinate pairs defining the polygon vertices in (lon, lat) format.
The coordinates should form a valid polygon (non-self-intersecting).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Earth Engine polygon geometry representing the ROI</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ee.Geometry.Polygon</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function automatically closes the polygon by connecting the last vertex
to the first vertex if they are not the same.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.save_geotiff_open_buildings_temporal">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">save_geotiff_open_buildings_temporal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aoi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geotiff_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/downloader/gee.html#save_geotiff_open_buildings_temporal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.save_geotiff_open_buildings_temporal" title="Link to this definition">¶</a></dt>
<dd><p>Save Open Buildings temporal data as a GeoTIFF.</p>
<p>Downloads and exports building height data from Google’s Open Buildings dataset.
This dataset provides building footprints and heights derived from satellite imagery.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aoi</strong> – Earth Engine geometry defining area of interest</p></li>
<li><p><strong>geotiff_path</strong> – Output path for GeoTIFF file</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The output GeoTIFF contains building heights in meters</p></li>
<li><p>The dataset is updated periodically and may not cover all regions</p></li>
<li><p>Resolution is fixed at 4 meters per pixel</p></li>
<li><p>Areas without buildings will have no-data values</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.apply_operation">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">apply_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#apply_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.apply_operation" title="Link to this definition">¶</a></dt>
<dd><p>Applies a sequence of operations to an array based on a mesh size to normalize and discretize values.</p>
<p>This function performs the following sequence of operations:
1. Divides array by mesh size to normalize values
2. Adds 0.5 to round values to nearest integer
3. Floors the result to get integer values
4. Scales back to original units by multiplying by mesh size</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>numpy.ndarray</em>) – Input array to transform</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of mesh to use for calculations</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformed array after applying operations</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">meshsize</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">apply_operation</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">meshsize</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.translate_array">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">translate_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation_dict</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#translate_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.translate_array" title="Link to this definition">¶</a></dt>
<dd><p>Translates values in an array according to a dictionary mapping.</p>
<p>This function creates a new array where each value from the input array
is replaced by its corresponding value from the translation dictionary.
Values not found in the dictionary are replaced with empty strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_array</strong> (<em>numpy.ndarray</em>) – Array containing values to translate</p></li>
<li><p><strong>translation_dict</strong> (<em>dict</em>) – Dictionary mapping input values to output values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array with translated values, with same shape as input array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">translate_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">trans_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># result = array([[&#39;A&#39;, &#39;B&#39;], [&#39;C&#39;, &#39;D&#39;]], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.group_and_label_cells">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">group_and_label_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#group_and_label_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.group_and_label_cells" title="Link to this definition">¶</a></dt>
<dd><p>Convert non-zero numbers in a 2D numpy array to sequential IDs starting from 1.</p>
<p>This function creates a new array where all non-zero values are replaced with
sequential IDs (1, 2, 3, etc.) while preserving zero values. This is useful
for labeling distinct regions or features in a grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>array</strong> (<em>numpy.ndarray</em>) – Input 2D array with non-zero values to be labeled</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Array with non-zero values converted to sequential IDs,</dt><dd><p>maintaining the same shape as input array</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">group_and_label_cells</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># result = array([[0, 1, 1], [0, 1, 2], [0, 0, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.process_grid">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">process_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_bi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem_grid</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#process_grid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.process_grid" title="Link to this definition">¶</a></dt>
<dd><p>Process a binary grid and DEM grid to create averaged elevation values.</p>
<p>This function takes a binary grid identifying regions and a corresponding DEM
grid with elevation values. For each non-zero region in the binary grid, it
calculates the mean elevation from the DEM grid and assigns this average to
all cells in that region. The result is normalized by subtracting the minimum value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_bi</strong> (<em>numpy.ndarray</em>) – Binary grid indicating regions (0 for background,
non-zero for different regions)</p></li>
<li><p><strong>dem_grid</strong> (<em>numpy.ndarray</em>) – Grid of elevation values corresponding to the
same spatial extent as grid_bi</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Processed grid with averaged and normalized elevation values.</dt><dd><p>Same shape as input grids.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binary_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elevation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span> <span class="p">[</span><span class="mi">105</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">120</span><span class="p">],</span> <span class="p">[</span><span class="mi">95</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">130</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">process_grid</span><span class="p">(</span><span class="n">binary_grid</span><span class="p">,</span> <span class="n">elevation</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.calculate_grid_size">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">calculate_grid_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">side_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">side_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#calculate_grid_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.calculate_grid_size" title="Link to this definition">¶</a></dt>
<dd><p>Calculate grid size and adjusted mesh size based on input parameters.</p>
<p>This function determines the number of grid cells needed in each direction and
adjusts the mesh size to exactly fit the desired area. The calculation takes into
account the input vectors and desired mesh size to ensure proper coverage.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>side_1</strong> (<em>numpy.ndarray</em>) – First side vector defining the grid extent</p></li>
<li><p><strong>side_2</strong> (<em>numpy.ndarray</em>) – Second side vector defining the grid extent</p></li>
<li><p><strong>u_vec</strong> (<em>numpy.ndarray</em>) – Unit vector in first direction</p></li>
<li><p><strong>v_vec</strong> (<em>numpy.ndarray</em>) – Unit vector in second direction</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Desired mesh size in the same units as the vectors</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tuple containing:</dt><dd><ul class="simple">
<li><p>grid_size (tuple of ints): Number of cells in each direction (nx, ny)</p></li>
<li><p>adjusted_mesh_size (tuple of floats): Actual mesh sizes that fit the area exactly</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">side1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># 100 units in x direction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">side2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">])</span>   <span class="c1"># 50 units in y direction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>        <span class="c1"># Unit vector in x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>        <span class="c1"># Unit vector in y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="mi">10</span>                    <span class="c1"># Desired 10-unit mesh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid_size</span><span class="p">,</span> <span class="n">adj_mesh</span> <span class="o">=</span> <span class="n">calculate_grid_size</span><span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="n">side2</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mesh</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_coordinate_mesh">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_coordinate_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjusted_meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_vec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_coordinate_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_coordinate_mesh" title="Link to this definition">¶</a></dt>
<dd><p>Create a coordinate mesh based on input parameters.</p>
<p>This function generates a 3D array representing a coordinate mesh, where each point
in the mesh is calculated by adding scaled vectors to the origin point. The mesh
is created using the specified grid size and adjusted mesh sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>numpy.ndarray</em>) – Origin point coordinates (shape: (2,) or (3,))</p></li>
<li><p><strong>grid_size</strong> (<em>tuple</em>) – Size of grid in each dimension (nx, ny)</p></li>
<li><p><strong>adjusted_meshsize</strong> (<em>tuple</em>) – Adjusted mesh size in each dimension (dx, dy)</p></li>
<li><p><strong>u_vec</strong> (<em>numpy.ndarray</em>) – Unit vector in first direction</p></li>
<li><p><strong>v_vec</strong> (<em>numpy.ndarray</em>) – Unit vector in second direction</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>3D array of shape (coord_dim, ny, nx) containing the coordinates</dt><dd><p>of each point in the mesh. coord_dim is the same as the
dimensionality of the input vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">create_coordinate_mesh</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_cell_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_cell_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjusted_meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u_vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_vec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_cell_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_cell_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a polygon representing a grid cell.</p>
<p>This function generates a rectangular polygon for a specific grid cell by calculating
its four corners based on the cell indices and grid parameters. The polygon is
created in counter-clockwise order starting from the bottom-left corner.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>numpy.ndarray</em>) – Origin point coordinates (shape: (2,) or (3,))</p></li>
<li><p><strong>i</strong> (<em>int</em>) – Row index of the cell</p></li>
<li><p><strong>j</strong> (<em>int</em>) – Column index of the cell</p></li>
<li><p><strong>adjusted_meshsize</strong> (<em>tuple</em>) – Adjusted mesh size in each dimension (dx, dy)</p></li>
<li><p><strong>u_vec</strong> (<em>numpy.ndarray</em>) – Unit vector in first direction</p></li>
<li><p><strong>v_vec</strong> (<em>numpy.ndarray</em>) – Unit vector in second direction</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Polygon representing the grid cell, with vertices</dt><dd><p>ordered counter-clockwise from bottom-left</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>shapely.geometry.Polygon</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>  <span class="c1"># Cell at row 1, column 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell_poly</span> <span class="o">=</span> <span class="n">create_cell_polygon</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.tree_height_grid_from_land_cover">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">tree_height_grid_from_land_cover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">land_cover_grid_ori</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#tree_height_grid_from_land_cover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.tree_height_grid_from_land_cover" title="Link to this definition">¶</a></dt>
<dd><p>Convert a land cover grid to a tree height grid.</p>
<p>This function transforms a land cover classification grid into a grid of tree heights
by mapping land cover classes to predefined tree heights. The function first flips
the input grid vertically and adjusts class values, then applies a translation
dictionary to convert classes to heights.</p>
<p>Land cover class to tree height mapping:
- Class 4 (Forest): 10m height
- All other classes: 0m height</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>land_cover_grid_ori</strong> (<em>numpy.ndarray</em>) – Original land cover grid with class values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Grid of tree heights in meters, with same dimensions as input</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lc_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree_heights</span> <span class="o">=</span> <span class="n">tree_height_grid_from_land_cover</span><span class="p">(</span><span class="n">lc_grid</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Result: array([[0, 10, 0], [10, 0, 10], [0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_land_cover_grid_from_geotiff_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_land_cover_grid_from_geotiff_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tiff_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">land_cover_classes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_land_cover_grid_from_geotiff_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_land_cover_grid_from_geotiff_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a land cover grid from a GeoTIFF file within a polygon boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tiff_path</strong> (<em>str</em>) – Path to GeoTIFF file</p></li>
<li><p><strong>mesh_size</strong> (<em>float</em>) – Size of mesh cells</p></li>
<li><p><strong>land_cover_classes</strong> (<em>dict</em>) – Dictionary mapping land cover classes</p></li>
<li><p><strong>polygon</strong> (<em>list</em>) – List of polygon vertices</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Grid of land cover classes within the polygon</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_land_cover_grid_from_gdf_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_land_cover_grid_from_gdf_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_land_cover_grid_from_gdf_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_land_cover_grid_from_gdf_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a grid of land cover classes from GeoDataFrame polygon data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing land cover polygons</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each grid cell in meters</p></li>
<li><p><strong>source</strong> (<em>str</em>) – Source of the land cover data to determine class priorities</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of 4 (lon,lat) coordinate pairs defining the rectangle bounds</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D grid of land cover classes as strings</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p>The function creates a regular grid over the given rectangle area and determines the dominant
land cover class for each cell based on polygon intersections. Classes are assigned based on
priority rules and majority area coverage.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_height_grid_from_geotiff_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_height_grid_from_geotiff_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tiff_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_height_grid_from_geotiff_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_height_grid_from_geotiff_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a height grid from a GeoTIFF file within a polygon boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tiff_path</strong> (<em>str</em>) – Path to GeoTIFF file</p></li>
<li><p><strong>mesh_size</strong> (<em>float</em>) – Size of mesh cells</p></li>
<li><p><strong>polygon</strong> (<em>list</em>) – List of polygon vertices</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Grid of heights within the polygon</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_building_height_grid_from_gdf_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_building_height_grid_from_gdf_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf_comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geotiff_path_comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complement_building_footprints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complement_height</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_building_height_grid_from_gdf_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_building_height_grid_from_gdf_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a building height grid from GeoDataFrame data within a polygon boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf</strong> (<em>geopandas.GeoDataFrame</em>) – GeoDataFrame containing building information</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of mesh cells</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of rectangle vertices defining the boundary</p></li>
<li><p><strong>gdf_comp</strong> (<em>geopandas.GeoDataFrame</em><em>, </em><em>optional</em>) – Complementary GeoDataFrame</p></li>
<li><p><strong>geotiff_path_comp</strong> (<em>str</em><em>, </em><em>optional</em>) – Path to complementary GeoTIFF file</p></li>
<li><p><strong>complement_building_footprints</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to complement footprints</p></li>
<li><p><strong>complement_height</strong> (<em>float</em><em>, </em><em>optional</em>) – Height value to use for buildings with height=0</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(building_height_grid, building_min_height_grid, building_id_grid, filtered_buildings)</dt><dd><ul class="simple">
<li><p>building_height_grid (numpy.ndarray): Grid of building heights</p></li>
<li><p>building_min_height_grid (numpy.ndarray): Grid of min building heights (list per cell)</p></li>
<li><p>building_id_grid (numpy.ndarray): Grid of building IDs</p></li>
<li><p>filtered_buildings (geopandas.GeoDataFrame): The buildings used (filtered_gdf)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_building_height_grid_from_open_building_temporal_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_building_height_grid_from_open_building_temporal_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_building_height_grid_from_open_building_temporal_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_building_height_grid_from_open_building_temporal_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a building height grid from OpenBuildings temporal data within a polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of mesh cells</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of rectangle vertices defining the boundary</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to save intermediate GeoTIFF files</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(building_height_grid, building_min_height_grid, building_id_grid, filtered_buildings)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_dem_grid_from_geotiff_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_dem_grid_from_geotiff_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tiff_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem_interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_dem_grid_from_geotiff_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_dem_grid_from_geotiff_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a Digital Elevation Model (DEM) grid from a GeoTIFF file within a polygon boundary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tiff_path</strong> (<em>str</em>) – Path to GeoTIFF file</p></li>
<li><p><strong>mesh_size</strong> (<em>float</em>) – Size of mesh cells</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of rectangle vertices defining the boundary</p></li>
<li><p><strong>dem_interpolation</strong> (<em>bool</em>) – Whether to use cubic interpolation for smoother results</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Grid of elevation values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.grid_to_geodataframe">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">grid_to_geodataframe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#grid_to_geodataframe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.grid_to_geodataframe" title="Link to this definition">¶</a></dt>
<dd><p>Converts a 2D grid to a GeoDataFrame with cell polygons and values.</p>
<p>This function transforms a regular grid into a GeoDataFrame where each cell is
represented as a polygon. The transformation handles coordinate systems properly,
converting between WGS84 (EPSG:4326) and Web Mercator (EPSG:3857) for accurate
distance calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_ori</strong> (<em>numpy.ndarray</em>) – 2D array containing grid values</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of [lon, lat] coordinates defining area corners.
Should be in WGS84 (EPSG:4326) format.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each grid cell in meters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A GeoDataFrame with columns:</dt><dd><ul class="simple">
<li><p>geometry: Polygon geometry of each grid cell in WGS84 (EPSG:4326)</p></li>
<li><p>value: Value from the original grid</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">],</span> <span class="p">[</span><span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">],</span> <span class="p">[</span><span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">],</span> <span class="p">[</span><span class="n">lon4</span><span class="p">,</span> <span class="n">lat4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh_size</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># 100 meters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">grid_to_geodataframe</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input grid is flipped vertically before processing to match geographic
orientation (north at top)</p></li>
<li><p>The output GeoDataFrame uses WGS84 (EPSG:4326) coordinate system</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.grid_to_point_geodataframe">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">grid_to_point_geodataframe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#grid_to_point_geodataframe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.grid_to_point_geodataframe" title="Link to this definition">¶</a></dt>
<dd><p>Converts a 2D grid to a GeoDataFrame with point geometries at cell centers and values.</p>
<p>This function transforms a regular grid into a GeoDataFrame where each cell is
represented by a point at its center. The transformation handles coordinate systems
properly, converting between WGS84 (EPSG:4326) and Web Mercator (EPSG:3857) for
accurate distance calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_ori</strong> (<em>numpy.ndarray</em>) – 2D array containing grid values</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of [lon, lat] coordinates defining area corners.
Should be in WGS84 (EPSG:4326) format.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each grid cell in meters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A GeoDataFrame with columns:</dt><dd><ul class="simple">
<li><p>geometry: Point geometry at center of each grid cell in WGS84 (EPSG:4326)</p></li>
<li><p>value: Value from the original grid</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">],</span> <span class="p">[</span><span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">],</span> <span class="p">[</span><span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">],</span> <span class="p">[</span><span class="n">lon4</span><span class="p">,</span> <span class="n">lat4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh_size</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># 100 meters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">grid_to_point_geodataframe</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input grid is flipped vertically before processing to match geographic
orientation (north at top)</p></li>
<li><p>The output GeoDataFrame uses WGS84 (EPSG:4326) coordinate system</p></li>
<li><p>Points are placed at the center of each grid cell</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_vegetation_height_grid_from_gdf_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_vegetation_height_grid_from_gdf_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">veg_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_vegetation_height_grid_from_gdf_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_vegetation_height_grid_from_gdf_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a vegetation height grid from a GeoDataFrame of vegetation polygons/objects
within the bounding box of a given polygon, at a specified mesh spacing.
Cells that intersect one or more vegetation polygons receive the
(by default) maximum vegetation height among intersecting polygons.
Cells that do not intersect any vegetation are set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>veg_gdf</strong> (<em>GeoDataFrame</em>) – A GeoDataFrame containing vegetation features
(usually polygons) with a ‘height’ column
(or a similarly named attribute). Must be in
EPSG:4326 or reprojectable to it.</p></li>
<li><p><strong>mesh_size</strong> (<em>float</em>) – Desired grid spacing in meters.</p></li>
<li><p><strong>polygon</strong> (<em>list</em><em> or </em><em>Polygon</em>) – <ul>
<li><p>If a list of (lon, lat) coords, will be converted to a shapely Polygon
in EPSG:4326.</p></li>
<li><p>If a shapely Polygon, it must be in or reprojectable to EPSG:4326.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of vegetation height values covering the bounding box</dt><dd><p>of the polygon. The array is indexed [row, col] from top row
(north) to bottom row (south). Cells with no intersecting
vegetation are set to 0.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_dem_grid_from_gdf_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_dem_grid_from_gdf_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">terrain_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#create_dem_grid_from_gdf_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_dem_grid_from_gdf_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a height grid from a terrain GeoDataFrame within the bounding box
of the given polygon, using nearest-neighbor sampling of elevations.
Edges of the bounding box will also receive a nearest elevation,
so there should be no NaNs around edges if data coverage is sufficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>terrain_gdf</strong> (<em>GeoDataFrame</em>) – A GeoDataFrame containing terrain features
(points or centroids) with an ‘elevation’ column.
Must be in EPSG:4326 or reprojectable to it.</p></li>
<li><p><strong>mesh_size</strong> (<em>float</em>) – Desired grid spacing in meters.</p></li>
<li><p><strong>polygon</strong> (<em>list</em><em> or </em><em>Polygon</em>) – <p>Polygon specifying the region of interest.
- If list of (lon, lat), will be made into a Polygon.
- If a shapely Polygon, must be in WGS84 (EPSG:4326)</p>
<blockquote>
<div><p>or reprojected to it.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of height values covering the bounding box of the polygon,</dt><dd><p>from top row (north) to bottom row (south). Any location not
matched by terrain_gdf data remains NaN, but edges will not
automatically be NaN if terrain coverage exists.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="voxcity.geoprocessor.floor_height">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">floor_height</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2.5</span></em><a class="headerlink" href="#voxcity.geoprocessor.floor_height" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.tile_from_lat_lon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">tile_from_lat_lon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_of_detail</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#tile_from_lat_lon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.tile_from_lat_lon" title="Link to this definition">¶</a></dt>
<dd><p>Convert latitude/longitude coordinates to tile coordinates at a given zoom level.
Uses the Web Mercator projection (EPSG:3857) commonly used in web mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat</strong> (<em>float</em>) – Latitude in degrees (-90 to 90)</p></li>
<li><p><strong>lon</strong> (<em>float</em>) – Longitude in degrees (-180 to 180)</p></li>
<li><p><strong>level_of_detail</strong> (<em>int</em>) – Zoom level (0-23, where 0 is the entire world)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(tile_x, tile_y) tile coordinates in the global tile grid</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span> <span class="o">=</span> <span class="n">tile_from_lat_lon</span><span class="p">(</span><span class="mf">35.6762</span><span class="p">,</span> <span class="mf">139.6503</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>  <span class="c1"># Tokyo at zoom 12</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.quadkey_to_tile">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">quadkey_to_tile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quadkey</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#quadkey_to_tile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.quadkey_to_tile" title="Link to this definition">¶</a></dt>
<dd><p>Convert a quadkey string to tile coordinates.
A quadkey is a string of digits (0-3) that identifies a tile at a certain zoom level.
Each digit in the quadkey represents a tile at a zoom level, with each subsequent digit
representing a more detailed zoom level.</p>
<dl class="simple">
<dt>The quadkey numbering scheme:</dt><dd><ul class="simple">
<li><p>0: Top-left quadrant</p></li>
<li><p>1: Top-right quadrant</p></li>
<li><p>2: Bottom-left quadrant</p></li>
<li><p>3: Bottom-right quadrant</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quadkey</strong> (<em>str</em>) – Quadkey string (e.g., “120” for zoom level 3)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(tile_x, tile_y, level_of_detail) tile coordinates and zoom level</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">zoom</span> <span class="o">=</span> <span class="n">quadkey_to_tile</span><span class="p">(</span><span class="s2">&quot;120&quot;</span><span class="p">)</span>  <span class="c1"># Returns coordinates at zoom level 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">initialize_geod</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#initialize_geod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Link to this definition">¶</a></dt>
<dd><p>Initialize a Geod object for geodetic calculations using WGS84 ellipsoid.
The WGS84 ellipsoid (EPSG:4326) is the standard reference system used by GPS
and most modern mapping applications.</p>
<p>The Geod object provides methods for:
- Forward geodetic calculations (direct)
- Inverse geodetic calculations (inverse)
- Area calculations
- Line length calculations</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Initialized Geod object for WGS84 calculations</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Geod</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geod</span> <span class="o">=</span> <span class="n">initialize_geod</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fwd_az</span><span class="p">,</span> <span class="n">back_az</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id1">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">calculate_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#calculate_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id1" title="Link to this definition">¶</a></dt>
<dd><p>Calculate geodetic distance between two points on the Earth’s surface.
Uses inverse geodetic computation to find the shortest distance along the ellipsoid,
which is more accurate than great circle (spherical) calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geod</strong> (<em>Geod</em>) – Geod object for calculations, initialized with WGS84</p></li>
<li><p><strong>lon1</strong> (<em>float</em>) – Coordinates of first point in decimal degrees</p></li>
<li><p><strong>lat1</strong> (<em>float</em>) – Coordinates of first point in decimal degrees</p></li>
<li><p><strong>lon2</strong> (<em>float</em>) – Coordinates of second point in decimal degrees</p></li>
<li><p><strong>lat2</strong> (<em>float</em>) – Coordinates of second point in decimal degrees</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Distance in meters between the two points along the ellipsoid</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geod</span> <span class="o">=</span> <span class="n">initialize_geod</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span> <span class="o">=</span> <span class="n">calculate_distance</span><span class="p">(</span><span class="n">geod</span><span class="p">,</span> <span class="mf">139.6503</span><span class="p">,</span> <span class="mf">35.6762</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="o">-</span><span class="mf">74.0060</span><span class="p">,</span> <span class="mf">40.7128</span><span class="p">)</span>  <span class="c1"># Tokyo to NYC</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id2">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">normalize_to_one_meter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_in_meters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#normalize_to_one_meter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id2" title="Link to this definition">¶</a></dt>
<dd><p>Normalize a vector to represent one meter in geographic space.
Useful for creating unit vectors in geographic calculations, particularly
when working with distance-based operations or scaling geographic features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vector</strong> (<em>numpy.ndarray</em>) – Vector to normalize, typically a direction vector</p></li>
<li><p><strong>distance_in_meters</strong> (<em>float</em>) – Current distance in meters that the vector represents</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Normalized vector where magnitude represents 1 meter</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">])</span>  <span class="c1"># Vector of length 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unit_meter</span> <span class="o">=</span> <span class="n">normalize_to_one_meter</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.setup_transformer">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">setup_transformer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_crs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_crs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#setup_transformer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.setup_transformer" title="Link to this definition">¶</a></dt>
<dd><p>Set up a coordinate transformer between two Coordinate Reference Systems (CRS).
The always_xy=True parameter ensures consistent handling of coordinate order
by always using (x,y) or (longitude,latitude) order regardless of CRS definition.</p>
<p>Common CRS codes:
- EPSG:4326 - WGS84 (latitude/longitude)
- EPSG:3857 - Web Mercator
- EPSG:2263 - NY State Plane</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_crs</strong> – Source coordinate reference system (EPSG code, proj4 string, or CRS dict)</p></li>
<li><p><strong>to_crs</strong> – Target coordinate reference system (EPSG code, proj4 string, or CRS dict)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Initialized transformer object for coordinate conversion</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Transformer</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">setup_transformer</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="s2">&quot;EPSG:3857&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.transform_coords">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">transform_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transformer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#transform_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.transform_coords" title="Link to this definition">¶</a></dt>
<dd><p>Transform coordinates using provided transformer with error handling.
Includes validation for infinite values that may result from invalid transformations
or coordinates outside the valid range for the target CRS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transformer</strong> (<em>Transformer</em>) – Coordinate transformer from setup_transformer()</p></li>
<li><p><strong>lon</strong> (<em>float</em>) – Input coordinates in the source CRS</p></li>
<li><p><strong>lat</strong> (<em>float</em>) – Input coordinates in the source CRS</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(x, y) transformed coordinates in the target CRS, or (None, None) if transformation fails</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transformer</span> <span class="o">=</span> <span class="n">setup_transformer</span><span class="p">(</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">,</span> <span class="s2">&quot;EPSG:3857&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">transform_coords</span><span class="p">(</span><span class="n">transformer</span><span class="p">,</span> <span class="o">-</span><span class="mf">74.0060</span><span class="p">,</span> <span class="mf">40.7128</span><span class="p">)</span>  <span class="c1"># NYC coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transformed coordinates: (</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#create_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Create a Shapely polygon from a list of vertices.
Input vertices must be in (longitude, latitude) format as required by Shapely.
The polygon will be automatically closed if the first and last vertices don’t match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vertices</strong> (<em>list</em>) – List of (longitude, latitude) coordinate pairs forming the polygon.
The coordinates should be in counter-clockwise order for exterior rings
and clockwise order for interior rings (holes).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Shapely polygon object that can be used for spatial operations</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Polygon</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>  <span class="c1"># Square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">create_polygon</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Polygon area: </span><span class="si">{</span><span class="n">polygon</span><span class="o">.</span><span class="n">area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_geodataframe">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_geodataframe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4326</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#create_geodataframe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_geodataframe" title="Link to this definition">¶</a></dt>
<dd><p>Create a GeoDataFrame from a Shapely polygon.
Default CRS is WGS84 (EPSG:4326) for geographic coordinates.
The GeoDataFrame provides additional functionality for spatial operations,
data analysis, and export to various geographic formats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>polygon</strong> (<em>Polygon</em>) – Shapely polygon object to convert</p></li>
<li><p><strong>crs</strong> (<em>int</em>) – Coordinate reference system EPSG code (default: 4326 for WGS84)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>GeoDataFrame containing the polygon with specified CRS</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygon</span> <span class="o">=</span> <span class="n">create_polygon</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">create_geodataframe</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s2">&quot;polygon.geojson&quot;</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.haversine_distance">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">haversine_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#haversine_distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.haversine_distance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate great-circle distance between two points using Haversine formula.
This is an approximation that treats the Earth as a perfect sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon1</strong> (<em>float</em>) – Coordinates of first point</p></li>
<li><p><strong>lat1</strong> (<em>float</em>) – Coordinates of first point</p></li>
<li><p><strong>lon2</strong> (<em>float</em>) – Coordinates of second point</p></li>
<li><p><strong>lat2</strong> (<em>float</em>) – Coordinates of second point</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Distance in kilometers</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_raster_bbox">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_raster_bbox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raster_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#get_raster_bbox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_raster_bbox" title="Link to this definition">¶</a></dt>
<dd><p>Get the bounding box of a raster file in its native coordinate system.
Returns a rectangular polygon representing the spatial extent of the raster,
which can be used for spatial queries and intersection tests.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>raster_path</strong> (<em>str</em>) – Path to the raster file (GeoTIFF, IMG, etc.)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Shapely box representing the raster bounds in the raster’s CRS</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>box</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bbox</span> <span class="o">=</span> <span class="n">get_raster_bbox</span><span class="p">(</span><span class="s2">&quot;elevation.tif&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Raster extent: </span><span class="si">{</span><span class="n">bbox</span><span class="o">.</span><span class="n">bounds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># (minx, miny, maxx, maxy)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.raster_intersects_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">raster_intersects_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raster_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polygon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#raster_intersects_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.raster_intersects_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Check if a raster file’s extent intersects with a given polygon.
Automatically handles coordinate system transformations by converting
the raster bounds to WGS84 (EPSG:4326) if needed before the intersection test.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>raster_path</strong> (<em>str</em>) – Path to the raster file to check</p></li>
<li><p><strong>polygon</strong> (<em>Polygon</em>) – Shapely polygon to test intersection with (in WGS84)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if raster intersects or contains the polygon, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aoi</span> <span class="o">=</span> <span class="n">create_polygon</span><span class="p">([(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">),</span> <span class="p">(</span><span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">),</span> <span class="o">...</span><span class="p">])</span>  <span class="c1"># Area of interest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">raster_intersects_polygon</span><span class="p">(</span><span class="s2">&quot;dem.tif&quot;</span><span class="p">,</span> <span class="n">aoi</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Raster covers the area of interest&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.save_raster">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">save_raster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#save_raster"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.save_raster" title="Link to this definition">¶</a></dt>
<dd><p>Create a copy of a raster file at a new location.
Performs a direct file copy without any transformation or modification,
preserving all metadata, georeferencing, and pixel values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_path</strong> (<em>str</em>) – Source raster file path</p></li>
<li><p><strong>output_path</strong> (<em>str</em>) – Destination path for the copied raster</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">save_raster</span><span class="p">(</span><span class="s2">&quot;original.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;backup/copy.tif&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Copied original file to: backup/copy.tif&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.merge_geotiffs">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">merge_geotiffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geotiff_files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#merge_geotiffs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.merge_geotiffs" title="Link to this definition">¶</a></dt>
<dd><p>Merge multiple GeoTIFF files into a single mosaic.
Handles edge matching and overlapping areas between adjacent rasters.
The output will have the same coordinate system and data type as the input files.</p>
<p>Important considerations:
- All input files should have the same coordinate system
- All input files should have the same data type
- Overlapping areas are handled by taking the first value encountered</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geotiff_files</strong> (<em>list</em>) – List of paths to GeoTIFF files to merge</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory where the merged output will be saved</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tile1.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;tile2.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;tile3.tif&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">merge_geotiffs</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="s2">&quot;output_directory&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merged output saved to: output_directory/lulc.tif&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id3">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">convert_format_lat_lon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_coords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#convert_format_lat_lon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id3" title="Link to this definition">¶</a></dt>
<dd><p>Convert coordinate format and close polygon.
Input coordinates are already in [lon, lat] format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_coords</strong> (<em>list</em>) – List of [lon, lat] coordinates</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of [lon, lat] coordinates with first point repeated at end</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id4">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_coordinates_from_cityname</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">place_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#get_coordinates_from_cityname"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id4" title="Link to this definition">¶</a></dt>
<dd><p>Geocode a city name to get its coordinates using OpenStreetMap’s Nominatim service.
Includes rate limiting and error handling to comply with Nominatim’s usage policy.</p>
<p>Note:
- Results may vary based on the specificity of the place name
- For better results, include country or state information
- Service has usage limits and may timeout</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>place_name</strong> (<em>str</em>) – Name of the city to geocode (e.g., “Tokyo, Japan”)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(latitude, longitude) coordinates or None if geocoding fails</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">get_coordinates_from_cityname</span><span class="p">(</span><span class="s2">&quot;Paris, France&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">coords</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Paris coordinates: </span><span class="si">{</span><span class="n">lat</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">lon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_city_country_name_from_rectangle">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_city_country_name_from_rectangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#get_city_country_name_from_rectangle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_city_country_name_from_rectangle" title="Link to this definition">¶</a></dt>
<dd><p>Get the city and country name for a location defined by a rectangle.
Uses reverse geocoding to find the nearest named place to the rectangle’s center.</p>
<p>The function:
1. Calculates the center point of the rectangle
2. Performs reverse geocoding with rate limiting
3. Extracts city and country information from the result</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>coordinates</strong> (<em>list</em>) – List of (longitude, latitude) coordinates defining the rectangle</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>String in format “city/ country” or fallback value if lookup fails</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">139.65</span><span class="p">,</span> <span class="mf">35.67</span><span class="p">),</span> <span class="p">(</span><span class="mf">139.66</span><span class="p">,</span> <span class="mf">35.67</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="mf">139.66</span><span class="p">,</span> <span class="mf">35.68</span><span class="p">),</span> <span class="p">(</span><span class="mf">139.65</span><span class="p">,</span> <span class="mf">35.68</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">location</span> <span class="o">=</span> <span class="n">get_city_country_name_from_rectangle</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Location: </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># e.g., &quot;Shibuya/ Japan&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_timezone_info">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_timezone_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rectangle_coords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#get_timezone_info"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_timezone_info" title="Link to this definition">¶</a></dt>
<dd><p>Get timezone and central meridian information for a location.
Uses the rectangle’s center point to determine the local timezone and
calculates the central meridian based on the UTC offset.</p>
<p>The function provides:
1. Local timezone identifier (e.g., “America/New_York”)
2. UTC offset (e.g., “UTC-04:00”)
3. Central meridian longitude for the timezone</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rectangle_coords</strong> (<em>list</em>) – List of (longitude, latitude) coordinates defining the area</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(timezone string with UTC offset, central meridian longitude string)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">139.65</span><span class="p">,</span> <span class="mf">35.67</span><span class="p">),</span> <span class="p">(</span><span class="mf">139.66</span><span class="p">,</span> <span class="mf">35.67</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="mf">139.66</span><span class="p">,</span> <span class="mf">35.68</span><span class="p">),</span> <span class="p">(</span><span class="mf">139.65</span><span class="p">,</span> <span class="mf">35.68</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tz</span><span class="p">,</span> <span class="n">meridian</span> <span class="o">=</span> <span class="n">get_timezone_info</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Timezone: </span><span class="si">{</span><span class="n">tz</span><span class="si">}</span><span class="s2">, Meridian: </span><span class="si">{</span><span class="n">meridian</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># e.g., &quot;UTC+09:00, 135.00000&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.validate_polygon_coordinates">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">validate_polygon_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#validate_polygon_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.validate_polygon_coordinates" title="Link to this definition">¶</a></dt>
<dd><p>Validate and ensure proper closure of polygon coordinate rings.
Performs validation and correction of GeoJSON polygon geometries according to
the GeoJSON specification requirements.</p>
<p>Validation checks:
1. Geometry type (Polygon or MultiPolygon)
2. Ring closure (first point equals last point)
3. Minimum number of points (4, including closure)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>geometry</strong> (<em>dict</em>) – GeoJSON geometry object with ‘type’ and ‘coordinates’ properties</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if polygon coordinates are valid or were successfully corrected,</dt><dd><p>False if validation failed</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]]</span>  <span class="c1"># Not closed</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">validate_polygon_coordinates</span><span class="p">(</span><span class="n">geom</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Polygon is valid&quot;</span><span class="p">)</span>  <span class="c1"># Will close the ring automatically</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id5">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_building_polygons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filtered_buildings</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#create_building_polygons"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id5" title="Link to this definition">¶</a></dt>
<dd><p>Create building polygons with properties from filtered GeoJSON features.
Processes a list of GeoJSON building features to create Shapely polygons
with associated height and other properties, while also building a spatial index.</p>
<p>Processing steps:
1. Extract and validate coordinates
2. Create Shapely polygons
3. Process building properties (height, levels, etc.)
4. Build spatial index for efficient querying</p>
<p>Height calculation rules:
- Use explicit height if available
- Calculate from levels * floor_height if height not available
- Calculate from floors * floor_height if levels not available
- Use NaN if no height information available</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filtered_buildings</strong> (<em>list</em>) – List of GeoJSON building features with properties</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(</dt><dd><p>list of tuples (polygon, height, min_height, is_inner, feature_id),
rtree spatial index for the polygons</p>
</dd>
</dl>
<p>)</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">buildings</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Feature&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="p">[</span><span class="o">...</span><span class="p">]},</span>
<span class="gp">... </span>        <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;levels&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span>    <span class="c1"># ... more buildings ...</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polygons</span><span class="p">,</span> <span class="n">spatial_idx</span> <span class="o">=</span> <span class="n">create_building_polygons</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_country_name">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_country_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#get_country_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_country_name" title="Link to this definition">¶</a></dt>
<dd><p>Get country name from coordinates using reverse geocoding.
Uses a local database for fast reverse geocoding to country level,
then converts the country code to full name using pycountry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> (<em>float</em>) – Longitude in decimal degrees</p></li>
<li><p><strong>lat</strong> (<em>float</em>) – Latitude in decimal degrees</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Full country name or None if lookup fails</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">country</span> <span class="o">=</span> <span class="n">get_country_name</span><span class="p">(</span><span class="mf">139.6503</span><span class="p">,</span> <span class="mf">35.6762</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Country: </span><span class="si">{</span><span class="n">country</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># &quot;Japan&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id6">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">grid_to_geodataframe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/grid.html#grid_to_geodataframe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id6" title="Link to this definition">¶</a></dt>
<dd><p>Converts a 2D grid to a GeoDataFrame with cell polygons and values.</p>
<p>This function transforms a regular grid into a GeoDataFrame where each cell is
represented as a polygon. The transformation handles coordinate systems properly,
converting between WGS84 (EPSG:4326) and Web Mercator (EPSG:3857) for accurate
distance calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_ori</strong> (<em>numpy.ndarray</em>) – 2D array containing grid values</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of [lon, lat] coordinates defining area corners.
Should be in WGS84 (EPSG:4326) format.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each grid cell in meters</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A GeoDataFrame with columns:</dt><dd><ul class="simple">
<li><p>geometry: Polygon geometry of each grid cell in WGS84 (EPSG:4326)</p></li>
<li><p>value: Value from the original grid</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>GeoDataFrame</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">],</span> <span class="p">[</span><span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">],</span> <span class="p">[</span><span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">],</span> <span class="p">[</span><span class="n">lon4</span><span class="p">,</span> <span class="n">lat4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh_size</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># 100 meters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">grid_to_geodataframe</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">mesh_size</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input grid is flipped vertically before processing to match geographic
orientation (north at top)</p></li>
<li><p>The output GeoDataFrame uses WGS84 (EPSG:4326) coordinate system</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.vectorized_edge_values">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">vectorized_edge_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polygons_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'value'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#vectorized_edge_values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.vectorized_edge_values" title="Link to this definition">¶</a></dt>
<dd><p>Compute average polygon values along each edge in a network graph using vectorized operations.</p>
<p>This function performs efficient computation of average values from polygons that intersect
with network edges. It uses GeoDataFrames for vectorized spatial operations instead of
iterating over individual edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkx.MultiDiGraph</em>) – OSMnx graph with edges containing either geometry attributes or node coordinates.</p></li>
<li><p><strong>polygons_gdf</strong> (<em>geopandas.GeoDataFrame</em>) – GeoDataFrame containing polygons with values to be averaged along edges.</p></li>
<li><p><strong>value_col</strong> (<em>str</em><em>, </em><em>default='value'</em>) – Name of the column in polygons_gdf containing the values to average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dictionary mapping edge tuples (u, v, k) to their computed average values.
Values are length-weighted averages of intersecting polygon values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The process involves:
1. Converting edges to a GeoDataFrame with LineString geometries
2. Projecting geometries to a metric CRS (EPSG:3857) for accurate length calculations
3. Computing intersections between edges and polygons
4. Calculating length-weighted averages of polygon values for each edge</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_network_values">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_network_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'value'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#get_network_values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_network_values" title="Link to this definition">¶</a></dt>
<dd><p>Extract and visualize values from a grid along a street network.</p>
<p>This function downloads a street network from OpenStreetMap for a given area,
computes average grid values along network edges, and optionally visualizes
the results on an interactive map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<em>array-like</em><em> or </em><em>geopandas.GeoDataFrame</em>) – Either a grid array of values or a pre-built GeoDataFrame with polygons and values.</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em><em> of </em><em>tuples</em>) – List of (lon, lat) coordinates defining the bounding rectangle in EPSG:4326.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each grid cell (used only if grid is array-like).</p></li>
<li><p><strong>value_name</strong> (<em>str</em><em>, </em><em>default='value'</em>) – Name to use for the edge attribute storing computed values.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – <p>Additional visualization and processing parameters:
- network_type : str, default=’walk’</p>
<blockquote>
<div><p>Type of street network to download (‘walk’, ‘drive’, etc.)</p>
</div></blockquote>
<ul>
<li><dl class="simple">
<dt>vis_graph<span class="classifier">bool, default=True</span></dt><dd><p>Whether to display the visualization</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>colormap<span class="classifier">str, default=’viridis’</span></dt><dd><p>Matplotlib colormap for edge colors</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>vmin, vmax<span class="classifier">float, optional</span></dt><dd><p>Value range for color mapping</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>edge_width<span class="classifier">float, default=1</span></dt><dd><p>Width of edge lines in visualization</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>fig_size<span class="classifier">tuple, default=(15,15)</span></dt><dd><p>Figure size in inches</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>zoom<span class="classifier">int, default=16</span></dt><dd><p>Zoom level for basemap</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>basemap_style<span class="classifier">ctx.providers, default=CartoDB.Positron</span></dt><dd><p>Contextily basemap provider</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>save_path<span class="classifier">str, optional</span></dt><dd><p>Path to save the edge GeoDataFrame as a GeoPackage</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(networkx.MultiDiGraph, geopandas.GeoDataFrame)
The network graph with computed edge values and edge geometries as a GeoDataFrame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.interpolate_points_along_line">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">interpolate_points_along_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">line</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#interpolate_points_along_line"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.interpolate_points_along_line" title="Link to this definition">¶</a></dt>
<dd><p>Interpolate points along a single LineString at a given interval (in meters).
If the line is shorter than <cite>interval</cite>, only start/end points are returned.</p>
<p>This function handles coordinate system transformations to ensure accurate
distance measurements, working in Web Mercator (EPSG:3857) for distance
calculations while maintaining WGS84 (EPSG:4326) for input/output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<em>shapely.geometry.LineString</em>) – Edge geometry in EPSG:4326 (lon/lat).</p></li>
<li><p><strong>interval</strong> (<em>float</em>) – Distance in meters between interpolated points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Points in EPSG:4326 along the line, spaced approximately <cite>interval</cite> meters apart.
For lines shorter than interval, only start and end points are returned.
For empty lines, an empty list is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of shapely.geometry.Point</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.gather_interpolation_points">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">gather_interpolation_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#gather_interpolation_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.gather_interpolation_points" title="Link to this definition">¶</a></dt>
<dd><p>Gather all interpolation points for each edge in the graph into a single GeoDataFrame.
Supports parallel processing for improved performance on large networks.</p>
<p>This function processes each edge in the graph, either using its geometry attribute
or creating a LineString from node coordinates, then interpolates points along it
at the specified interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<em>networkx.MultiDiGraph</em>) – OSMnx graph with ‘geometry’ attributes or x,y coordinates in the nodes.</p></li>
<li><p><strong>interval</strong> (<em>float</em><em>, </em><em>default=10.0</em>) – Interpolation distance interval in meters.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>default=1</em>) – Number of parallel jobs for processing edges. Set to 1 for sequential processing,
or -1 to use all available CPU cores.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>GeoDataFrame in EPSG:4326 with columns:
- edge_id: Index of the edge in the graph
- index_in_edge: Position of the point along its edge
- geometry: Point geometry</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.fetch_elevations_for_points">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">fetch_elevations_for_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points_gdf_3857</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem_gdf_3857</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elevation_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'value'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#fetch_elevations_for_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.fetch_elevations_for_points" title="Link to this definition">¶</a></dt>
<dd><p>Perform a spatial join to fetch DEM elevations for interpolated points.</p>
<p>Uses nearest neighbor matching in projected coordinates (EPSG:3857) to ensure
accurate distance calculations when finding the closest DEM cell for each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points_gdf_3857</strong> (<em>gpd.GeoDataFrame</em>) – Interpolation points in EPSG:3857 projection.</p></li>
<li><p><strong>dem_gdf_3857</strong> (<em>gpd.GeoDataFrame</em>) – DEM polygons in EPSG:3857 projection, containing elevation values.</p></li>
<li><p><strong>elevation_col</strong> (<em>str</em><em>, </em><em>default='value'</em>) – Name of the column containing elevation values in dem_gdf_3857.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Copy of points_gdf_3857 with additional columns:
- elevation: Elevation value from nearest DEM cell
- dist_to_poly: Distance to nearest DEM cell</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.compute_slope_for_group">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">compute_slope_for_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#compute_slope_for_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.compute_slope_for_group" title="Link to this definition">¶</a></dt>
<dd><p>Compute average slope between consecutive points along a single edge.</p>
<p>Slopes are calculated as absolute percentage grade (rise/run * 100) between
consecutive points, then averaged for the entire edge. Points must be in
EPSG:3857 projection for accurate horizontal distance calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>df</strong> (<em>pd.DataFrame</em>) – DataFrame containing points for a single edge with columns:
- geometry: Point geometries in EPSG:3857
- elevation: Elevation values in meters
- index_in_edge: Position along the edge for sorting</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Average slope as a percentage, or np.nan if no valid slopes can be computed
(e.g., when points are coincident or no elevation change).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.calculate_edge_slopes_from_join">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">calculate_edge_slopes_from_join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">joined_points_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_edges</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#calculate_edge_slopes_from_join"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.calculate_edge_slopes_from_join" title="Link to this definition">¶</a></dt>
<dd><p>Calculate average slopes for all edges in the network from interpolated points.</p>
<p>This function groups points by edge_id and computes the average slope for each edge
using the compute_slope_for_group function. It ensures all edges in the original
graph have a slope value, even if no valid slope could be computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>joined_points_gdf</strong> (<em>gpd.GeoDataFrame</em>) – Points with elevations in EPSG:3857, must have columns:
- edge_id: Index of the edge in the graph
- index_in_edge: Position along the edge
- elevation: Elevation value
- geometry: Point geometry</p></li>
<li><p><strong>n_edges</strong> (<em>int</em>) – Total number of edges in the original graph.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dictionary mapping edge_id to average slope (in %). Edges with no valid
slope calculation are assigned np.nan.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.analyze_network_slopes">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">analyze_network_slopes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dem_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'slope'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/network.html#analyze_network_slopes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.analyze_network_slopes" title="Link to this definition">¶</a></dt>
<dd><p>Analyze and visualize street network slopes using Digital Elevation Model (DEM) data.</p>
<p>This function performs a comprehensive analysis of street network slopes by:
1. Converting DEM data to a GeoDataFrame of elevation polygons
2. Downloading the street network from OpenStreetMap
3. Interpolating points along network edges
4. Matching points to DEM elevations
5. Computing slopes between consecutive points
6. Aggregating slopes per edge
7. Optionally visualizing results on an interactive map</p>
<p>The analysis uses appropriate coordinate transformations between WGS84 (EPSG:4326)
for geographic operations and Web Mercator (EPSG:3857) for distance calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dem_grid</strong> (<em>array-like</em>) – Digital Elevation Model grid data containing elevation values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each DEM grid cell.</p></li>
<li><p><strong>value_name</strong> (<em>str</em><em>, </em><em>default='slope'</em>) – Name to use for the slope attribute in output data.</p></li>
<li><p><strong>interval</strong> (<em>float</em><em>, </em><em>default=10.0</em>) – Distance in meters between interpolated points along edges.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>default=1</em>) – Number of parallel jobs for edge processing.</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – <p>Additional configuration parameters:
- rectangle_vertices : list of (lon, lat), required</p>
<blockquote>
<div><p>Coordinates defining the analysis area in EPSG:4326</p>
</div></blockquote>
<ul>
<li><dl class="simple">
<dt>network_type<span class="classifier">str, default=’walk’</span></dt><dd><p>Type of street network to download</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>vis_graph<span class="classifier">bool, default=True</span></dt><dd><p>Whether to create visualization</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>colormap<span class="classifier">str, default=’viridis’</span></dt><dd><p>Matplotlib colormap for slope visualization</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>vmin, vmax<span class="classifier">float, optional</span></dt><dd><p>Value range for slope coloring</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>edge_width<span class="classifier">float, default=1</span></dt><dd><p>Width of edge lines in plot</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>fig_size<span class="classifier">tuple, default=(15,15)</span></dt><dd><p>Figure size in inches</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>zoom<span class="classifier">int, default=16</span></dt><dd><p>Zoom level for basemap</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>basemap_style<span class="classifier">ctx.providers, default=CartoDB.Positron</span></dt><dd><p>Contextily basemap provider</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output_directory<span class="classifier">str, optional</span></dt><dd><p>Directory to save results</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>output_file_name<span class="classifier">str, default=’network_slopes’</span></dt><dd><p>Base name for output files</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>alpha<span class="classifier">float, default=1.0</span></dt><dd><p>Transparency of edge lines in visualization</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(networkx.MultiDiGraph, geopandas.GeoDataFrame)
- Graph with slope values as edge attributes
- GeoDataFrame of edges with geometries and slope values</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Slopes are calculated as absolute percentage grades (rise/run * 100)</p></li>
<li><p>Edge slopes are length-weighted averages of point-to-point slopes</p></li>
<li><p>The visualization includes a basemap and legend showing slope percentages</p></li>
<li><p>If output_directory is specified, results are saved as a GeoPackage</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id7">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">validate_polygon_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/utils.html#validate_polygon_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id7" title="Link to this definition">¶</a></dt>
<dd><p>Validate and ensure proper closure of polygon coordinate rings.
Performs validation and correction of GeoJSON polygon geometries according to
the GeoJSON specification requirements.</p>
<p>Validation checks:
1. Geometry type (Polygon or MultiPolygon)
2. Ring closure (first point equals last point)
3. Minimum number of points (4, including closure)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>geometry</strong> (<em>dict</em>) – GeoJSON geometry object with ‘type’ and ‘coordinates’ properties</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if polygon coordinates are valid or were successfully corrected,</dt><dd><p>False if validation failed</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]]</span>  <span class="c1"># Not closed</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">validate_polygon_coordinates</span><span class="p">(</span><span class="n">geom</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Polygon is valid&quot;</span><span class="p">)</span>  <span class="c1"># Will close the ring automatically</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.filter_and_convert_gdf_to_geojson">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">filter_and_convert_gdf_to_geojson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#filter_and_convert_gdf_to_geojson"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.filter_and_convert_gdf_to_geojson" title="Link to this definition">¶</a></dt>
<dd><p>Filter a GeoDataFrame by a bounding rectangle and convert to GeoJSON format.</p>
<p>This function performs spatial filtering on a GeoDataFrame using a bounding rectangle,
and converts the filtered data to GeoJSON format. It handles both Polygon and MultiPolygon
geometries, splitting MultiPolygons into separate Polygon features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf</strong> (<em>GeoDataFrame</em>) – Input GeoDataFrame containing building data
Must have ‘geometry’ and ‘height’ columns
Any CRS is accepted, will be converted to WGS84 if needed</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of (lon, lat) tuples defining the bounding rectangle
Must be in WGS84 (EPSG:4326) coordinate system
Must form a valid rectangle (4 vertices, clockwise or counterclockwise)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>List of GeoJSON features within the bounding rectangle</dt><dd><p>Each feature contains:
- geometry: Polygon coordinates in WGS84
- properties: Dictionary with ‘height’, ‘confidence’, and ‘id’
- type: Always “Feature”</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<dl class="simple">
<dt>Memory Optimization:</dt><dd><ul class="simple">
<li><p>Uses spatial indexing for efficient filtering</p></li>
<li><p>Downcasts numeric columns to save memory</p></li>
<li><p>Cleans up intermediate data structures</p></li>
<li><p>Splits MultiPolygons into separate features</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_geojson_from_gpkg">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_geojson_from_gpkg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpkg_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#get_geojson_from_gpkg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_geojson_from_gpkg" title="Link to this definition">¶</a></dt>
<dd><p>Read a GeoPackage file and convert it to GeoJSON format within a bounding rectangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gpkg_path</strong> (<em>str</em>) – Path to the GeoPackage file</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of (lon, lat) tuples defining the bounding rectangle</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of GeoJSON features within the bounding rectangle</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id8">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">extract_building_heights_from_gdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf_0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">geopandas.GeoDataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf_1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">geopandas.GeoDataFrame</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">geopandas.GeoDataFrame</span></span></span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#extract_building_heights_from_gdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id8" title="Link to this definition">¶</a></dt>
<dd><p>Extract building heights from one GeoDataFrame and apply them to another based on spatial overlap.</p>
<p>This function transfers height information from a reference GeoDataFrame to a primary GeoDataFrame
based on the spatial overlap between building footprints. For each building in the primary dataset
that needs height data, it calculates a weighted average height from overlapping buildings in the
reference dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf_0</strong> (<em>gpd.GeoDataFrame</em>) – Primary GeoDataFrame to update with heights
Must have ‘geometry’ column with building footprints
Will be updated with height values where missing or zero</p></li>
<li><p><strong>gdf_1</strong> (<em>gpd.GeoDataFrame</em>) – Reference GeoDataFrame containing height data
Must have ‘geometry’ column with building footprints
Must have ‘height’ column with valid height values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Updated primary GeoDataFrame with extracted heights</dt><dd><p>Buildings with overlapping reference data get weighted average heights
Buildings without overlapping data retain original height or get NaN</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<dl class="simple">
<dt>Statistics Tracked:</dt><dd><ul class="simple">
<li><p>count_0: Number of buildings without height in primary dataset</p></li>
<li><p>count_1: Number of buildings successfully updated with height</p></li>
<li><p>count_2: Number of buildings where no reference height data found</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Uses R-tree spatial indexing for efficient overlap detection</p></li>
<li><p>Handles invalid geometries by attempting to fix them with buffer(0)</p></li>
<li><p>Weighted average is based on the area of overlap between buildings</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.geojson_to_gdf">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">geojson_to_gdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geojson_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'id'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#geojson_to_gdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.geojson_to_gdf" title="Link to this definition">¶</a></dt>
<dd><p>Convert a list of GeoJSON-like dict features into a GeoDataFrame.</p>
<p>This function takes a list of GeoJSON feature dictionaries (Fiona-like format)
and converts them into a GeoDataFrame, handling geometry conversion and property
extraction. It ensures each feature has a unique identifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geojson_data</strong> (<em>List</em><em>[</em><em>Dict</em><em>]</em>) – A list of feature dicts (Fiona-like)
Each dict must have ‘geometry’ and ‘properties’ keys
‘geometry’ must be a valid GeoJSON geometry
‘properties’ can be empty but must be a dict if present</p></li>
<li><p><strong>id_col</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of property to use as an identifier
Default is ‘id’
If not found in properties, a sequential ID will be created
Must be a string that can be used as a column name</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>GeoDataFrame with geometry and property columns</dt><dd><p>Will have ‘geometry’ column with Shapely geometries
Will have columns for all properties found in features
Will have id_col with unique identifiers
Will be set to WGS84 (EPSG:4326) coordinate system</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Handles missing properties gracefully</p></li>
<li><p>Creates sequential IDs if id_col not found</p></li>
<li><p>Converts GeoJSON geometries to Shapely objects</p></li>
<li><p>Sets WGS84 as coordinate system</p></li>
<li><p>Preserves all properties as columns</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id9">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">complement_building_heights_from_gdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">primary_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'id'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'id'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#complement_building_heights_from_gdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id9" title="Link to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Use a vectorized approach with GeoPandas to:</dt><dd><ol class="arabic simple">
<li><p>Find intersections and compute weighted average heights</p></li>
<li><p>Update heights in the primary dataset</p></li>
<li><p>Add non-intersecting buildings from the reference dataset</p></li>
</ol>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf_0</strong> (<em>gpd.GeoDataFrame</em>) – Primary GeoDataFrame</p></li>
<li><p><strong>gdf_1</strong> (<em>gpd.GeoDataFrame</em>) – Reference GeoDataFrame</p></li>
<li><p><strong>primary_id</strong> (<em>str</em>) – Name of the unique identifier in primary dataset’s properties</p></li>
<li><p><strong>ref_id</strong> (<em>str</em>) – Name of the unique identifier in reference dataset’s properties</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Updated GeoDataFrame (including new buildings).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.gdf_to_geojson_dicts">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">gdf_to_geojson_dicts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'id'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#gdf_to_geojson_dicts"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.gdf_to_geojson_dicts" title="Link to this definition">¶</a></dt>
<dd><p>Convert a GeoDataFrame to a list of dicts similar to GeoJSON features.</p>
<p>This function converts a GeoDataFrame into a list of dictionary objects that
follow the GeoJSON Feature format. Each feature will have geometry and properties,
with an optional ID field handled separately from other properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gdf</strong> (<em>gpd.GeoDataFrame</em>) – GeoDataFrame to convert
Must have ‘geometry’ column with Shapely geometries
All non-geometry columns will become properties
Can optionally have id_col for unique identifiers</p></li>
<li><p><strong>id_col</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of column to use as feature ID
Default is ‘id’
If present, will be excluded from properties
If not present, features will not have explicit IDs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>List of GeoJSON-like feature dictionaries</dt><dd><p>Each dict will have:
- type: Always “Feature”
- geometry: GeoJSON geometry from Shapely object
- properties: All columns except geometry and ID</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Converts Shapely geometries to GeoJSON format</p></li>
<li><p>Preserves all non-geometry columns as properties</p></li>
<li><p>Handles missing ID column gracefully</p></li>
<li><p>Maintains original property types</p></li>
<li><p>Excludes ID from properties if specified</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.load_gdf_from_multiple_gz">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">load_gdf_from_multiple_gz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_paths</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#load_gdf_from_multiple_gz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.load_gdf_from_multiple_gz" title="Link to this definition">¶</a></dt>
<dd><p>Load GeoJSON features from multiple gzipped files into a single GeoDataFrame.</p>
<p>This function reads multiple gzipped GeoJSON files, where each line in each file
represents a single GeoJSON feature. It combines all features into a single
GeoDataFrame, ensuring height properties are properly handled and coordinates
are in WGS84.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_paths</strong> (<em>list</em>) – List of paths to gzipped GeoJSON files
Each file should contain one GeoJSON feature per line
Files should be readable as UTF-8 text
Features should be in WGS84 coordinate system</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Combined GeoDataFrame containing all features</dt><dd><p>Will have ‘geometry’ column with building footprints
Will have ‘height’ column (0 for missing values)
Will be set to WGS84 (EPSG:4326) coordinate system</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Skips lines that cannot be parsed as valid JSON</p></li>
<li><p>Sets missing height values to 0</p></li>
<li><p>Assumes input coordinates are in WGS84</p></li>
<li><p>Memory usage scales with total number of features</p></li>
<li><p>Reports JSON parsing errors but continues processing</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id10">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">filter_buildings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geojson_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plotting_box</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#filter_buildings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id10" title="Link to this definition">¶</a></dt>
<dd><p>Filter building features that intersect with a given bounding box.</p>
<p>This function filters a list of GeoJSON building features to keep only those
that intersect with a specified bounding box. It performs geometry validation
and handles invalid geometries gracefully.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geojson_data</strong> (<em>list</em>) – List of GeoJSON features representing buildings
Each feature must have valid ‘geometry’ property
Coordinates must be in same CRS as plotting_box
Invalid geometries will be skipped with warning</p></li>
<li><p><strong>plotting_box</strong> (<em>Polygon</em>) – Shapely polygon defining the bounding box
Must be a valid Shapely Polygon object
Must be in same coordinate system as geojson_data
Used for spatial intersection testing</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Filtered list of GeoJSON features that intersect with the bounding box</dt><dd><p>Features maintain their original structure
Invalid features are excluded
Order of features is preserved</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Validates polygon coordinates before processing</p></li>
<li><p>Skips features with invalid geometries</p></li>
<li><p>Reports validation and geometry errors</p></li>
<li><p>No coordinate system transformation is performed</p></li>
<li><p>Memory efficient as it creates new list only for valid features</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id11">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">extract_building_heights_from_geotiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geotiff_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gdf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#extract_building_heights_from_geotiff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id11" title="Link to this definition">¶</a></dt>
<dd><p>Extract building heights from a GeoTIFF raster for building footprints in a GeoDataFrame.</p>
<p>This function processes building footprints to extract height information from a GeoTIFF
raster file. It handles coordinate transformation between WGS84 (EPSG:4326) and the raster’s
CRS, and calculates average heights for each building footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geotiff_path</strong> (<em>str</em>) – Path to the GeoTIFF height raster file containing elevation data</p></li>
<li><p><strong>gdf</strong> (<em>gpd.GeoDataFrame</em>) – GeoDataFrame containing building footprints with geometry column
The GeoDataFrame should be in WGS84 (EPSG:4326) coordinate system</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Updated GeoDataFrame with extracted heights in the ‘height’ column</dt><dd><ul class="simple">
<li><p>Buildings with valid height data will have their height values updated</p></li>
<li><p>Buildings with no valid height data will have NaN values</p></li>
<li><p>Original buildings with existing valid heights are preserved</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<dl class="simple">
<dt>Statistics Reported:</dt><dd><ul class="simple">
<li><p>Total number of buildings without height data</p></li>
<li><p>Number of buildings successfully updated with height data</p></li>
<li><p>Number of buildings where no height data could be found</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The function only processes Polygon geometries (not MultiPolygons or other types)</p></li>
<li><p>Buildings are considered to need height processing if they have no height or height &lt;= 0</p></li>
<li><p>Heights are calculated as the mean of all valid raster values within the building footprint</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_gdf_from_gpkg">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_gdf_from_gpkg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpkg_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rectangle_vertices</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#get_gdf_from_gpkg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_gdf_from_gpkg" title="Link to this definition">¶</a></dt>
<dd><p>Read a GeoPackage file and convert it to a GeoDataFrame with consistent CRS.</p>
<p>This function reads a GeoPackage file containing building footprints and ensures
the data is properly formatted with WGS84 coordinate system and unique identifiers.
It handles CRS conversion if needed and adds sequential IDs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gpkg_path</strong> (<em>str</em>) – Path to the GeoPackage file
File must exist and be readable
Must contain valid building footprint geometries
Any coordinate system is accepted</p></li>
<li><p><strong>rectangle_vertices</strong> (<em>list</em>) – List of (lon, lat) tuples defining the bounding rectangle
Must be in WGS84 (EPSG:4326) coordinate system
Used for spatial filtering (not implemented in this function)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>GeoDataFrame containing building footprints</dt><dd><p>Will have ‘geometry’ column with building geometries
Will have ‘id’ column with sequential integers
Will be in WGS84 (EPSG:4326) coordinate system</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>gpd.GeoDataFrame</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Prints informative message when opening file</p></li>
<li><p>Sets CRS to WGS84 if not specified</p></li>
<li><p>Transforms to WGS84 if different CRS</p></li>
<li><p>Adds sequential IDs starting from 0</p></li>
<li><p>rectangle_vertices parameter is currently unused</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.swap_coordinates">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">swap_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">features</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#swap_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.swap_coordinates" title="Link to this definition">¶</a></dt>
<dd><p>Swap coordinate ordering in GeoJSON features from (lat, lon) to (lon, lat).</p>
<p>This function modifies GeoJSON features in-place to swap the order of coordinates
from (latitude, longitude) to (longitude, latitude). It handles both Polygon and
MultiPolygon geometries, maintaining their structure while swapping coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>features</strong> (<em>list</em>) – List of GeoJSON features to process
Features must have ‘geometry’ property
Supported geometry types: ‘Polygon’, ‘MultiPolygon’
Coordinates must be in (lat, lon) order initially</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Features are modified in-place</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Modifies features directly (no copy created)</p></li>
<li><p>Handles both Polygon and MultiPolygon geometries</p></li>
<li><p>For Polygons: processes single coordinate ring</p></li>
<li><p>For MultiPolygons: processes multiple coordinate rings</p></li>
<li><p>Assumes input coordinates are in (lat, lon) order</p></li>
<li><p>Resulting coordinates will be in (lon, lat) order</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.save_geojson">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">save_geojson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#save_geojson"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.save_geojson" title="Link to this definition">¶</a></dt>
<dd><p>Save GeoJSON features to a file with coordinate swapping and pretty printing.</p>
<p>This function takes a list of GeoJSON features, swaps their coordinate ordering
if needed, wraps them in a FeatureCollection, and saves to a file with proper
JSON formatting. It creates a deep copy to avoid modifying the original data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>features</strong> (<em>list</em>) – List of GeoJSON features to save
Each feature should have valid GeoJSON structure
Features can be Polygon or MultiPolygon type
Coordinates will be swapped if in (lat, lon) order</p></li>
<li><p><strong>save_path</strong> (<em>str</em>) – Path where the GeoJSON file should be saved
Will overwrite existing file if present
Directory must exist and be writable
File will be created with UTF-8 encoding</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Creates deep copy to preserve original feature data</p></li>
<li><p>Swaps coordinates from (lat, lon) to (lon, lat) order</p></li>
<li><p>Wraps features in a FeatureCollection object</p></li>
<li><p>Uses pretty printing with 2-space indentation</p></li>
<li><p>Handles both Polygon and MultiPolygon geometries</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.find_building_containing_point">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">find_building_containing_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">building_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#find_building_containing_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.find_building_containing_point" title="Link to this definition">¶</a></dt>
<dd><p>Find building IDs that contain a given point in their footprint.</p>
<p>This function identifies all buildings in a GeoDataFrame whose footprint contains
a specified geographic point. Only Polygon geometries are considered, and the point
must be fully contained within the building footprint (not just touching).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>building_gdf</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing building geometries and IDs
Must have ‘geometry’ column with Polygon geometries
Must have ‘id’ column or index will be used as fallback
Geometries must be in same CRS as target_point coordinates</p></li>
<li><p><strong>target_point</strong> (<em>tuple</em>) – Tuple of (lon, lat) coordinates to check
Must be in same coordinate system as building_gdf geometries
Order must be (longitude, latitude) if using WGS84</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>List of building IDs containing the target point</dt><dd><p>Empty list if no buildings contain the point
Multiple IDs possible if buildings overlap
IDs are in arbitrary order</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Only processes Polygon geometries (skips MultiPolygons and others)</p></li>
<li><p>Uses Shapely’s contains() method which requires point to be fully inside polygon</p></li>
<li><p>No spatial indexing is used, performs linear search through all buildings</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.get_buildings_in_drawn_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">get_buildings_in_drawn_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">building_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drawn_polygon_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'within'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#get_buildings_in_drawn_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.get_buildings_in_drawn_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Find buildings that intersect with or are contained within a user-drawn polygon.</p>
<p>This function identifies buildings from a GeoDataFrame that have a specified spatial
relationship with a polygon defined by user-drawn vertices. The relationship can be
either intersection (building overlaps polygon) or containment (building fully within
polygon).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>building_gdf</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing building footprints
Must have ‘geometry’ column with Polygon geometries
Must have ‘id’ column or index will be used as fallback
Geometries must be in same CRS as drawn_polygon_vertices</p></li>
<li><p><strong>drawn_polygon_vertices</strong> (<em>list</em>) – List of (lon, lat) tuples defining polygon vertices
Must be in same coordinate system as building_gdf geometries
Must form a valid polygon (3+ vertices, first != last)
Order must be (longitude, latitude) if using WGS84</p></li>
<li><p><strong>operation</strong> (<em>str</em><em>, </em><em>optional</em>) – Type of spatial relationship to check
‘within’: buildings must be fully contained in drawn polygon (default)
‘intersect’: buildings must overlap with drawn polygon</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>List of building IDs that satisfy the spatial relationship</dt><dd><p>Empty list if no buildings meet the criteria
IDs are returned in order of processing
May contain None values if buildings lack IDs</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Only processes Polygon geometries (skips MultiPolygons and others)</p></li>
<li><p>No spatial indexing is used, performs linear search through all buildings</p></li>
<li><p>Invalid operation parameter will raise ValueError</p></li>
<li><p>Does not validate polygon closure (first vertex = last vertex)</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id12">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">process_building_footprints_by_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filtered_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#process_building_footprints_by_overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id12" title="Link to this definition">¶</a></dt>
<dd><p>Process building footprints to merge overlapping buildings based on area overlap ratio.</p>
<p>This function identifies and merges building footprints that significantly overlap with each other.
Buildings are processed in order of decreasing area, and smaller buildings that overlap significantly
with larger ones are assigned the ID of the larger building, effectively merging them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filtered_gdf</strong> (<em>geopandas.GeoDataFrame</em>) – GeoDataFrame containing building footprints
Must have ‘geometry’ column with building polygons
If CRS is set, areas will be calculated in Web Mercator projection</p></li>
<li><p><strong>overlap_threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – Threshold for overlap ratio (0.0-1.0) to merge buildings
Default is 0.5 (50% overlap)
Higher values require more overlap for merging
Lower values will result in more aggressive merging</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Processed GeoDataFrame with updated IDs</dt><dd><p>Overlapping buildings will share the same ID
Original geometries are preserved, only IDs are updated
All other columns remain unchanged</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>geopandas.GeoDataFrame</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Uses R-tree spatial indexing for efficient overlap detection</p></li>
<li><p>Projects to Web Mercator (EPSG:3857) for accurate area calculation if CRS is set</p></li>
<li><p>Handles invalid geometries by attempting to fix them with buffer(0)</p></li>
<li><p>Processes buildings in order of decreasing area (largest first)</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_voxel_mesh">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_voxel_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">building_id_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/mesh.html#create_voxel_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_voxel_mesh" title="Link to this definition">¶</a></dt>
<dd><p>Create a 3D mesh from voxels preserving sharp edges, scaled by meshsize.</p>
<p>This function converts a 3D voxel array into a triangulated mesh, where each voxel
face is converted into two triangles. The function preserves sharp edges between
different classes and handles special cases for buildings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_array</strong> (<em>np.ndarray</em><em> (</em><em>3D</em><em>)</em>) – The voxel array of shape (X, Y, Z) where each cell contains a class ID.
- 0: typically represents void/air
- -2: typically represents trees
- -3: typically represents buildings
Other values can represent different classes as defined by the application.</p></li>
<li><p><strong>class_id</strong> (<em>int</em>) – The ID of the class to extract. Only voxels with this ID will be included
in the output mesh.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em><em>, </em><em>default=1.0</em>) – The real-world size of each voxel in meters, applied uniformly to x, y, and z
dimensions. Used to scale the output mesh to real-world coordinates.</p></li>
<li><p><strong>building_id_grid</strong> (<em>np.ndarray</em><em> (</em><em>2D</em><em>)</em><em>, </em><em>optional</em>) – 2D grid of building IDs with shape (X, Y). Only used when class_id=-3 (buildings).
Each cell contains a unique identifier for the building at that location.
This allows tracking which faces belong to which building.</p></li>
<li><p><strong>mesh_type</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Type of mesh to create, controlling which faces are included:
- None (default): create faces at boundaries between different classes
- ‘building_solar’: only create faces at boundaries between buildings (-3)</p>
<blockquote>
<div><p>and either void (0) or trees (-2). Useful for solar analysis
where only exposed surfaces matter.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>mesh</strong> – The resulting triangulated mesh for the given class_id. Returns None if no
voxels of the specified class are found.</p>
<p>The mesh includes:
- vertices: 3D coordinates of each vertex
- faces: triangles defined by vertex indices
- face_normals: normal vectors for each face
- metadata: If class_id=-3, includes ‘building_id’ mapping faces to buildings</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh or None</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage for a simple voxel array:
&gt;&gt;&gt; voxels = np.zeros((10, 10, 10))
&gt;&gt;&gt; voxels[4:7, 4:7, 0:5] = 1  # Create a simple column
&gt;&gt;&gt; mesh = create_voxel_mesh(voxels, class_id=1, meshsize=0.5)</p>
<p>Creating a building mesh with IDs:
&gt;&gt;&gt; building_ids = np.zeros((10, 10))
&gt;&gt;&gt; building_ids[4:7, 4:7] = 1  # Mark building #1
&gt;&gt;&gt; mesh = create_voxel_mesh(voxels, class_id=-3,
…                         building_id_grid=building_ids,
…                         meshsize=1.0)</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function creates faces only at boundaries between different classes or at
the edges of the voxel array.</p></li>
<li><p>Each face is split into two triangles for compatibility with graphics engines.</p></li>
<li><p>Face normals are computed to ensure correct lighting and rendering.</p></li>
<li><p>For buildings (class_id=-3), building IDs are tracked to maintain building identity.</p></li>
<li><p>The mesh preserves sharp edges, which is important for architectural visualization.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_sim_surface_mesh">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_sim_surface_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/mesh.html#create_sim_surface_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_sim_surface_mesh" title="Link to this definition">¶</a></dt>
<dd><p>Create a colored planar surface mesh from simulation data, positioned above a DEM.</p>
<p>This function generates a 3D visualization mesh for 2D simulation results (like
Green View Index, solar radiation, etc.). The mesh is positioned above the Digital
Elevation Model (DEM) by a specified offset, and colored according to the simulation
values using a matplotlib colormap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sim_grid</strong> (<em>2D np.ndarray</em>) – 2D array of simulation values (e.g., Green View Index, solar radiation).
NaN values in this grid will be skipped in the output mesh.
The grid should be oriented with north at the top.</p></li>
<li><p><strong>dem_grid</strong> (<em>2D np.ndarray</em>) – 2D array of ground elevations in meters. Must have the same shape as sim_grid.
Used to position the visualization mesh at the correct height above terrain.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em><em>, </em><em>default=1.0</em>) – Size of each cell in meters. Applied uniformly to x and y dimensions.
Determines the resolution of the output mesh.</p></li>
<li><p><strong>z_offset</strong> (<em>float</em><em>, </em><em>default=1.5</em>) – Additional height offset in meters added to dem_grid elevations.
Used to position the visualization above ground level for better visibility.</p></li>
<li><p><strong>cmap_name</strong> (<em>str</em><em>, </em><em>default='viridis'</em>) – Matplotlib colormap name used for coloring the mesh based on sim_grid values.
Common options:
- ‘viridis’: Default, perceptually uniform, colorblind-friendly
- ‘RdYlBu’: Red-Yellow-Blue, good for diverging data
- ‘jet’: Rainbow colormap (not recommended for scientific visualization)</p></li>
<li><p><strong>vmin</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum value for color mapping. If None, uses min of sim_grid (excluding NaN).
Used to control the range of the colormap.</p></li>
<li><p><strong>vmax</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum value for color mapping. If None, uses max of sim_grid (excluding NaN).
Used to control the range of the colormap.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>mesh</strong> – A single mesh containing one colored square face (two triangles) per non-NaN cell.
Returns None if there are no valid (non-NaN) cells in sim_grid.</p>
<p>The mesh includes:
- vertices: 3D coordinates of each vertex
- faces: triangles defined by vertex indices
- face_colors: RGBA colors for each face based on sim_grid values
- visual: trimesh.visual.ColorVisuals object storing the face colors</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh or None</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage with Green View Index data:
&gt;&gt;&gt; gvi = np.array([[0.5, 0.6], [0.4, 0.8]])  # GVI values
&gt;&gt;&gt; dem = np.array([[10.0, 10.2], [9.8, 10.1]])  # Ground heights
&gt;&gt;&gt; mesh = create_sim_surface_mesh(gvi, dem, meshsize=1.0, z_offset=1.5)</p>
<p>Custom color range and colormap:
&gt;&gt;&gt; mesh = create_sim_surface_mesh(gvi, dem,
…                               cmap_name=’RdYlBu’,
…                               vmin=0.0, vmax=1.0)</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function automatically creates a matplotlib colorbar figure for visualization</p></li>
<li><p>Both input grids are flipped vertically to match the voxel_array orientation</p></li>
<li><p>Each grid cell is converted to two triangles for compatibility with 3D engines</p></li>
<li><p>The mesh is positioned at dem_grid + z_offset to float above the terrain</p></li>
<li><p>Face colors are interpolated from the colormap based on sim_grid values</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.create_city_meshes">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">create_city_meshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vox_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/mesh.html#create_city_meshes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.create_city_meshes" title="Link to this definition">¶</a></dt>
<dd><p>Create a collection of colored 3D meshes representing different city elements.</p>
<p>This function processes a voxelized city model and creates separate meshes for
different urban elements (buildings, trees, etc.), each with its own color.
The function preserves sharp edges and applies appropriate colors based on the
provided color dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_array</strong> (<em>np.ndarray</em><em> (</em><em>3D</em><em>)</em>) – 3D array representing the voxelized city model. Each voxel contains a class ID
that maps to an urban element type:
- 0: Void/air (automatically skipped)
- -2: Trees
- -3: Buildings
Other values can represent different urban elements as defined in vox_dict.</p></li>
<li><p><strong>vox_dict</strong> (<em>dict</em>) – Dictionary mapping class IDs to RGB colors. Each entry should be:
{class_id: [R, G, B]} where R, G, B are 0-255 integer values.
Example: {-3: [200, 200, 200], -2: [0, 255, 0]} for grey buildings and
green trees. The key 0 (air) is automatically excluded.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em><em>, </em><em>default=1.0</em>) – Size of each voxel in meters, applied uniformly to x, y, and z dimensions.
Used to scale the output meshes to real-world coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>meshes</strong> – Dictionary mapping class IDs to their corresponding trimesh.Trimesh objects.
Each mesh includes:
- vertices: 3D coordinates scaled by meshsize
- faces: triangulated faces preserving sharp edges
- face_colors: RGBA colors from vox_dict
- visual: trimesh.visual.ColorVisuals object storing the face colors</p>
<p>Classes with no voxels are automatically excluded from the output.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage with buildings and trees:
&gt;&gt;&gt; voxels = np.zeros((10, 10, 10))
&gt;&gt;&gt; voxels[4:7, 4:7, 0:5] = -3  # Add a building
&gt;&gt;&gt; voxels[2:4, 2:4, 0:3] = -2  # Add some trees
&gt;&gt;&gt; colors = {
…     -3: [200, 200, 200],  # Grey buildings
…     -2: [0, 255, 0]       # Green trees
… }
&gt;&gt;&gt; meshes = create_city_meshes(voxels, colors, meshsize=1.0)</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function automatically skips class_id=0 (typically air/void)</p></li>
<li><p>Each urban element type gets its own separate mesh for efficient rendering</p></li>
<li><p>Colors are converted from RGB [0-255] to RGBA [0-1] format</p></li>
<li><p>Sharp edges are preserved to maintain architectural features</p></li>
<li><p>Empty classes (no voxels) are automatically excluded from the output</p></li>
<li><p>Errors during mesh creation for a class are caught and reported</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.export_meshes">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">export_meshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_directory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/mesh.html#export_meshes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.export_meshes" title="Link to this definition">¶</a></dt>
<dd><p>Export a collection of meshes to both OBJ (with MTL) and STL formats.</p>
<p>This function exports meshes in two ways:
1. A single combined OBJ file with materials (and associated MTL file)
2. Separate STL files for each mesh, named with their class IDs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>meshes</strong> (<em>dict</em>) – Dictionary mapping class IDs to trimesh.Trimesh objects.
Each mesh should have:
- vertices: 3D coordinates
- faces: triangulated faces
- face_colors: RGBA colors (if using materials)</p></li>
<li><p><strong>output_directory</strong> (<em>str</em>) – Directory path where the output files will be saved.
Will be created if it doesn’t exist.</p></li>
<li><p><strong>base_filename</strong> (<em>str</em>) – Base name for the output files (without extension).
Will be used to create:
- {base_filename}.obj : Combined mesh with materials
- {base_filename}.mtl : Material definitions for OBJ
- {base_filename}_{class_id}.stl : Individual STL files</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Files are written directly to the specified output directory.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">meshes</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="n">building_mesh</span><span class="p">,</span>  <span class="c1"># Building mesh with grey color</span>
<span class="gp">... </span>    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="n">tree_mesh</span>      <span class="c1"># Tree mesh with green color</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">export_meshes</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span> <span class="s1">&#39;output/models&#39;</span><span class="p">,</span> <span class="s1">&#39;city_model&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will create:
- output/models/city_model.obj
- output/models/city_model.mtl
- output/models/<a href="#id13"><span class="problematic" id="id14">city_model_</span></a>-3.stl
- output/models/<a href="#id15"><span class="problematic" id="id16">city_model_</span></a>-2.stl</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>OBJ/MTL format preserves colors and materials but is more complex</p></li>
<li><p>STL format is simpler but doesn’t support colors</p></li>
<li><p>STL files are exported separately for each class for easier processing</p></li>
<li><p>The OBJ file combines all meshes while preserving their materials</p></li>
<li><p>File extensions are automatically added to the base filename</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.split_vertices_manual">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">split_vertices_manual</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/mesh.html#split_vertices_manual"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.split_vertices_manual" title="Link to this definition">¶</a></dt>
<dd><p>Split a mesh into independent faces by duplicating shared vertices.</p>
<p>This function imitates trimesh’s split_vertices() functionality but ensures
complete face independence by giving each face its own copy of vertices.
This is particularly useful for rendering applications where smooth shading
between faces is undesirable, such as architectural visualization in Rhino.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mesh</strong> (<em>trimesh.Trimesh</em>) – Input mesh to split. Should have:
- vertices: array of vertex coordinates
- faces: array of vertex indices forming triangles
- visual: Optional ColorVisuals object with face colors</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>out_mesh</strong> – New mesh where each face is completely independent, with:
- Duplicated vertices for each face
- No vertex sharing between faces
- Preserved face colors if present in input
- Each face as a separate component</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage:
&gt;&gt;&gt; vertices = np.array([[0,0,0], [1,0,0], [1,1,0], [0,1,0]])
&gt;&gt;&gt; faces = np.array([[0,1,2], [0,2,3]])  # Two triangles sharing vertices
&gt;&gt;&gt; mesh = trimesh.Trimesh(vertices=vertices, faces=faces)
&gt;&gt;&gt; split_mesh = split_vertices_manual(mesh)
&gt;&gt;&gt; print(f”Original vertices: {len(mesh.vertices)}”)  # 4 vertices
&gt;&gt;&gt; print(f”Split vertices: {len(split_mesh.vertices)}”)  # 6 vertices</p>
<p>With face colors:
&gt;&gt;&gt; colors = np.array([[255,0,0,255], [0,255,0,255]])  # Red and green faces
&gt;&gt;&gt; mesh.visual = trimesh.visual.ColorVisuals(mesh, face_colors=colors)
&gt;&gt;&gt; split_mesh = split_vertices_manual(mesh)  # Colors are preserved</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Each output face has exactly 3 unique vertices</p></li>
<li><p>Face colors are preserved in the output mesh</p></li>
<li><dl class="simple">
<dt>Useful for:</dt><dd><ul>
<li><p>Preventing smooth shading artifacts</p></li>
<li><p>Ensuring face color independence</p></li>
<li><p>Preparing meshes for CAD software</p></li>
<li><p>Creating sharp edges in architectural models</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Memory usage increases as vertices are duplicated</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.geoprocessor.save_obj_from_colored_mesh">
<span class="sig-prename descclassname"><span class="pre">voxcity.geoprocessor.</span></span><span class="sig-name descname"><span class="pre">save_obj_from_colored_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_filename</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/mesh.html#save_obj_from_colored_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.geoprocessor.save_obj_from_colored_mesh" title="Link to this definition">¶</a></dt>
<dd><p>Save a collection of colored meshes as OBJ and MTL files with material support.</p>
<p>This function exports colored meshes to the Wavefront OBJ format with an
accompanying MTL file for material definitions. It handles the conversion of
face colors to materials and ensures proper material assignment in the OBJ file.
The function is particularly useful for preserving color information in
architectural and urban visualization models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>meshes</strong> (<em>dict</em>) – Dictionary mapping class IDs to trimesh.Trimesh objects.
Each mesh should have:
- vertices: array of 3D coordinates
- faces: array of vertex indices forming triangles
- visual.face_colors: RGBA colors for each face</p></li>
<li><p><strong>output_path</strong> (<em>str</em>) – Directory path where to save the files.
Will be created if it doesn’t exist.
Should be writable by the current user.</p></li>
<li><p><strong>base_filename</strong> (<em>str</em>) – Base name for the output files (without extension).
Will be used to create:
- {base_filename}.obj : The main geometry file
- {base_filename}.mtl : The material definitions file</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(obj_path, mtl_path) : Paths to the saved OBJ and MTL files.
Both paths are absolute or relative depending on the input output_path.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage with multiple colored meshes:
&gt;&gt;&gt; building_mesh = trimesh.Trimesh(
…     vertices=[[0,0,0], [1,0,0], [1,1,0]],
…     faces=[[0,1,2]],
…     face_colors=[[200,200,200,255]]  # Grey color
… )
&gt;&gt;&gt; tree_mesh = trimesh.Trimesh(
…     vertices=[[2,0,0], [3,0,0], [2.5,1,0]],
…     faces=[[0,1,2]],
…     face_colors=[[0,255,0,255]]  # Green color
… )
&gt;&gt;&gt; meshes = {-3: building_mesh, -2: tree_mesh}
&gt;&gt;&gt; obj_path, mtl_path = save_obj_from_colored_mesh(
…     meshes, ‘output/models’, ‘city’
… )</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Creates unique materials for each distinct face color</p></li>
<li><p>Material names are auto-generated as ‘material_0’, ‘material_1’, etc.</p></li>
<li><p>Handles both RGB and RGBA colors (alpha channel supported)</p></li>
<li><p>Colors are normalized from [0-255] to [0-1] range for MTL format</p></li>
<li><p>Vertices are written in OBJ’s 1-based indexing format</p></li>
<li><p>Faces are grouped by material for efficient rendering</p></li>
<li><p>The MTL file is automatically referenced in the OBJ file</p></li>
</ul>
<section id="file-format-details">
<h3>File Format Details<a class="headerlink" href="#file-format-details" title="Link to this heading">¶</a></h3>
<p>OBJ file structure:
- mtllib reference to MTL file
- All vertex coordinates (v)
- Face definitions (f) grouped by material (usemtl)</p>
<p>MTL file structure:
- newmtl: Material name
- Kd: Diffuse color (RGB)
- d: Alpha/transparency</p>
</section>
</dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="draw/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">voxcity.geoprocessor.draw</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../generator/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">voxcity.generator</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Kunihiko Fujiwara
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">voxcity.geoprocessor</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#attributes">Attributes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#package-contents">Package Contents</a><ul>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_coordinates_from_cityname"><code class="docutils literal notranslate"><span class="pre">get_coordinates_from_cityname()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.rotate_rectangle"><code class="docutils literal notranslate"><span class="pre">rotate_rectangle()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.draw_rectangle_map"><code class="docutils literal notranslate"><span class="pre">draw_rectangle_map()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.draw_rectangle_map_cityname"><code class="docutils literal notranslate"><span class="pre">draw_rectangle_map_cityname()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.center_location_map_cityname"><code class="docutils literal notranslate"><span class="pre">center_location_map_cityname()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.display_buildings_and_draw_polygon"><code class="docutils literal notranslate"><span class="pre">display_buildings_and_draw_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.initialize_geod"><code class="docutils literal notranslate"><span class="pre">initialize_geod()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.calculate_distance"><code class="docutils literal notranslate"><span class="pre">calculate_distance()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.normalize_to_one_meter"><code class="docutils literal notranslate"><span class="pre">normalize_to_one_meter()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_building_polygons"><code class="docutils literal notranslate"><span class="pre">create_building_polygons()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.convert_format_lat_lon"><code class="docutils literal notranslate"><span class="pre">convert_format_lat_lon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.filter_buildings"><code class="docutils literal notranslate"><span class="pre">filter_buildings()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.extract_building_heights_from_geotiff"><code class="docutils literal notranslate"><span class="pre">extract_building_heights_from_geotiff()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.extract_building_heights_from_gdf"><code class="docutils literal notranslate"><span class="pre">extract_building_heights_from_gdf()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.complement_building_heights_from_gdf"><code class="docutils literal notranslate"><span class="pre">complement_building_heights_from_gdf()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.process_building_footprints_by_overlap"><code class="docutils literal notranslate"><span class="pre">process_building_footprints_by_overlap()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_class_priority"><code class="docutils literal notranslate"><span class="pre">get_class_priority()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_land_cover_polygons"><code class="docutils literal notranslate"><span class="pre">create_land_cover_polygons()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_dominant_class"><code class="docutils literal notranslate"><span class="pre">get_dominant_class()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_roi"><code class="docutils literal notranslate"><span class="pre">get_roi()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.save_geotiff_open_buildings_temporal"><code class="docutils literal notranslate"><span class="pre">save_geotiff_open_buildings_temporal()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.apply_operation"><code class="docutils literal notranslate"><span class="pre">apply_operation()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.translate_array"><code class="docutils literal notranslate"><span class="pre">translate_array()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.group_and_label_cells"><code class="docutils literal notranslate"><span class="pre">group_and_label_cells()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.process_grid"><code class="docutils literal notranslate"><span class="pre">process_grid()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.calculate_grid_size"><code class="docutils literal notranslate"><span class="pre">calculate_grid_size()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_coordinate_mesh"><code class="docutils literal notranslate"><span class="pre">create_coordinate_mesh()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_cell_polygon"><code class="docutils literal notranslate"><span class="pre">create_cell_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.tree_height_grid_from_land_cover"><code class="docutils literal notranslate"><span class="pre">tree_height_grid_from_land_cover()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_land_cover_grid_from_geotiff_polygon"><code class="docutils literal notranslate"><span class="pre">create_land_cover_grid_from_geotiff_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_land_cover_grid_from_gdf_polygon"><code class="docutils literal notranslate"><span class="pre">create_land_cover_grid_from_gdf_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_height_grid_from_geotiff_polygon"><code class="docutils literal notranslate"><span class="pre">create_height_grid_from_geotiff_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_building_height_grid_from_gdf_polygon"><code class="docutils literal notranslate"><span class="pre">create_building_height_grid_from_gdf_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_building_height_grid_from_open_building_temporal_polygon"><code class="docutils literal notranslate"><span class="pre">create_building_height_grid_from_open_building_temporal_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_dem_grid_from_geotiff_polygon"><code class="docutils literal notranslate"><span class="pre">create_dem_grid_from_geotiff_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.grid_to_geodataframe"><code class="docutils literal notranslate"><span class="pre">grid_to_geodataframe()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.grid_to_point_geodataframe"><code class="docutils literal notranslate"><span class="pre">grid_to_point_geodataframe()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_vegetation_height_grid_from_gdf_polygon"><code class="docutils literal notranslate"><span class="pre">create_vegetation_height_grid_from_gdf_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_dem_grid_from_gdf_polygon"><code class="docutils literal notranslate"><span class="pre">create_dem_grid_from_gdf_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.floor_height"><code class="docutils literal notranslate"><span class="pre">floor_height</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.tile_from_lat_lon"><code class="docutils literal notranslate"><span class="pre">tile_from_lat_lon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.quadkey_to_tile"><code class="docutils literal notranslate"><span class="pre">quadkey_to_tile()</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">initialize_geod()</span></code></a></li>
<li><a class="reference internal" href="#id1"><code class="docutils literal notranslate"><span class="pre">calculate_distance()</span></code></a></li>
<li><a class="reference internal" href="#id2"><code class="docutils literal notranslate"><span class="pre">normalize_to_one_meter()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.setup_transformer"><code class="docutils literal notranslate"><span class="pre">setup_transformer()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.transform_coords"><code class="docutils literal notranslate"><span class="pre">transform_coords()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_polygon"><code class="docutils literal notranslate"><span class="pre">create_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_geodataframe"><code class="docutils literal notranslate"><span class="pre">create_geodataframe()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.haversine_distance"><code class="docutils literal notranslate"><span class="pre">haversine_distance()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_raster_bbox"><code class="docutils literal notranslate"><span class="pre">get_raster_bbox()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.raster_intersects_polygon"><code class="docutils literal notranslate"><span class="pre">raster_intersects_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.save_raster"><code class="docutils literal notranslate"><span class="pre">save_raster()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.merge_geotiffs"><code class="docutils literal notranslate"><span class="pre">merge_geotiffs()</span></code></a></li>
<li><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">convert_format_lat_lon()</span></code></a></li>
<li><a class="reference internal" href="#id4"><code class="docutils literal notranslate"><span class="pre">get_coordinates_from_cityname()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_city_country_name_from_rectangle"><code class="docutils literal notranslate"><span class="pre">get_city_country_name_from_rectangle()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_timezone_info"><code class="docutils literal notranslate"><span class="pre">get_timezone_info()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.validate_polygon_coordinates"><code class="docutils literal notranslate"><span class="pre">validate_polygon_coordinates()</span></code></a></li>
<li><a class="reference internal" href="#id5"><code class="docutils literal notranslate"><span class="pre">create_building_polygons()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_country_name"><code class="docutils literal notranslate"><span class="pre">get_country_name()</span></code></a></li>
<li><a class="reference internal" href="#id6"><code class="docutils literal notranslate"><span class="pre">grid_to_geodataframe()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.vectorized_edge_values"><code class="docutils literal notranslate"><span class="pre">vectorized_edge_values()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_network_values"><code class="docutils literal notranslate"><span class="pre">get_network_values()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.interpolate_points_along_line"><code class="docutils literal notranslate"><span class="pre">interpolate_points_along_line()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.gather_interpolation_points"><code class="docutils literal notranslate"><span class="pre">gather_interpolation_points()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.fetch_elevations_for_points"><code class="docutils literal notranslate"><span class="pre">fetch_elevations_for_points()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.compute_slope_for_group"><code class="docutils literal notranslate"><span class="pre">compute_slope_for_group()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.calculate_edge_slopes_from_join"><code class="docutils literal notranslate"><span class="pre">calculate_edge_slopes_from_join()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.analyze_network_slopes"><code class="docutils literal notranslate"><span class="pre">analyze_network_slopes()</span></code></a></li>
<li><a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">validate_polygon_coordinates()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.filter_and_convert_gdf_to_geojson"><code class="docutils literal notranslate"><span class="pre">filter_and_convert_gdf_to_geojson()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_geojson_from_gpkg"><code class="docutils literal notranslate"><span class="pre">get_geojson_from_gpkg()</span></code></a></li>
<li><a class="reference internal" href="#id8"><code class="docutils literal notranslate"><span class="pre">extract_building_heights_from_gdf()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.geojson_to_gdf"><code class="docutils literal notranslate"><span class="pre">geojson_to_gdf()</span></code></a></li>
<li><a class="reference internal" href="#id9"><code class="docutils literal notranslate"><span class="pre">complement_building_heights_from_gdf()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.gdf_to_geojson_dicts"><code class="docutils literal notranslate"><span class="pre">gdf_to_geojson_dicts()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.load_gdf_from_multiple_gz"><code class="docutils literal notranslate"><span class="pre">load_gdf_from_multiple_gz()</span></code></a></li>
<li><a class="reference internal" href="#id10"><code class="docutils literal notranslate"><span class="pre">filter_buildings()</span></code></a></li>
<li><a class="reference internal" href="#id11"><code class="docutils literal notranslate"><span class="pre">extract_building_heights_from_geotiff()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_gdf_from_gpkg"><code class="docutils literal notranslate"><span class="pre">get_gdf_from_gpkg()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.swap_coordinates"><code class="docutils literal notranslate"><span class="pre">swap_coordinates()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.save_geojson"><code class="docutils literal notranslate"><span class="pre">save_geojson()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.find_building_containing_point"><code class="docutils literal notranslate"><span class="pre">find_building_containing_point()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.get_buildings_in_drawn_polygon"><code class="docutils literal notranslate"><span class="pre">get_buildings_in_drawn_polygon()</span></code></a></li>
<li><a class="reference internal" href="#id12"><code class="docutils literal notranslate"><span class="pre">process_building_footprints_by_overlap()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_voxel_mesh"><code class="docutils literal notranslate"><span class="pre">create_voxel_mesh()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_sim_surface_mesh"><code class="docutils literal notranslate"><span class="pre">create_sim_surface_mesh()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.create_city_meshes"><code class="docutils literal notranslate"><span class="pre">create_city_meshes()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.export_meshes"><code class="docutils literal notranslate"><span class="pre">export_meshes()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.split_vertices_manual"><code class="docutils literal notranslate"><span class="pre">split_vertices_manual()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.geoprocessor.save_obj_from_colored_mesh"><code class="docutils literal notranslate"><span class="pre">save_obj_from_colored_mesh()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=8a448e45"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>
<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" /><link rel="next" title="voxcity.simulator.solar" href="solar/index.html" /><link rel="prev" title="voxcity.geoprocessor.polygon" href="../geoprocessor/polygon/index.html" />

    <link rel="shortcut icon" href="../../../_static/favicon.ico"/><!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>voxcity.simulator - VoxCity Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=7edd21af" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">VoxCity Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.png" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.png" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">VoxCity Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../example.html"><strong>VoxCity Demo</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step1-prepare-environment">Step1. Prepare environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step2-set-target-area-by-a-rectangle">Step2. Set target area by a rectangle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step3-set-variables">Step3 Set variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step4-get-voxcity-output">Step4 Get voxcity output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step5-export-files">Step5 Export files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step6-urban-simulations">Step6 Urban simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#solar-radiation">6.1. Solar radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#landmark-visibility">6.3. Landmark visibility</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../index.html">API Reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current has-children"><a class="reference internal" href="../index.html">voxcity</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of voxcity</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3 has-children"><a class="reference internal" href="../downloader/index.html">voxcity.downloader</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of voxcity.downloader</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../downloader/citygml/index.html">voxcity.downloader.citygml</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/eubucco/index.html">voxcity.downloader.eubucco</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/gee/index.html">voxcity.downloader.gee</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/mbfp/index.html">voxcity.downloader.mbfp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/oemj/index.html">voxcity.downloader.oemj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/osm/index.html">voxcity.downloader.osm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../downloader/overture/index.html">voxcity.downloader.overture</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../exporter/index.html">voxcity.exporter</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of voxcity.exporter</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../exporter/envimet/index.html">voxcity.exporter.envimet</a></li>
<li class="toctree-l4"><a class="reference internal" href="../exporter/magicavoxel/index.html">voxcity.exporter.magicavoxel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../exporter/obj/index.html">voxcity.exporter.obj</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../generator/index.html">voxcity.generator</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../geoprocessor/index.html">voxcity.geoprocessor</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of voxcity.geoprocessor</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../geoprocessor/draw/index.html">voxcity.geoprocessor.draw</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geoprocessor/grid/index.html">voxcity.geoprocessor.grid</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geoprocessor/mesh/index.html">voxcity.geoprocessor.mesh</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geoprocessor/network/index.html">voxcity.geoprocessor.network</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geoprocessor/polygon/index.html">voxcity.geoprocessor.polygon</a></li>
</ul>
</li>
<li class="toctree-l3 current has-children current-page"><a class="current reference internal" href="#">voxcity.simulator</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of voxcity.simulator</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="solar/index.html">voxcity.simulator.solar</a></li>
<li class="toctree-l4"><a class="reference internal" href="view/index.html">voxcity.simulator.view</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial:</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../examples/index.html">Use cases of VoxCity</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Use cases of VoxCity</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html"><strong>VoxCity Demo</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step1-prepare-environment">Step1. Prepare environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step2-set-target-area-by-a-rectangle">Step2. Set target area by a rectangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step3-set-variables">Step3 Set variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step4-get-voxcity-output">Step4 Get voxcity output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step5-export-files">Step5 Export files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step6-urban-simulations">Step6 Urban simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#solar-radiation">6.1. Solar radiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#landmark-visibility">6.3. Landmark visibility</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Information:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">=======
History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">============
Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conduct.html">====================================
Contributor Covenant Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../../../_sources/autoapi/voxcity/simulator/index.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-voxcity.simulator">
<span id="voxcity-simulator"></span><h1>voxcity.simulator<a class="headerlink" href="#module-voxcity.simulator" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="solar/index.html">voxcity.simulator.solar</a></li>
<li class="toctree-l1"><a class="reference internal" href="view/index.html">voxcity.simulator.view</a></li>
</ul>
</div>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.find_building_containing_point" title="voxcity.simulator.find_building_containing_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_building_containing_point</span></code></a>(building_gdf, target_point)</p></td>
<td><p>Find building IDs that contain a given point in their footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.get_buildings_in_drawn_polygon" title="voxcity.simulator.get_buildings_in_drawn_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_buildings_in_drawn_polygon</span></code></a>(building_gdf, ...[, ...])</p></td>
<td><p>Find buildings that intersect with or are contained within a user-drawn polygon.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.create_voxel_mesh" title="voxcity.simulator.create_voxel_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_voxel_mesh</span></code></a>(voxel_array, class_id[, meshsize, ...])</p></td>
<td><p>Create a 3D mesh from voxels preserving sharp edges, scaled by meshsize.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id4" title="voxcity.simulator.grid_to_obj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_to_obj</span></code></a>(value_array_ori, dem_array_ori, ...[, ...])</p></td>
<td><p>Converts a 2D array of values and a corresponding DEM array to an OBJ file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id5" title="voxcity.simulator.export_obj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_obj</span></code></a>(array, output_dir, file_name, voxel_size[, ...])</p></td>
<td><p>Export a voxel array to OBJ format with materials and proper face orientations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.calculate_transmittance" title="voxcity.simulator.calculate_transmittance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_transmittance</span></code></a>(length[, tree_k, tree_lad])</p></td>
<td><p>Calculate tree transmittance using the Beer-Lambert law.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="voxcity.simulator.trace_ray_generic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace_ray_generic</span></code></a>(voxel_data, origin, direction, ...)</p></td>
<td><p>Trace a ray through a voxel grid and check for hits with specified values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.compute_vi_generic" title="voxcity.simulator.compute_vi_generic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_vi_generic</span></code></a>(observer_location, voxel_data, ...)</p></td>
<td><p>Compute view index accounting for tree transmittance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id1" title="voxcity.simulator.compute_vi_map_generic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_vi_map_generic</span></code></a>(voxel_data, ray_directions, ...)</p></td>
<td><p>Compute view index map incorporating tree transmittance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.get_view_index" title="voxcity.simulator.get_view_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_view_index</span></code></a>(voxel_data, meshsize[, mode, ...])</p></td>
<td><p>Calculate and visualize a generic view index for a voxel city model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.mark_building_by_id" title="voxcity.simulator.mark_building_by_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mark_building_by_id</span></code></a>(voxcity_grid_ori, ...)</p></td>
<td><p>Mark specific buildings in the voxel grid with a given value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.trace_ray_to_target" title="voxcity.simulator.trace_ray_to_target"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace_ray_to_target</span></code></a>(voxel_data, origin, target, ...)</p></td>
<td><p>Trace a ray from origin to target through voxel data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.compute_visibility_to_all_landmarks" title="voxcity.simulator.compute_visibility_to_all_landmarks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_visibility_to_all_landmarks</span></code></a>(observer_location, ...)</p></td>
<td><p>Check if any landmark is visible from the observer location.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.compute_visibility_map" title="voxcity.simulator.compute_visibility_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_visibility_map</span></code></a>(voxel_data, landmark_positions, ...)</p></td>
<td><p>Compute visibility map for landmarks in the voxel grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.compute_landmark_visibility" title="voxcity.simulator.compute_landmark_visibility"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_landmark_visibility</span></code></a>(voxel_data[, ...])</p></td>
<td><p>Compute and visualize landmark visibility in a voxel grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.get_landmark_visibility_map" title="voxcity.simulator.get_landmark_visibility_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_landmark_visibility_map</span></code></a>(voxcity_grid_ori, ...)</p></td>
<td><p>Generate a visibility map for landmark buildings in a voxel city.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id2" title="voxcity.simulator.get_sky_view_factor_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sky_view_factor_map</span></code></a>(voxel_data, meshsize[, show_plot])</p></td>
<td><p>Compute and visualize the Sky View Factor (SVF) for each valid observer cell in the voxel grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.rotate_vector_axis_angle" title="voxcity.simulator.rotate_vector_axis_angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_vector_axis_angle</span></code></a>(vec, axis, angle)</p></td>
<td><p>Rotate a 3D vector around an arbitrary axis using Rodrigues' rotation formula.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.compute_view_factor_for_all_faces" title="voxcity.simulator.compute_view_factor_for_all_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_view_factor_for_all_faces</span></code></a>(face_centers, ...[, ...])</p></td>
<td><p>Compute a per-face &quot;view factor&quot; for a specified set of target voxel classes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id3" title="voxcity.simulator.get_surface_view_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_surface_view_factor</span></code></a>(voxel_data, meshsize, **kwargs)</p></td>
<td><p>Compute and optionally visualize view factors for surface meshes with respect to target voxel classes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="voxcity.simulator.trace_ray_generic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace_ray_generic</span></code></a>(voxel_data, origin, direction, ...)</p></td>
<td><p>Trace a ray through a voxel grid and check for hits with specified values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id1" title="voxcity.simulator.compute_vi_map_generic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_vi_map_generic</span></code></a>(voxel_data, ray_directions, ...)</p></td>
<td><p>Compute view index map incorporating tree transmittance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id2" title="voxcity.simulator.get_sky_view_factor_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sky_view_factor_map</span></code></a>(voxel_data, meshsize[, show_plot])</p></td>
<td><p>Compute and visualize the Sky View Factor (SVF) for each valid observer cell in the voxel grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id3" title="voxcity.simulator.get_surface_view_factor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_surface_view_factor</span></code></a>(voxel_data, meshsize, **kwargs)</p></td>
<td><p>Compute and optionally visualize view factors for surface meshes with respect to target voxel classes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.get_nearest_epw_from_climate_onebuilding" title="voxcity.simulator.get_nearest_epw_from_climate_onebuilding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_nearest_epw_from_climate_onebuilding</span></code></a>(...)</p></td>
<td><p>Download and process EPW weather file from Climate.OneBuilding.Org based on coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.read_epw_for_solar_simulation" title="voxcity.simulator.read_epw_for_solar_simulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_epw_for_solar_simulation</span></code></a>(epw_file_path)</p></td>
<td><p>Read EPW file specifically for solar simulation purposes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id4" title="voxcity.simulator.grid_to_obj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_to_obj</span></code></a>(value_array_ori, dem_array_ori, ...[, ...])</p></td>
<td><p>Converts a 2D array of values and a corresponding DEM array to an OBJ file</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id5" title="voxcity.simulator.export_obj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">export_obj</span></code></a>(array, output_dir, file_name, voxel_size[, ...])</p></td>
<td><p>Export a voxel array to OBJ format with materials and proper face orientations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.compute_direct_solar_irradiance_map_binary" title="voxcity.simulator.compute_direct_solar_irradiance_map_binary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_direct_solar_irradiance_map_binary</span></code></a>(voxel_data, ...)</p></td>
<td><p>Compute a map of direct solar irradiation accounting for tree transmittance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.get_direct_solar_irradiance_map" title="voxcity.simulator.get_direct_solar_irradiance_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_direct_solar_irradiance_map</span></code></a>(voxel_data, meshsize, ...)</p></td>
<td><p>Compute direct solar irradiance map with tree transmittance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.get_diffuse_solar_irradiance_map" title="voxcity.simulator.get_diffuse_solar_irradiance_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_diffuse_solar_irradiance_map</span></code></a>(voxel_data, meshsize)</p></td>
<td><p>Compute diffuse solar irradiance map using the Sky View Factor (SVF) with tree transmittance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.get_global_solar_irradiance_map" title="voxcity.simulator.get_global_solar_irradiance_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_global_solar_irradiance_map</span></code></a>(voxel_data, meshsize, ...)</p></td>
<td><p>Compute global solar irradiance (direct + diffuse) on a horizontal plane at each valid observer location.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.get_solar_positions_astral" title="voxcity.simulator.get_solar_positions_astral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_solar_positions_astral</span></code></a>(times, lon, lat)</p></td>
<td><p>Compute solar azimuth and elevation using Astral for given times and location.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.get_cumulative_global_solar_irradiance" title="voxcity.simulator.get_cumulative_global_solar_irradiance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_cumulative_global_solar_irradiance</span></code></a>(voxel_data, ...)</p></td>
<td><p>Compute cumulative global solar irradiance over a specified period using data from an EPW file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.get_global_solar_irradiance_using_epw" title="voxcity.simulator.get_global_solar_irradiance_using_epw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_global_solar_irradiance_using_epw</span></code></a>(voxel_data, meshsize)</p></td>
<td><p>Compute global solar irradiance using EPW weather data, either for a single time or cumulatively over a period.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.compute_solar_irradiance_for_all_faces" title="voxcity.simulator.compute_solar_irradiance_for_all_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_solar_irradiance_for_all_faces</span></code></a>(face_centers, ...)</p></td>
<td><p>Numba-compiled function to compute direct, diffuse, and global solar irradiance</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.get_building_solar_irradiance" title="voxcity.simulator.get_building_solar_irradiance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_building_solar_irradiance</span></code></a>(voxel_data, meshsize, ...)</p></td>
<td><p>Calculate solar irradiance on building surfaces using Sky View Factor (SVF) analysis,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.get_cumulative_building_solar_irradiance" title="voxcity.simulator.get_cumulative_building_solar_irradiance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_cumulative_building_solar_irradiance</span></code></a>(voxel_data, ...)</p></td>
<td><p>Calculate cumulative solar irradiance on building surfaces over a time period.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.get_building_global_solar_irradiance_using_epw" title="voxcity.simulator.get_building_global_solar_irradiance_using_epw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_building_global_solar_irradiance_using_epw</span></code></a>(...[, ...])</p></td>
<td><p>Compute global solar irradiance on building surfaces using EPW weather data, either for a single time or cumulatively.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.save_irradiance_mesh" title="voxcity.simulator.save_irradiance_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_irradiance_mesh</span></code></a>(irradiance_mesh, output_file_path)</p></td>
<td><p>Save the irradiance mesh data to a file using pickle serialization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#voxcity.simulator.load_irradiance_mesh" title="voxcity.simulator.load_irradiance_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_irradiance_mesh</span></code></a>(input_file_path)</p></td>
<td><p>Load previously saved irradiance mesh data from a file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#voxcity.simulator.dummy_function" title="voxcity.simulator.dummy_function"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dummy_function</span></code></a>(test_string)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.find_building_containing_point">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">find_building_containing_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">building_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#find_building_containing_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.find_building_containing_point" title="Link to this definition">¶</a></dt>
<dd><p>Find building IDs that contain a given point in their footprint.</p>
<p>This function identifies all buildings in a GeoDataFrame whose footprint contains
a specified geographic point. Only Polygon geometries are considered, and the point
must be fully contained within the building footprint (not just touching).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>building_gdf</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing building geometries and IDs
Must have ‘geometry’ column with Polygon geometries
Must have ‘id’ column or index will be used as fallback
Geometries must be in same CRS as target_point coordinates</p></li>
<li><p><strong>target_point</strong> (<em>tuple</em>) – Tuple of (lon, lat) coordinates to check
Must be in same coordinate system as building_gdf geometries
Order must be (longitude, latitude) if using WGS84</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>List of building IDs containing the target point</dt><dd><p>Empty list if no buildings contain the point
Multiple IDs possible if buildings overlap
IDs are in arbitrary order</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Only processes Polygon geometries (skips MultiPolygons and others)</p></li>
<li><p>Uses Shapely’s contains() method which requires point to be fully inside polygon</p></li>
<li><p>No spatial indexing is used, performs linear search through all buildings</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_buildings_in_drawn_polygon">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_buildings_in_drawn_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">building_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drawn_polygon_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'within'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/polygon.html#get_buildings_in_drawn_polygon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_buildings_in_drawn_polygon" title="Link to this definition">¶</a></dt>
<dd><p>Find buildings that intersect with or are contained within a user-drawn polygon.</p>
<p>This function identifies buildings from a GeoDataFrame that have a specified spatial
relationship with a polygon defined by user-drawn vertices. The relationship can be
either intersection (building overlaps polygon) or containment (building fully within
polygon).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>building_gdf</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing building footprints
Must have ‘geometry’ column with Polygon geometries
Must have ‘id’ column or index will be used as fallback
Geometries must be in same CRS as drawn_polygon_vertices</p></li>
<li><p><strong>drawn_polygon_vertices</strong> (<em>list</em>) – List of (lon, lat) tuples defining polygon vertices
Must be in same coordinate system as building_gdf geometries
Must form a valid polygon (3+ vertices, first != last)
Order must be (longitude, latitude) if using WGS84</p></li>
<li><p><strong>operation</strong> (<em>str</em><em>, </em><em>optional</em>) – Type of spatial relationship to check
‘within’: buildings must be fully contained in drawn polygon (default)
‘intersect’: buildings must overlap with drawn polygon</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>List of building IDs that satisfy the spatial relationship</dt><dd><p>Empty list if no buildings meet the criteria
IDs are returned in order of processing
May contain None values if buildings lack IDs</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Only processes Polygon geometries (skips MultiPolygons and others)</p></li>
<li><p>No spatial indexing is used, performs linear search through all buildings</p></li>
<li><p>Invalid operation parameter will raise ValueError</p></li>
<li><p>Does not validate polygon closure (first vertex = last vertex)</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.create_voxel_mesh">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">create_voxel_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">building_id_grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/geoprocessor/mesh.html#create_voxel_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.create_voxel_mesh" title="Link to this definition">¶</a></dt>
<dd><p>Create a 3D mesh from voxels preserving sharp edges, scaled by meshsize.</p>
<p>This function converts a 3D voxel array into a triangulated mesh, where each voxel
face is converted into two triangles. The function preserves sharp edges between
different classes and handles special cases for buildings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_array</strong> (<em>np.ndarray</em><em> (</em><em>3D</em><em>)</em>) – The voxel array of shape (X, Y, Z) where each cell contains a class ID.
- 0: typically represents void/air
- -2: typically represents trees
- -3: typically represents buildings
Other values can represent different classes as defined by the application.</p></li>
<li><p><strong>class_id</strong> (<em>int</em>) – The ID of the class to extract. Only voxels with this ID will be included
in the output mesh.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em><em>, </em><em>default=1.0</em>) – The real-world size of each voxel in meters, applied uniformly to x, y, and z
dimensions. Used to scale the output mesh to real-world coordinates.</p></li>
<li><p><strong>building_id_grid</strong> (<em>np.ndarray</em><em> (</em><em>2D</em><em>)</em><em>, </em><em>optional</em>) – 2D grid of building IDs with shape (X, Y). Only used when class_id=-3 (buildings).
Each cell contains a unique identifier for the building at that location.
This allows tracking which faces belong to which building.</p></li>
<li><p><strong>mesh_type</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>Type of mesh to create, controlling which faces are included:
- None (default): create faces at boundaries between different classes
- ‘building_solar’: only create faces at boundaries between buildings (-3)</p>
<blockquote>
<div><p>and either void (0) or trees (-2). Useful for solar analysis
where only exposed surfaces matter.</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>mesh</strong> – The resulting triangulated mesh for the given class_id. Returns None if no
voxels of the specified class are found.</p>
<p>The mesh includes:
- vertices: 3D coordinates of each vertex
- faces: triangles defined by vertex indices
- face_normals: normal vectors for each face
- metadata: If class_id=-3, includes ‘building_id’ mapping faces to buildings</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh or None</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic usage for a simple voxel array:
&gt;&gt;&gt; voxels = np.zeros((10, 10, 10))
&gt;&gt;&gt; voxels[4:7, 4:7, 0:5] = 1  # Create a simple column
&gt;&gt;&gt; mesh = create_voxel_mesh(voxels, class_id=1, meshsize=0.5)</p>
<p>Creating a building mesh with IDs:
&gt;&gt;&gt; building_ids = np.zeros((10, 10))
&gt;&gt;&gt; building_ids[4:7, 4:7] = 1  # Mark building #1
&gt;&gt;&gt; mesh = create_voxel_mesh(voxels, class_id=-3,
…                         building_id_grid=building_ids,
…                         meshsize=1.0)</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function creates faces only at boundaries between different classes or at
the edges of the voxel array.</p></li>
<li><p>Each face is split into two triangles for compatibility with graphics engines.</p></li>
<li><p>Face normals are computed to ensure correct lighting and rendering.</p></li>
<li><p>For buildings (class_id=-3), building IDs are tracked to maintain building identity.</p></li>
<li><p>The mesh preserves sharp edges, which is important for architectural visualization.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.grid_to_obj">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">grid_to_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_array_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem_array_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/exporter/obj.html#grid_to_obj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.grid_to_obj" title="Link to this definition">¶</a></dt>
<dd><p>Converts a 2D array of values and a corresponding DEM array to an OBJ file
with specified colormap, transparency, and value range.</p>
<p>This function creates a 3D visualization of 2D grid data by using elevation
data and color mapping. It’s particularly useful for visualizing terrain data,
analysis results, or any 2D data that should be displayed with elevation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value_array_ori</strong> (<em>ndarray</em>) – 2D array of values to visualize.
These values will be mapped to colors using the specified colormap.</p></li>
<li><p><strong>dem_array_ori</strong> (<em>ndarray</em>) – 2D array of DEM values corresponding to value_array.
Provides elevation data for the 3D visualization.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to save the OBJ and MTL files.
Will be created if it doesn’t exist.</p></li>
<li><p><strong>file_name</strong> (<em>str</em>) – Base name for the output files.
Used for both .obj and .mtl files.</p></li>
<li><p><strong>cell_size</strong> (<em>float</em>) – Size of each cell in the grid (e.g., in meters).
Used to scale the model to real-world units.</p></li>
<li><p><strong>offset</strong> (<em>float</em>) – Elevation offset added after quantization.
Useful for adjusting the base height of the model.</p></li>
<li><p><strong>colormap_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the Matplotlib colormap to use.
Defaults to ‘viridis’. Must be a valid Matplotlib colormap name.</p></li>
<li><p><strong>num_colors</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of discrete colors to use from the colormap.
Defaults to 256. Higher values give smoother color transitions.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em>) – Transparency value between 0.0 (transparent) and 1.0 (opaque).
Defaults to 1.0 (fully opaque).</p></li>
<li><p><strong>vmin</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum value for colormap normalization.
If None, uses data minimum. Used to control color mapping range.</p></li>
<li><p><strong>vmax</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum value for colormap normalization.
If None, uses data maximum. Used to control color mapping range.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Automatically handles NaN values in input arrays</p></li>
<li><p>Creates triangulated mesh for proper rendering</p></li>
<li><p>Supports transparency and color mapping</p></li>
<li><p>Generates complete OBJ and MTL files</p></li>
<li><p>Maintains consistent coordinate system</p></li>
<li><p>Optimizes mesh generation for large grids</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If vmin equals vmax or if colormap_name is invalid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.export_obj">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">export_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_color_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/exporter/obj.html#export_obj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.export_obj" title="Link to this definition">¶</a></dt>
<dd><p>Export a voxel array to OBJ format with materials and proper face orientations.</p>
<p>This function converts a 3D voxel array into a complete OBJ file with materials,
performing mesh optimization and ensuring proper face orientations. It generates
both OBJ and MTL files with all necessary components for rendering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>ndarray</em>) – 3D numpy array containing voxel values.
Non-zero values indicate voxel presence and material type.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to save the OBJ and MTL files.
Will be created if it doesn’t exist.</p></li>
<li><p><strong>file_name</strong> (<em>str</em>) – Base name for the output files.
Will be used for both .obj and .mtl files.</p></li>
<li><p><strong>voxel_size</strong> (<em>float</em>) – Size of each voxel in meters.
Used to scale the model to real-world units.</p></li>
<li><p><strong>voxel_color_map</strong> (<em>dict</em><em>, </em><em>optional</em>) – Dictionary mapping voxel values to RGB colors.
If None, uses default color map. Colors should be RGB lists (0-255).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Generates optimized mesh using greedy meshing</p></li>
<li><p>Creates complete OBJ file with vertices, normals, and faces</p></li>
<li><p>Generates MTL file with material definitions</p></li>
<li><p>Handles proper face orientation and winding order</p></li>
<li><p>Supports color mapping for visualization</p></li>
<li><p>Uses consistent coordinate system throughout</p></li>
</ul>
<dl>
<dt>File Format Details:</dt><dd><p>OBJ file contains:
- Vertex coordinates (v)
- Normal vectors (vn)
- Material references (usemtl)
- Face definitions (f)</p>
<p>MTL file contains:
- Material names and colors
- Ambient, diffuse, and specular properties
- Transparency settings
- Illumination model definitions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.calculate_transmittance">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">calculate_transmittance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#calculate_transmittance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.calculate_transmittance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate tree transmittance using the Beer-Lambert law.</p>
<p>Uses the Beer-Lambert law to model light attenuation through tree canopy:
transmittance = exp(-k * LAD * L)
where:
- k is the extinction coefficient
- LAD is the leaf area density
- L is the path length through the canopy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>float</em>) – Path length through tree voxel in meters</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Static extinction coefficient (default: 0.6)
Controls overall light attenuation strength</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1 (default: 1.0)
Higher values = denser foliage = more attenuation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Transmittance value between 0 and 1</dt><dd><p>1.0 = fully transparent
0.0 = fully opaque</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.trace_ray_generic">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">trace_ray_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#trace_ray_generic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.trace_ray_generic" title="Link to this definition">¶</a></dt>
<dd><p>Trace a ray through a voxel grid and check for hits with specified values.</p>
<p>Uses DDA algorithm to efficiently traverse voxels along ray path.
Handles tree transmittance using Beer-Lambert law.</p>
<p>The DDA algorithm:
1. Initializes ray at origin voxel
2. Calculates distances to next voxel boundaries in each direction
3. Steps to next voxel by choosing smallest distance
4. Repeats until hit or out of bounds</p>
<p>Tree transmittance:
- When ray passes through tree voxels (-2), transmittance is accumulated
- Uses Beer-Lambert law with configurable extinction coefficient and leaf area density
- Ray is considered blocked if cumulative transmittance falls below 0.01</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>origin</strong> (<em>ndarray</em>) – Starting point (x,y,z) of ray in voxel coordinates</p></li>
<li><p><strong>direction</strong> (<em>ndarray</em>) – Direction vector of ray (will be normalized)</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Values to check for hits</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – If True, hit_values are hits. If False, hit_values are allowed values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(hit_detected, transmittance_value)</dt><dd><p>hit_detected (bool): Whether ray hit a target voxel
transmittance_value (float): Cumulative transmittance through trees</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_vi_generic">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_vi_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observer_location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#compute_vi_generic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_vi_generic" title="Link to this definition">¶</a></dt>
<dd><p>Compute view index accounting for tree transmittance.</p>
<p>Casts rays in specified directions and computes visibility index based on hits and transmittance.
The view index is the ratio of visible rays to total rays cast, where:
- For inclusion mode: Counts hits with target values
- For exclusion mode: Counts rays that don’t hit obstacles
Tree transmittance is handled specially:
- In inclusion mode with trees as targets: Uses (1 - transmittance) as contribution
- In exclusion mode: Uses transmittance value directly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observer_location</strong> (<em>ndarray</em>) – Observer position (x,y,z) in voxel coordinates</p></li>
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>ray_directions</strong> (<em>ndarray</em>) – Array of direction vectors for rays</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Values to check for hits</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – If True, hit_values are hits. If False, hit_values are allowed values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>View index value between 0 and 1</dt><dd><p>0.0 = no visibility in any direction
1.0 = full visibility in all directions</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_vi_map_generic">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_vi_map_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_height_voxel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#compute_vi_map_generic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_vi_map_generic" title="Link to this definition">¶</a></dt>
<dd><p>Compute view index map incorporating tree transmittance.</p>
<p>Places observers at valid locations and computes view index for each position.
Valid observer locations are:
- Empty voxels (0) or tree voxels (-2)
- Above non-empty, non-tree voxels
- Not above water (7,8,9) or negative values</p>
<p>The function processes each x,y position in parallel for efficiency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>ray_directions</strong> (<em>ndarray</em>) – Array of direction vectors for rays</p></li>
<li><p><strong>view_height_voxel</strong> (<em>int</em>) – Observer height in voxel units</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Values to check for hits</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – If True, hit_values are hits. If False, hit_values are allowed values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of view index values</dt><dd><p>NaN = invalid observer location
0.0-1.0 = view index value</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_view_index">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_view_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#get_view_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_view_index" title="Link to this definition">¶</a></dt>
<dd><p>Calculate and visualize a generic view index for a voxel city model.</p>
<p>This is a high-level function that provides a flexible interface for computing
various view indices. It handles:
- Mode presets for common indices (green, sky)
- Ray direction generation
- Tree transmittance parameters
- Visualization
- Optional OBJ export</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters.</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – Predefined mode. Options: ‘green’, ‘sky’, or None.
If ‘green’: GVI mode - measures visibility of vegetation
If ‘sky’: SVI mode - measures visibility of open sky
If None: Custom mode requiring hit_values parameter</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Voxel values considered as hits (if inclusion_mode=True)
or allowed values (if inclusion_mode=False), if mode is None.</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – True = voxel_value in hit_values is success.
False = voxel_value not in hit_values is success.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments:
- view_point_height (float): Observer height in meters (default: 1.5)
- colormap (str): Matplotlib colormap name (default: ‘viridis’)
- obj_export (bool): Export as OBJ (default: False)
- output_directory (str): Directory for OBJ output
- output_file_name (str): Base filename for OBJ output
- num_colors (int): Number of discrete colors for OBJ export
- alpha (float): Transparency value for OBJ export
- vmin (float): Minimum value for color mapping
- vmax (float): Maximum value for color mapping
- N_azimuth (int): Number of azimuth angles for ray directions
- N_elevation (int): Number of elevation angles for ray directions
- elevation_min_degrees (float): Minimum elevation angle in degrees
- elevation_max_degrees (float): Maximum elevation angle in degrees
- tree_k (float): Tree extinction coefficient (default: 0.5)
- tree_lad (float): Leaf area density in m^-1 (default: 1.0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D array of computed view index values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.mark_building_by_id">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">mark_building_by_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxcity_grid_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">building_id_grid_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mark</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#mark_building_by_id"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.mark_building_by_id" title="Link to this definition">¶</a></dt>
<dd><p>Mark specific buildings in the voxel grid with a given value.</p>
<p>This function is used to identify landmark buildings for visibility analysis
by replacing their voxel values with a special marker value. It handles
coordinate system alignment between the building ID grid and voxel grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxcity_grid_ori</strong> (<em>ndarray</em>) – 3D array of voxel values (original, will be copied)</p></li>
<li><p><strong>building_id_grid_ori</strong> (<em>ndarray</em>) – 2D array of building IDs (original, will be copied)</p></li>
<li><p><strong>ids</strong> (<em>list</em>) – List of building IDs to mark as landmarks</p></li>
<li><p><strong>mark</strong> (<em>int</em>) – Value to mark the landmark buildings with (typically negative)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Modified 3D voxel grid with landmark buildings marked</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.trace_ray_to_target">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">trace_ray_to_target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opaque_values</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#trace_ray_to_target"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.trace_ray_to_target" title="Link to this definition">¶</a></dt>
<dd><p>Trace a ray from origin to target through voxel data.</p>
<p>Uses DDA algorithm to efficiently traverse voxels along ray path.
Checks for any opaque voxels blocking the line of sight.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>origin</strong> (<em>tuple</em>) – Starting point (x,y,z) in voxel coordinates</p></li>
<li><p><strong>target</strong> (<em>tuple</em>) – End point (x,y,z) in voxel coordinates</p></li>
<li><p><strong>opaque_values</strong> (<em>ndarray</em>) – Array of voxel values that block the ray</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if target is visible from origin, False otherwise</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_visibility_to_all_landmarks">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_visibility_to_all_landmarks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observer_location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">landmark_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opaque_values</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#compute_visibility_to_all_landmarks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_visibility_to_all_landmarks" title="Link to this definition">¶</a></dt>
<dd><p>Check if any landmark is visible from the observer location.</p>
<p>Traces rays to each landmark position until finding one that’s visible.
Uses optimized ray tracing with early exit on first visible landmark.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observer_location</strong> (<em>ndarray</em>) – Observer position (x,y,z) in voxel coordinates</p></li>
<li><p><strong>landmark_positions</strong> (<em>ndarray</em>) – Array of landmark positions (n_landmarks, 3)</p></li>
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>opaque_values</strong> (<em>ndarray</em>) – Array of voxel values that block visibility</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>1 if any landmark is visible, 0 if none are visible</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_visibility_map">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_visibility_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">landmark_positions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opaque_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_height_voxel</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#compute_visibility_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_visibility_map" title="Link to this definition">¶</a></dt>
<dd><p>Compute visibility map for landmarks in the voxel grid.</p>
<p>Places observers at valid locations (empty voxels above ground, excluding building
roofs and vegetation) and checks visibility to any landmark.</p>
<p>The function processes each x,y position in parallel for efficiency.
Valid observer locations are:
- Empty voxels (0) or tree voxels (-2)
- Above non-empty, non-tree voxels
- Not above water (7,8,9) or negative values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>landmark_positions</strong> (<em>ndarray</em>) – Array of landmark positions (n_landmarks, 3)</p></li>
<li><p><strong>opaque_values</strong> (<em>ndarray</em>) – Array of voxel values that block visibility</p></li>
<li><p><strong>view_height_voxel</strong> (<em>int</em>) – Height offset for observer in voxels</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of visibility values</dt><dd><p>NaN = invalid observer location
0 = no landmarks visible
1 = at least one landmark visible</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_landmark_visibility">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_landmark_visibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_height_voxel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#compute_landmark_visibility"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_landmark_visibility" title="Link to this definition">¶</a></dt>
<dd><p>Compute and visualize landmark visibility in a voxel grid.</p>
<p>Places observers at valid locations and checks visibility to any landmark voxel.
Generates a binary visibility map and visualization.</p>
<p>The function:
1. Identifies all landmark voxels (target_value)
2. Determines which voxel values block visibility
3. Computes visibility from each valid observer location
4. Generates visualization with legend</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>target_value</strong> (<em>int</em><em>, </em><em>optional</em>) – Value used to identify landmark voxels. Defaults to -30.</p></li>
<li><p><strong>view_height_voxel</strong> (<em>int</em><em>, </em><em>optional</em>) – Height offset for observer in voxels. Defaults to 0.</p></li>
<li><p><strong>colormap</strong> (<em>str</em><em>, </em><em>optional</em>) – Matplotlib colormap name. Defaults to ‘viridis’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of visibility values (0 or 1) with y-axis flipped</dt><dd><p>NaN = invalid observer location
0 = no landmarks visible
1 = at least one landmark visible</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If no landmark voxels are found with the specified target_value</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_landmark_visibility_map">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_landmark_visibility_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxcity_grid_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">building_id_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">building_gdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#get_landmark_visibility_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_landmark_visibility_map" title="Link to this definition">¶</a></dt>
<dd><p>Generate a visibility map for landmark buildings in a voxel city.</p>
<p>Places observers at valid locations and checks visibility to any part of the
specified landmark buildings. Can identify landmarks either by ID or by finding
buildings within a specified rectangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxcity_grid</strong> (<em>ndarray</em>) – 3D array representing the voxel city</p></li>
<li><p><strong>building_id_grid</strong> (<em>ndarray</em>) – 3D array mapping voxels to building IDs</p></li>
<li><p><strong>building_gdf</strong> (<em>GeoDataFrame</em>) – GeoDataFrame containing building features</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments
view_point_height (float): Height of observer viewpoint in meters
colormap (str): Matplotlib colormap name
landmark_building_ids (list): List of building IDs to mark as landmarks
rectangle_vertices (list): List of (lat,lon) coordinates defining rectangle
obj_export (bool): Whether to export visibility map as OBJ file
dem_grid (ndarray): Digital elevation model grid for OBJ export
output_directory (str): Directory for OBJ file output
output_file_name (str): Base filename for OBJ output
alpha (float): Alpha transparency value for OBJ export
vmin (float): Minimum value for color mapping
vmax (float): Maximum value for color mapping</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D array of visibility values for landmark buildings</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_sky_view_factor_map">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_sky_view_factor_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#get_sky_view_factor_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_sky_view_factor_map" title="Link to this definition">¶</a></dt>
<dd><p>Compute and visualize the Sky View Factor (SVF) for each valid observer cell in the voxel grid.</p>
<p>Sky View Factor measures the proportion of the sky hemisphere that is visible from a given point.
It ranges from 0 (completely obstructed) to 1 (completely open sky). This implementation:
- Uses hemisphere ray casting to sample sky visibility
- Accounts for tree transmittance using Beer-Lambert law
- Places observers at valid street-level locations
- Provides optional visualization and OBJ export</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters.</p></li>
<li><p><strong>show_plot</strong> (<em>bool</em>) – Whether to display the SVF visualization plot.</p></li>
<li><p><strong>**kwargs</strong> – Additional parameters including:
view_point_height (float): Observer height in meters (default: 1.5)
colormap (str): Matplotlib colormap name (default: ‘BuPu_r’)
vmin, vmax (float): Color scale limits (default: 0.0, 1.0)
N_azimuth (int): Number of azimuth angles for ray sampling (default: 60)
N_elevation (int): Number of elevation angles for ray sampling (default: 10)
elevation_min_degrees (float): Minimum elevation angle (default: 0)
elevation_max_degrees (float): Maximum elevation angle (default: 90)
tree_k (float): Tree extinction coefficient (default: 0.6)
tree_lad (float): Leaf area density in m^-1 (default: 1.0)
obj_export (bool): Whether to export as OBJ file (default: False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of SVF values at each valid observer location (x, y).</dt><dd><p>NaN values indicate invalid observer positions.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.rotate_vector_axis_angle">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">rotate_vector_axis_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#rotate_vector_axis_angle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.rotate_vector_axis_angle" title="Link to this definition">¶</a></dt>
<dd><p>Rotate a 3D vector around an arbitrary axis using Rodrigues’ rotation formula.</p>
<p>This function implements the Rodrigues rotation formula:
v_rot = v*cos(θ) + (k × v)*sin(θ) + k*(k·v)*(1-cos(θ))
where k is the unit rotation axis, θ is the rotation angle, and v is the input vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<em>ndarray</em>) – 3D vector to rotate [x, y, z]</p></li>
<li><p><strong>axis</strong> (<em>ndarray</em>) – 3D rotation axis vector [x, y, z] (will be normalized)</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – Rotation angle in radians</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Rotated 3D vector [x, y, z]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_view_factor_for_all_faces">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_view_factor_for_all_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face_centers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">face_normals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hemisphere_dirs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_bounds_real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_epsilon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_downward</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#compute_view_factor_for_all_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_view_factor_for_all_faces" title="Link to this definition">¶</a></dt>
<dd><p>Compute a per-face “view factor” for a specified set of target voxel classes.</p>
<p>This function computes view factors from building surface faces to target voxel types
(e.g., sky, trees, other buildings). It uses hemisphere ray casting with rotation
to align rays with each face’s normal direction.</p>
<p>Typical usage examples:
- Sky View Factor: target_values=(0,), inclusion_mode=False (sky voxels)
- Tree View Factor: target_values=(-2,), inclusion_mode=True (tree voxels)
- Building View Factor: target_values=(-3,), inclusion_mode=True (building voxels)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>face_centers</strong> (<em>np.ndarray</em>) – (n_faces, 3) face centroid positions in real coordinates.</p></li>
<li><p><strong>face_normals</strong> (<em>np.ndarray</em>) – (n_faces, 3) face normal vectors (outward pointing).</p></li>
<li><p><strong>hemisphere_dirs</strong> (<em>np.ndarray</em>) – (N, 3) set of direction vectors in the upper hemisphere.</p></li>
<li><p><strong>voxel_data</strong> (<em>np.ndarray</em>) – 3D array of voxel values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters.</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient for Beer-Lambert law.</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1 for tree transmittance.</p></li>
<li><p><strong>target_values</strong> (<em>tuple</em><em>[</em><em>int</em><em>]</em>) – Voxel classes that define a ‘hit’ or target.</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – If True, hitting target_values counts as visibility.
If False, hitting anything NOT in target_values blocks the ray.</p></li>
<li><p><strong>grid_bounds_real</strong> (<em>np.ndarray</em>) – [[x_min,y_min,z_min],[x_max,y_max,z_max]] in real coords.</p></li>
<li><p><strong>boundary_epsilon</strong> (<em>float</em>) – Tolerance for identifying boundary vertical faces.</p></li>
<li><p><strong>ignore_downward</strong> (<em>bool</em>) – If True, only consider upward rays. If False, consider all outward rays.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Computed view factor for each face.</dt><dd><p>NaN values indicate boundary vertical faces that should be excluded.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray of shape (n_faces,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_surface_view_factor">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_surface_view_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#get_surface_view_factor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_surface_view_factor" title="Link to this definition">¶</a></dt>
<dd><p>Compute and optionally visualize view factors for surface meshes with respect to target voxel classes.</p>
<p>This function provides a flexible framework for computing various surface-based view factors:
- Sky View Factor: Fraction of sky hemisphere visible from building surfaces
- Tree View Factor: Fraction of directions that intersect vegetation
- Building View Factor: Fraction of directions that intersect other buildings
- Custom View Factors: User-defined target voxel classes</p>
<p>The function extracts surface meshes from the voxel data, then computes view factors
for each face using hemisphere ray casting with proper geometric transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values representing the urban environment.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters for coordinate scaling.</p></li>
<li><p><strong>**kwargs</strong> – <p>Extensive configuration options including:
# Target specification:
target_values (tuple[int]): Voxel classes to measure visibility to (default: (0,) for sky)
inclusion_mode (bool): Interpretation of target_values (default: False for sky)</p>
<p># Surface extraction:
building_class_id (int): Voxel class to extract surfaces from (default: -3 for buildings)
building_id_grid (ndarray): Optional grid mapping voxels to building IDs</p>
<p># Ray sampling:
N_azimuth (int): Number of azimuth angles for hemisphere sampling (default: 60)
N_elevation (int): Number of elevation angles for hemisphere sampling (default: 10)</p>
<p># Tree transmittance (Beer-Lambert law):
tree_k (float): Tree extinction coefficient (default: 0.6)
tree_lad (float): Leaf area density in m^-1 (default: 1.0)</p>
<p># Visualization and export:
colormap (str): Matplotlib colormap for visualization (default: ‘BuPu_r’)
vmin, vmax (float): Color scale limits (default: 0.0, 1.0)
obj_export (bool): Whether to export mesh as OBJ file (default: False)
output_directory (str): Directory for OBJ export (default: “output”)
output_file_name (str): Base filename for OBJ export (default: “surface_view_factor”)</p>
<p># Other options:
progress_report (bool): Whether to print computation progress (default: False)
debug (bool): Enable debug output (default: False)</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Surface mesh with per-face view factor values stored in metadata.</dt><dd><p>The view factor values can be accessed via mesh.metadata[value_name].
Returns None if no surfaces are found or extraction fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh</p>
</dd>
</dl>
<dl>
<dt>Example Usage:</dt><dd><p># Sky View Factor for building surfaces
mesh = get_surface_view_factor(voxel_data, meshsize,</p>
<blockquote>
<div><p>target_values=(0,), inclusion_mode=False)</p>
</div></blockquote>
<p># Tree View Factor for building surfaces
mesh = get_surface_view_factor(voxel_data, meshsize,</p>
<blockquote>
<div><p>target_values=(-2,), inclusion_mode=True)</p>
</div></blockquote>
<p># Custom view factor with OBJ export
mesh = get_surface_view_factor(voxel_data, meshsize,</p>
<blockquote>
<div><p>target_values=(-3,), inclusion_mode=True,
obj_export=True, output_file_name=”building_view_factor”)</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">trace_ray_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#trace_ray_generic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Link to this definition">¶</a></dt>
<dd><p>Trace a ray through a voxel grid and check for hits with specified values.</p>
<p>Uses DDA algorithm to efficiently traverse voxels along ray path.
Handles tree transmittance using Beer-Lambert law.</p>
<p>The DDA algorithm:
1. Initializes ray at origin voxel
2. Calculates distances to next voxel boundaries in each direction
3. Steps to next voxel by choosing smallest distance
4. Repeats until hit or out of bounds</p>
<p>Tree transmittance:
- When ray passes through tree voxels (-2), transmittance is accumulated
- Uses Beer-Lambert law with configurable extinction coefficient and leaf area density
- Ray is considered blocked if cumulative transmittance falls below 0.01</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>origin</strong> (<em>ndarray</em>) – Starting point (x,y,z) of ray in voxel coordinates</p></li>
<li><p><strong>direction</strong> (<em>ndarray</em>) – Direction vector of ray (will be normalized)</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Values to check for hits</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – If True, hit_values are hits. If False, hit_values are allowed values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(hit_detected, transmittance_value)</dt><dd><p>hit_detected (bool): Whether ray hit a target voxel
transmittance_value (float): Cumulative transmittance through trees</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id1">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_vi_map_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ray_directions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_height_voxel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#compute_vi_map_generic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id1" title="Link to this definition">¶</a></dt>
<dd><p>Compute view index map incorporating tree transmittance.</p>
<p>Places observers at valid locations and computes view index for each position.
Valid observer locations are:
- Empty voxels (0) or tree voxels (-2)
- Above non-empty, non-tree voxels
- Not above water (7,8,9) or negative values</p>
<p>The function processes each x,y position in parallel for efficiency.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values</p></li>
<li><p><strong>ray_directions</strong> (<em>ndarray</em>) – Array of direction vectors for rays</p></li>
<li><p><strong>view_height_voxel</strong> (<em>int</em>) – Observer height in voxel units</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Values to check for hits</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – If True, hit_values are hits. If False, hit_values are allowed values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of view index values</dt><dd><p>NaN = invalid observer location
0.0-1.0 = view index value</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id2">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_sky_view_factor_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#get_sky_view_factor_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id2" title="Link to this definition">¶</a></dt>
<dd><p>Compute and visualize the Sky View Factor (SVF) for each valid observer cell in the voxel grid.</p>
<p>Sky View Factor measures the proportion of the sky hemisphere that is visible from a given point.
It ranges from 0 (completely obstructed) to 1 (completely open sky). This implementation:
- Uses hemisphere ray casting to sample sky visibility
- Accounts for tree transmittance using Beer-Lambert law
- Places observers at valid street-level locations
- Provides optional visualization and OBJ export</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters.</p></li>
<li><p><strong>show_plot</strong> (<em>bool</em>) – Whether to display the SVF visualization plot.</p></li>
<li><p><strong>**kwargs</strong> – Additional parameters including:
view_point_height (float): Observer height in meters (default: 1.5)
colormap (str): Matplotlib colormap name (default: ‘BuPu_r’)
vmin, vmax (float): Color scale limits (default: 0.0, 1.0)
N_azimuth (int): Number of azimuth angles for ray sampling (default: 60)
N_elevation (int): Number of elevation angles for ray sampling (default: 10)
elevation_min_degrees (float): Minimum elevation angle (default: 0)
elevation_max_degrees (float): Maximum elevation angle (default: 90)
tree_k (float): Tree extinction coefficient (default: 0.6)
tree_lad (float): Leaf area density in m^-1 (default: 1.0)
obj_export (bool): Whether to export as OBJ file (default: False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of SVF values at each valid observer location (x, y).</dt><dd><p>NaN values indicate invalid observer positions.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id3">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_surface_view_factor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/view.html#get_surface_view_factor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id3" title="Link to this definition">¶</a></dt>
<dd><p>Compute and optionally visualize view factors for surface meshes with respect to target voxel classes.</p>
<p>This function provides a flexible framework for computing various surface-based view factors:
- Sky View Factor: Fraction of sky hemisphere visible from building surfaces
- Tree View Factor: Fraction of directions that intersect vegetation
- Building View Factor: Fraction of directions that intersect other buildings
- Custom View Factors: User-defined target voxel classes</p>
<p>The function extracts surface meshes from the voxel data, then computes view factors
for each face using hemisphere ray casting with proper geometric transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values representing the urban environment.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters for coordinate scaling.</p></li>
<li><p><strong>**kwargs</strong> – <p>Extensive configuration options including:
# Target specification:
target_values (tuple[int]): Voxel classes to measure visibility to (default: (0,) for sky)
inclusion_mode (bool): Interpretation of target_values (default: False for sky)</p>
<p># Surface extraction:
building_class_id (int): Voxel class to extract surfaces from (default: -3 for buildings)
building_id_grid (ndarray): Optional grid mapping voxels to building IDs</p>
<p># Ray sampling:
N_azimuth (int): Number of azimuth angles for hemisphere sampling (default: 60)
N_elevation (int): Number of elevation angles for hemisphere sampling (default: 10)</p>
<p># Tree transmittance (Beer-Lambert law):
tree_k (float): Tree extinction coefficient (default: 0.6)
tree_lad (float): Leaf area density in m^-1 (default: 1.0)</p>
<p># Visualization and export:
colormap (str): Matplotlib colormap for visualization (default: ‘BuPu_r’)
vmin, vmax (float): Color scale limits (default: 0.0, 1.0)
obj_export (bool): Whether to export mesh as OBJ file (default: False)
output_directory (str): Directory for OBJ export (default: “output”)
output_file_name (str): Base filename for OBJ export (default: “surface_view_factor”)</p>
<p># Other options:
progress_report (bool): Whether to print computation progress (default: False)
debug (bool): Enable debug output (default: False)</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Surface mesh with per-face view factor values stored in metadata.</dt><dd><p>The view factor values can be accessed via mesh.metadata[value_name].
Returns None if no surfaces are found or extraction fails.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh</p>
</dd>
</dl>
<dl>
<dt>Example Usage:</dt><dd><p># Sky View Factor for building surfaces
mesh = get_surface_view_factor(voxel_data, meshsize,</p>
<blockquote>
<div><p>target_values=(0,), inclusion_mode=False)</p>
</div></blockquote>
<p># Tree View Factor for building surfaces
mesh = get_surface_view_factor(voxel_data, meshsize,</p>
<blockquote>
<div><p>target_values=(-2,), inclusion_mode=True)</p>
</div></blockquote>
<p># Custom view factor with OBJ export
mesh = get_surface_view_factor(voxel_data, meshsize,</p>
<blockquote>
<div><p>target_values=(-3,), inclusion_mode=True,
obj_export=True, output_file_name=”building_view_factor”)</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_nearest_epw_from_climate_onebuilding">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_nearest_epw_from_climate_onebuilding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">longitude</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latitude</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extract_zip</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">region</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">pandas.DataFrame</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../../_modules/voxcity/utils/weather.html#get_nearest_epw_from_climate_onebuilding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_nearest_epw_from_climate_onebuilding" title="Link to this definition">¶</a></dt>
<dd><p>Download and process EPW weather file from Climate.OneBuilding.Org based on coordinates.</p>
<p>This function automatically finds and downloads the nearest available weather station
data from Climate.OneBuilding.Org’s global database. It supports region-based searching
for improved performance and can automatically detect the appropriate region based on
coordinates.</p>
<p>The function performs the following steps:
1. Determines which regional KML files to scan based on coordinates or user input
2. Downloads and parses KML files to extract weather station metadata
3. Calculates distances to find the nearest station
4. Downloads the EPW file from the nearest station
5. Optionally processes the EPW data into a pandas DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>longitude</strong> (<em>float</em>) – Longitude of the location (-180 to 180)</p></li>
<li><p><strong>latitude</strong> (<em>float</em>) – Latitude of the location (-90 to 90)</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to save the EPW file (defaults to current directory)</p></li>
<li><p><strong>max_distance</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum distance in kilometers to search for stations.
If no stations within this distance, uses closest available.</p></li>
<li><p><strong>extract_zip</strong> (<em>bool</em>) – Whether to extract the ZIP file (default True)</p></li>
<li><p><strong>load_data</strong> (<em>bool</em>) – Whether to load the EPW data into a DataFrame (default True)</p></li>
<li><p><strong>region</strong> (<em>str</em><em> or </em><em>List</em><em>[</em><em>str</em><em>]</em><em>, </em><em>optional</em>) – Specific region(s) to scan for stations.
Options: “Africa”, “Asia”, “Japan”, “India”, “Argentina”,
“Canada”, “USA”, “Caribbean”, “Southwest_Pacific”,
“Europe”, “Antarctica”, or “all”.
If None, will auto-detect region based on coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>Path to the EPW file (or None if download fails)</p></li>
<li><p>DataFrame with hourly weather data (if load_data=True, else None)</p></li>
<li><p>Dictionary with EPW header metadata (if load_data=True, else None)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple containing</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>ValueError</strong> – If invalid region specified or no weather stations found</p></li>
<li><p><strong>requests.exceptions.RequestException</strong> – If network requests fail</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.read_epw_for_solar_simulation">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">read_epw_for_solar_simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epw_file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/utils/weather.html#read_epw_for_solar_simulation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.read_epw_for_solar_simulation" title="Link to this definition">¶</a></dt>
<dd><p>Read EPW file specifically for solar simulation purposes.</p>
<p>This function extracts essential solar radiation data and location metadata
from an EPW file for use in solar energy calculations. It focuses on the
Direct Normal Irradiance (DNI) and Diffuse Horizontal Irradiance (DHI)
which are the primary inputs for solar simulation models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>epw_file_path</strong> – Path to the EPW weather file</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>DataFrame with time-indexed DNI and DHI data</p></li>
<li><p>Longitude (degrees)</p></li>
<li><p>Latitude (degrees)</p></li>
<li><p>Time zone offset (hours from UTC)</p></li>
<li><p>Elevation (meters above sea level)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple containing</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If LOCATION line not found or data parsing fails</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id4">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">grid_to_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_array_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dem_array_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'viridis'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/exporter/obj.html#grid_to_obj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id4" title="Link to this definition">¶</a></dt>
<dd><p>Converts a 2D array of values and a corresponding DEM array to an OBJ file
with specified colormap, transparency, and value range.</p>
<p>This function creates a 3D visualization of 2D grid data by using elevation
data and color mapping. It’s particularly useful for visualizing terrain data,
analysis results, or any 2D data that should be displayed with elevation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value_array_ori</strong> (<em>ndarray</em>) – 2D array of values to visualize.
These values will be mapped to colors using the specified colormap.</p></li>
<li><p><strong>dem_array_ori</strong> (<em>ndarray</em>) – 2D array of DEM values corresponding to value_array.
Provides elevation data for the 3D visualization.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to save the OBJ and MTL files.
Will be created if it doesn’t exist.</p></li>
<li><p><strong>file_name</strong> (<em>str</em>) – Base name for the output files.
Used for both .obj and .mtl files.</p></li>
<li><p><strong>cell_size</strong> (<em>float</em>) – Size of each cell in the grid (e.g., in meters).
Used to scale the model to real-world units.</p></li>
<li><p><strong>offset</strong> (<em>float</em>) – Elevation offset added after quantization.
Useful for adjusting the base height of the model.</p></li>
<li><p><strong>colormap_name</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of the Matplotlib colormap to use.
Defaults to ‘viridis’. Must be a valid Matplotlib colormap name.</p></li>
<li><p><strong>num_colors</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of discrete colors to use from the colormap.
Defaults to 256. Higher values give smoother color transitions.</p></li>
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em>) – Transparency value between 0.0 (transparent) and 1.0 (opaque).
Defaults to 1.0 (fully opaque).</p></li>
<li><p><strong>vmin</strong> (<em>float</em><em>, </em><em>optional</em>) – Minimum value for colormap normalization.
If None, uses data minimum. Used to control color mapping range.</p></li>
<li><p><strong>vmax</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum value for colormap normalization.
If None, uses data maximum. Used to control color mapping range.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Automatically handles NaN values in input arrays</p></li>
<li><p>Creates triangulated mesh for proper rendering</p></li>
<li><p>Supports transparency and color mapping</p></li>
<li><p>Generates complete OBJ and MTL files</p></li>
<li><p>Maintains consistent coordinate system</p></li>
<li><p>Optimizes mesh generation for large grids</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If vmin equals vmax or if colormap_name is invalid</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id5">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">export_obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_color_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/exporter/obj.html#export_obj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id5" title="Link to this definition">¶</a></dt>
<dd><p>Export a voxel array to OBJ format with materials and proper face orientations.</p>
<p>This function converts a 3D voxel array into a complete OBJ file with materials,
performing mesh optimization and ensuring proper face orientations. It generates
both OBJ and MTL files with all necessary components for rendering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>ndarray</em>) – 3D numpy array containing voxel values.
Non-zero values indicate voxel presence and material type.</p></li>
<li><p><strong>output_dir</strong> (<em>str</em>) – Directory to save the OBJ and MTL files.
Will be created if it doesn’t exist.</p></li>
<li><p><strong>file_name</strong> (<em>str</em>) – Base name for the output files.
Will be used for both .obj and .mtl files.</p></li>
<li><p><strong>voxel_size</strong> (<em>float</em>) – Size of each voxel in meters.
Used to scale the model to real-world units.</p></li>
<li><p><strong>voxel_color_map</strong> (<em>dict</em><em>, </em><em>optional</em>) – Dictionary mapping voxel values to RGB colors.
If None, uses default color map. Colors should be RGB lists (0-255).</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Generates optimized mesh using greedy meshing</p></li>
<li><p>Creates complete OBJ file with vertices, normals, and faces</p></li>
<li><p>Generates MTL file with material definitions</p></li>
<li><p>Handles proper face orientation and winding order</p></li>
<li><p>Supports color mapping for visualization</p></li>
<li><p>Uses consistent coordinate system throughout</p></li>
</ul>
<dl>
<dt>File Format Details:</dt><dd><p>OBJ file contains:
- Vertex coordinates (v)
- Normal vectors (vn)
- Material references (usemtl)
- Face definitions (f)</p>
<p>MTL file contains:
- Material names and colors
- Ambient, diffuse, and specular properties
- Transparency settings
- Illumination model definitions</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_direct_solar_irradiance_map_binary">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_direct_solar_irradiance_map_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sun_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view_point_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#compute_direct_solar_irradiance_map_binary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_direct_solar_irradiance_map_binary" title="Link to this definition">¶</a></dt>
<dd><p>Compute a map of direct solar irradiation accounting for tree transmittance.</p>
<p>This function performs ray tracing from observer positions on the ground surface
towards the sun to determine direct solar irradiance at each location. It accounts
for shadows cast by buildings and vegetation, with special consideration for
tree transmittance using the Beer-Lambert law.</p>
<p>The function:
1. Places observers at valid locations (empty voxels above ground)
2. Casts rays from each observer in the sun direction
3. Computes transmittance through trees using Beer-Lambert law
4. Returns a 2D map of transmittance values</p>
<p>Observer Placement Rules:
- Observers are placed in empty voxels (value 0 or -2 for trees) above solid ground
- Observers are NOT placed on buildings, vegetation, or water surfaces
- Observer height is added above the detected ground surface</p>
<p>Ray Tracing Process:
- Rays are cast from each valid observer position toward the sun
- Intersections with obstacles (non-sky voxels) are detected
- Tree voxels provide partial transmittance rather than complete blocking
- Final transmittance value represents solar energy reaching the surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values representing the urban environment.
Common values: 0=sky, 1-6=buildings, 7-9=special surfaces, -2=trees</p></li>
<li><p><strong>sun_direction</strong> (<em>tuple</em>) – Direction vector of the sun (dx, dy, dz), should be normalized</p></li>
<li><p><strong>view_point_height</strong> (<em>float</em>) – Observer height above ground surface in meters</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Values considered non-obstacles if inclusion_mode=False
Typically (0,) meaning only sky voxels are transparent</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters (spatial resolution)</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient for Beer-Lambert law (higher = more opaque)</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1 (affects light attenuation through trees)</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – False here, meaning any voxel not in hit_values is an obstacle</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of transmittance values (0.0-1.0)</dt><dd><ul class="simple">
<li><p>1.0 = full sun exposure</p></li>
<li><p>0.0 = complete shadow</p></li>
<li><p>0.0-1.0 = partial transmittance through trees</p></li>
<li><p>NaN = invalid observer position (cannot place observer)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned map is vertically flipped to match standard visualization conventions
where the origin is at the bottom-left corner.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_direct_solar_irradiance_map">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_direct_solar_irradiance_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">azimuth_degrees_ori</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elevation_degrees</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct_normal_irradiance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_direct_solar_irradiance_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_direct_solar_irradiance_map" title="Link to this definition">¶</a></dt>
<dd><p>Compute direct solar irradiance map with tree transmittance.</p>
<p>This function converts solar angles to a 3D direction vector, computes the binary
transmittance map using ray tracing, and scales the results by actual solar irradiance
values to produce physically meaningful irradiance measurements.</p>
<p>Solar Geometry:
- Azimuth: Horizontal angle measured from North (0°) clockwise to East (90°)
- Elevation: Vertical angle above the horizon (0° = horizon, 90° = zenith)
- The coordinate system is adjusted by 180° to match the voxel grid orientation</p>
<p>Physics Background:
- Direct Normal Irradiance (DNI): Solar energy on a surface perpendicular to sun rays
- Horizontal irradiance: DNI scaled by sine of elevation angle
- Tree transmittance: Applied using Beer-Lambert law for realistic light attenuation</p>
<p>The function:
1. Converts sun angles to direction vector using spherical coordinates
2. Computes binary transmittance map accounting for shadows and tree effects
3. Scales by direct normal irradiance and sun elevation for horizontal surfaces
4. Optionally visualizes and exports results in various formats</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values representing the urban environment</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters (spatial resolution)</p></li>
<li><p><strong>azimuth_degrees_ori</strong> (<em>float</em>) – Sun azimuth angle in degrees (0° = North, 90° = East)</p></li>
<li><p><strong>elevation_degrees</strong> (<em>float</em>) – Sun elevation angle in degrees above horizon (0-90°)</p></li>
<li><p><strong>direct_normal_irradiance</strong> (<em>float</em>) – Direct normal irradiance in W/m² (from weather data)</p></li>
<li><p><strong>show_plot</strong> (<em>bool</em>) – Whether to display visualization of results</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional arguments including:
- view_point_height (float): Observer height in meters (default: 1.5)</p>
<blockquote>
<div><p>Height above ground where irradiance is measured</p>
</div></blockquote>
<ul>
<li><p>colormap (str): Matplotlib colormap name for visualization (default: ‘magma’)</p></li>
<li><p>vmin (float): Minimum value for colormap scaling</p></li>
<li><p>vmax (float): Maximum value for colormap scaling</p></li>
<li><dl class="simple">
<dt>tree_k (float): Tree extinction coefficient (default: 0.6)</dt><dd><p>Higher values mean trees block more light</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>tree_lad (float): Leaf area density in m^-1 (default: 1.0)</dt><dd><p>Affects light attenuation through tree canopies</p>
</dd>
</dl>
</li>
<li><p>obj_export (bool): Whether to export results as 3D OBJ file</p></li>
<li><p>output_directory (str): Directory for file exports</p></li>
<li><p>output_file_name (str): Base filename for exports</p></li>
<li><p>dem_grid (ndarray): Digital elevation model for 3D export</p></li>
<li><p>num_colors (int): Number of discrete colors for OBJ export</p></li>
<li><p>alpha (float): Transparency value for 3D visualization</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of direct solar irradiance values in W/m²</dt><dd><ul class="simple">
<li><p>Values represent energy flux on horizontal surfaces</p></li>
<li><p>NaN indicates invalid measurement locations</p></li>
<li><p>Range typically 0 to direct_normal_irradiance * sin(elevation)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The azimuth is internally adjusted by 180° to match the coordinate system
where the voxel grid’s y-axis points in the opposite direction from geographic north.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_diffuse_solar_irradiance_map">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_diffuse_solar_irradiance_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_irradiance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_diffuse_solar_irradiance_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_diffuse_solar_irradiance_map" title="Link to this definition">¶</a></dt>
<dd><p>Compute diffuse solar irradiance map using the Sky View Factor (SVF) with tree transmittance.</p>
<p>This function calculates the diffuse component of solar radiation, which consists of
sunlight scattered by the atmosphere and reaches surfaces from all directions across
the sky hemisphere. The calculation is based on the Sky View Factor (SVF), which
quantifies how much of the sky dome is visible from each location.</p>
<p>Physics Background:
- Diffuse radiation: Solar energy scattered by atmospheric particles and clouds
- Sky View Factor (SVF): Fraction of sky hemisphere visible from a point (0.0 to 1.0)
- Isotropic sky model: Assumes uniform diffuse radiation distribution across the sky
- Tree effects: Partial transmittance through canopies reduces effective sky visibility</p>
<p>SVF Characteristics:
- SVF = 1.0: Completely open sky (maximum diffuse radiation)
- SVF = 0.0: Completely blocked sky (no diffuse radiation)
- SVF = 0.5: Half of sky visible (typical for urban canyons)
- Trees reduce SVF through partial light attenuation rather than complete blocking</p>
<p>The function:
1. Computes SVF map accounting for building shadows and tree transmittance
2. Scales SVF by diffuse horizontal irradiance from weather data
3. Optionally visualizes and exports results for analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values representing the urban environment</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters (spatial resolution)</p></li>
<li><p><strong>diffuse_irradiance</strong> (<em>float</em>) – Diffuse horizontal irradiance in W/m² (from weather data)
Default 1.0 for normalized calculations</p></li>
<li><p><strong>show_plot</strong> (<em>bool</em>) – Whether to display visualization of results</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional arguments including:
- view_point_height (float): Observer height in meters (default: 1.5)</p>
<blockquote>
<div><p>Height above ground where measurements are taken</p>
</div></blockquote>
<ul>
<li><p>colormap (str): Matplotlib colormap name for visualization (default: ‘magma’)</p></li>
<li><p>vmin (float): Minimum value for colormap scaling</p></li>
<li><p>vmax (float): Maximum value for colormap scaling</p></li>
<li><dl class="simple">
<dt>tree_k (float): Tree extinction coefficient for transmittance calculations</dt><dd><p>Higher values mean trees block more diffuse light</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>tree_lad (float): Leaf area density in m^-1</dt><dd><p>Affects light attenuation through tree canopies</p>
</dd>
</dl>
</li>
<li><p>obj_export (bool): Whether to export results as 3D OBJ file</p></li>
<li><p>output_directory (str): Directory for file exports</p></li>
<li><p>output_file_name (str): Base filename for exports</p></li>
<li><p>dem_grid (ndarray): Digital elevation model for 3D export</p></li>
<li><p>num_colors (int): Number of discrete colors for OBJ export</p></li>
<li><p>alpha (float): Transparency value for 3D visualization</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of diffuse solar irradiance values in W/m²</dt><dd><ul class="simple">
<li><p>Values represent diffuse energy flux on horizontal surfaces</p></li>
<li><p>Range: 0.0 to diffuse_irradiance (input parameter)</p></li>
<li><p>NaN indicates invalid measurement locations</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The SVF calculation internally handles tree transmittance effects, so trees
contribute partial sky visibility rather than complete obstruction.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_global_solar_irradiance_map">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_global_solar_irradiance_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">azimuth_degrees</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elevation_degrees</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct_normal_irradiance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_irradiance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_plot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_global_solar_irradiance_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_global_solar_irradiance_map" title="Link to this definition">¶</a></dt>
<dd><p>Compute global solar irradiance (direct + diffuse) on a horizontal plane at each valid observer location.</p>
<p>This function combines both direct and diffuse components of solar radiation to calculate
the total solar irradiance at each location. Global horizontal irradiance (GHI) is the
most commonly used metric for solar energy assessment and represents the total solar
energy available on a horizontal surface.</p>
<p>Global Irradiance Components:
- Direct component: Solar radiation from the sun’s disk, affected by shadows and obstacles
- Diffuse component: Solar radiation scattered by the atmosphere, affected by sky view
- Total irradiance: Sum of direct and diffuse components at each location</p>
<p>Physical Considerations:
- Direct radiation varies with sun position and local obstructions
- Diffuse radiation varies with sky visibility (Sky View Factor)
- Both components are affected by tree transmittance using Beer-Lambert law
- Invalid locations (e.g., on water, buildings) are marked as NaN</p>
<p>The function:
1. Computes direct solar irradiance map accounting for sun position and shadows
2. Computes diffuse solar irradiance map based on Sky View Factor
3. Combines maps and optionally visualizes/exports results for analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D voxel array representing the urban environment</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Voxel size in meters (spatial resolution)</p></li>
<li><p><strong>azimuth_degrees</strong> (<em>float</em>) – Sun azimuth angle in degrees (0° = North, 90° = East)</p></li>
<li><p><strong>elevation_degrees</strong> (<em>float</em>) – Sun elevation angle in degrees above horizon (0-90°)</p></li>
<li><p><strong>direct_normal_irradiance</strong> (<em>float</em>) – Direct normal irradiance in W/m² (from weather data)</p></li>
<li><p><strong>diffuse_irradiance</strong> (<em>float</em>) – Diffuse horizontal irradiance in W/m² (from weather data)</p></li>
<li><p><strong>show_plot</strong> (<em>bool</em>) – Whether to display visualization of results</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional arguments including:
- view_point_height (float): Observer height in meters (default: 1.5)</p>
<blockquote>
<div><p>Height above ground where measurements are taken</p>
</div></blockquote>
<ul>
<li><p>colormap (str): Matplotlib colormap name for visualization (default: ‘magma’)</p></li>
<li><p>vmin (float): Minimum value for colormap scaling</p></li>
<li><p>vmax (float): Maximum value for colormap scaling</p></li>
<li><dl class="simple">
<dt>tree_k (float): Tree extinction coefficient for transmittance calculations</dt><dd><p>Higher values mean trees block more light</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>tree_lad (float): Leaf area density in m^-1</dt><dd><p>Affects light attenuation through tree canopies</p>
</dd>
</dl>
</li>
<li><p>obj_export (bool): Whether to export results as 3D OBJ file</p></li>
<li><p>output_directory (str): Directory for file exports</p></li>
<li><p>output_file_name (str): Base filename for exports</p></li>
<li><p>dem_grid (ndarray): Digital elevation model for 3D export</p></li>
<li><p>num_colors (int): Number of discrete colors for OBJ export</p></li>
<li><p>alpha (float): Transparency value for 3D visualization</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of global solar irradiance values in W/m²</dt><dd><ul class="simple">
<li><p>Values represent total solar energy flux on horizontal surfaces</p></li>
<li><p>Range: 0.0 to (direct_normal_irradiance * sin(elevation) + diffuse_irradiance)</p></li>
<li><p>NaN indicates invalid measurement locations</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Global irradiance is the standard metric used for solar energy assessment
and represents the maximum solar energy available at each location.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_solar_positions_astral">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_solar_positions_astral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_solar_positions_astral"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_solar_positions_astral" title="Link to this definition">¶</a></dt>
<dd><p>Compute solar azimuth and elevation using Astral for given times and location.</p>
<p>This function uses the Astral astronomical library to calculate precise solar positions
based on location coordinates and timestamps. The calculations account for Earth’s
orbital mechanics, axial tilt, and atmospheric refraction effects.</p>
<p>Astronomical Background:
- Solar position depends on date, time, and geographic location
- Azimuth: Horizontal angle measured clockwise from North (0°-360°)
- Elevation: Vertical angle above the horizon (-90° to +90°)
- Calculations use standard astronomical algorithms (e.g., NREL SPA)</p>
<p>Coordinate System:
- Azimuth: 0° = North, 90° = East, 180° = South, 270° = West
- Elevation: 0° = horizon, 90° = zenith, negative values = below horizon
- All angles are in degrees for consistency with weather data formats</p>
<p>The function:
1. Creates an Astral observer at the specified geographic location
2. Computes sun position for each timestamp in the input array
3. Returns DataFrame with azimuth and elevation angles for further processing</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>times</strong> (<em>DatetimeIndex</em>) – Array of timezone-aware datetime objects
Must include timezone information for accurate calculations</p></li>
<li><p><strong>lon</strong> (<em>float</em>) – Longitude in degrees (positive = East, negative = West)
Range: -180° to +180°</p></li>
<li><p><strong>lat</strong> (<em>float</em>) – Latitude in degrees (positive = North, negative = South)
Range: -90° to +90°</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>DataFrame with columns ‘azimuth’ and ‘elevation’ containing solar positions</dt><dd><ul class="simple">
<li><p>Index: Input timestamps (timezone-aware)</p></li>
<li><p>’azimuth’: Solar azimuth angles in degrees (0°-360°)</p></li>
<li><p>’elevation’: Solar elevation angles in degrees (-90° to +90°)</p></li>
<li><p>All values are float type for numerical calculations</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>DataFrame</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Input times must be timezone-aware. The function preserves the original
timezone information and performs calculations in the specified timezone.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_cumulative_global_solar_irradiance">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_cumulative_global_solar_irradiance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct_normal_irradiance_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_irradiance_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_cumulative_global_solar_irradiance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_cumulative_global_solar_irradiance" title="Link to this definition">¶</a></dt>
<dd><p>Compute cumulative global solar irradiance over a specified period using data from an EPW file.</p>
<p>This function performs time-series analysis of solar irradiance by processing weather data
over a user-defined period and accumulating irradiance values at each location. The result
represents the total solar energy received during the specified time period, which is
essential for seasonal analysis, solar panel positioning, and energy yield predictions.</p>
<p>Cumulative Analysis Concept:
- Instantaneous irradiance (W/m²): Power at a specific moment
- Cumulative irradiance (Wh/m²): Energy accumulated over time
- Integration: Sum of (irradiance × time_step) for all timesteps
- Applications: Annual energy yield, seasonal variations, optimal siting</p>
<p>Time Period Processing:
- Supports flexible time ranges (daily, seasonal, annual analysis)
- Handles timezone conversions between local and UTC time
- Filters weather data based on user-specified start/end times
- Accounts for leap years and varying daylight hours</p>
<p>Performance Optimization:
- Pre-calculates diffuse map once (scales linearly with DHI)
- Processes direct component for each timestep (varies with sun position)
- Uses efficient memory management for large time series
- Provides optional progress monitoring for long calculations</p>
<p>The function:
1. Filters EPW data for specified time period with timezone handling
2. Computes sun positions for each timestep using astronomical calculations
3. Calculates and accumulates global irradiance maps over the entire period
4. Handles tree transmittance and provides visualization/export options</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values representing the urban environment</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters (spatial resolution)</p></li>
<li><p><strong>df</strong> (<em>DataFrame</em>) – EPW weather data with columns ‘DNI’, ‘DHI’ and datetime index
Must include complete meteorological dataset</p></li>
<li><p><strong>lon</strong> (<em>float</em>) – Longitude in degrees for solar position calculations</p></li>
<li><p><strong>lat</strong> (<em>float</em>) – Latitude in degrees for solar position calculations</p></li>
<li><p><strong>tz</strong> (<em>float</em>) – Timezone offset in hours from UTC (positive = East of UTC)</p></li>
<li><p><strong>direct_normal_irradiance_scaling</strong> (<em>float</em>) – Scaling factor for direct normal irradiance
Allows sensitivity analysis or unit conversions</p></li>
<li><p><strong>diffuse_irradiance_scaling</strong> (<em>float</em>) – Scaling factor for diffuse horizontal irradiance
Allows sensitivity analysis or unit conversions</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional arguments including:
- view_point_height (float): Observer height in meters (default: 1.5)</p>
<blockquote>
<div><p>Height above ground where measurements are taken</p>
</div></blockquote>
<ul>
<li><dl class="simple">
<dt>start_time (str): Start time in format ‘MM-DD HH:MM:SS’</dt><dd><p>Defines beginning of analysis period (default: “01-01 05:00:00”)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>end_time (str): End time in format ‘MM-DD HH:MM:SS’</dt><dd><p>Defines end of analysis period (default: “01-01 20:00:00”)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>tree_k (float): Tree extinction coefficient for transmittance calculations</dt><dd><p>Higher values mean trees block more light</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>tree_lad (float): Leaf area density in m^-1</dt><dd><p>Affects light attenuation through tree canopies</p>
</dd>
</dl>
</li>
<li><p>show_plot (bool): Whether to show final accumulated results</p></li>
<li><dl class="simple">
<dt>show_each_timestep (bool): Whether to show plots for each timestep</dt><dd><p>Useful for debugging but significantly increases computation time</p>
</dd>
</dl>
</li>
<li><p>colormap (str): Matplotlib colormap name for visualization</p></li>
<li><p>vmin (float): Minimum value for colormap scaling</p></li>
<li><p>vmax (float): Maximum value for colormap scaling</p></li>
<li><p>obj_export (bool): Whether to export results as 3D OBJ file</p></li>
<li><p>output_directory (str): Directory for file exports</p></li>
<li><p>output_file_name (str): Base filename for exports</p></li>
<li><p>dem_grid (ndarray): Digital elevation model for 3D export</p></li>
<li><p>num_colors (int): Number of discrete colors for OBJ export</p></li>
<li><p>alpha (float): Transparency value for 3D visualization</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>2D array of cumulative global solar irradiance values in W/m²·hour</dt><dd><ul class="simple">
<li><p>Values represent total solar energy received during the analysis period</p></li>
<li><p>Range depends on period length and local climate conditions</p></li>
<li><p>NaN indicates invalid measurement locations (e.g., on buildings, water)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function efficiently handles large time series by pre-computing the diffuse
component once and scaling it for each timestep, significantly reducing
computation time for long-term analysis.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_global_solar_irradiance_using_epw">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_global_solar_irradiance_using_epw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'instantaneous'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct_normal_irradiance_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_irradiance_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_global_solar_irradiance_using_epw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_global_solar_irradiance_using_epw" title="Link to this definition">¶</a></dt>
<dd><p>Compute global solar irradiance using EPW weather data, either for a single time or cumulatively over a period.</p>
<p>The function:
1. Optionally downloads and reads EPW weather data
2. Handles timezone conversions and solar position calculations
3. Computes either instantaneous or cumulative irradiance maps
4. Supports visualization and export options</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters.</p></li>
<li><p><strong>calc_type</strong> (<em>str</em>) – ‘instantaneous’ or ‘cumulative’.</p></li>
<li><p><strong>direct_normal_irradiance_scaling</strong> (<em>float</em>) – Scaling factor for direct normal irradiance.</p></li>
<li><p><strong>diffuse_irradiance_scaling</strong> (<em>float</em>) – Scaling factor for diffuse horizontal irradiance.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments including:
- download_nearest_epw (bool): Whether to download nearest EPW file
- epw_file_path (str): Path to EPW file
- rectangle_vertices (list): List of (lat,lon) coordinates for EPW download
- output_dir (str): Directory for EPW download
- calc_time (str): Time for instantaneous calculation (‘MM-DD HH:MM:SS’)
- start_time (str): Start time for cumulative calculation
- end_time (str): End time for cumulative calculation
- start_hour (int): Starting hour for daily time window (0-23)
- end_hour (int): Ending hour for daily time window (0-23)
- view_point_height (float): Observer height in meters
- tree_k (float): Tree extinction coefficient
- tree_lad (float): Leaf area density in m^-1
- show_plot (bool): Whether to show visualization
- show_each_timestep (bool): Whether to show timestep plots
- colormap (str): Matplotlib colormap name
- obj_export (bool): Whether to export as OBJ file</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D array of solar irradiance values (W/m²).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.compute_solar_irradiance_for_all_faces">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">compute_solar_irradiance_for_all_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face_centers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">face_normals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">face_svf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sun_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct_normal_irradiance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_irradiance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_lad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hit_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusion_mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_bounds_real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_epsilon</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#compute_solar_irradiance_for_all_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.compute_solar_irradiance_for_all_faces" title="Link to this definition">¶</a></dt>
<dd><p>Numba-compiled function to compute direct, diffuse, and global solar irradiance
for each face in a 3D building mesh.</p>
<p>This optimized function processes all mesh faces in parallel to calculate solar
irradiance components. It handles both direct radiation (dependent on sun position
and surface orientation) and diffuse radiation (dependent on sky visibility).
The function is compiled with Numba for high-performance computation on large meshes.</p>
<p>Surface Irradiance Physics:
- Direct component: DNI × cos(incidence_angle) × transmittance
- Diffuse component: DHI × sky_view_factor
- Incidence angle: Angle between sun direction and surface normal
- Transmittance: Attenuation factor from obstacles and vegetation</p>
<p>Boundary Condition Handling:
- Vertical boundary faces are excluded (mesh edges touching domain boundaries)
- Invalid faces (NaN SVF) are skipped to maintain data consistency
- Surface orientation affects direct radiation calculation</p>
<p>Performance Optimizations:
- Numba JIT compilation for near C-speed execution
- Parallel processing of face calculations
- Efficient geometric computations using vectorized operations
- Memory-optimized array operations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>float64</strong><strong>[</strong> (<em>sun_direction</em>) – , :]): (N x 3) array of face center coordinates in real-world units</p></li>
<li><p><strong>(</strong><strong>float64</strong><strong>[</strong> – , :]): (N x 3) array of outward-pointing unit normal vectors</p></li>
<li><p><strong>(</strong><strong>float64</strong><strong>[</strong> – ]): (N,) array of Sky View Factor values for each face (0.0-1.0)</p></li>
<li><p><strong>(</strong><strong>float64</strong><strong>[</strong> – ]): (3,) array for normalized sun direction vector (dx, dy, dz)</p></li>
<li><p><strong>direct_normal_irradiance</strong> (<em>float</em>) – Direct normal irradiance (DNI) in W/m²</p></li>
<li><p><strong>diffuse_irradiance</strong> (<em>float</em>) – Diffuse horizontal irradiance (DHI) in W/m²</p></li>
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values for obstacle detection</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters (spatial resolution)</p></li>
<li><p><strong>tree_k</strong> (<em>float</em>) – Tree extinction coefficient for Beer-Lambert law</p></li>
<li><p><strong>tree_lad</strong> (<em>float</em>) – Leaf area density in m^-1</p></li>
<li><p><strong>hit_values</strong> (<em>tuple</em>) – Values considered ‘sky’ for ray tracing (e.g. (0,))</p></li>
<li><p><strong>inclusion_mode</strong> (<em>bool</em>) – Whether hit_values are included (True) or excluded (False)</p></li>
<li><p><strong>grid_bounds_real</strong> (<em>float64</em><em>[</em><em>2</em><em>,</em><em>3</em><em>]</em>) – Domain boundaries [[x_min,y_min,z_min],[x_max,y_max,z_max]]</p></li>
<li><p><strong>boundary_epsilon</strong> (<em>float</em>) – Distance threshold for boundary face detection</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Three float64[N] arrays containing:</dt><dd><ul class="simple">
<li><p>direct_irr: Direct solar irradiance for each face (W/m²)</p></li>
<li><p>diffuse_irr: Diffuse solar irradiance for each face (W/m²)</p></li>
<li><p>global_irr: Global solar irradiance for each face (W/m²)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is optimized with Numba and should not be called directly.
Use the higher-level wrapper functions for normal operation.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_building_solar_irradiance">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_building_solar_irradiance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">building_svf_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">azimuth_degrees</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elevation_degrees</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct_normal_irradiance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_irradiance</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_building_solar_irradiance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_building_solar_irradiance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate solar irradiance on building surfaces using Sky View Factor (SVF) analysis,
with high-performance computation accelerated by Numba JIT compilation.</p>
<p>This function performs detailed solar irradiance analysis on 3D building surfaces
represented as triangulated meshes. It calculates both direct and diffuse components
of solar radiation for each mesh face, accounting for surface orientation, shadows,
and sky visibility. The computation is optimized for large urban models using
efficient algorithms and parallel processing.</p>
<p>Mesh-Based Analysis Advantages:
- Surface-specific calculations for facades, roofs, and complex geometries
- Accurate accounting of surface orientation and local shading effects
- Integration with 3D visualization and CAD workflows
- Detailed irradiance data for building energy modeling</p>
<p>Performance Features:
- Numba JIT compilation for near C-speed execution
- Parallel processing of mesh faces
- Efficient ray tracing with tree transmittance
- Memory-optimized operations for large datasets</p>
<p>Physical Modeling:
- Direct irradiance: Based on sun position and surface orientation
- Diffuse irradiance: Based on Sky View Factor from each surface
- Tree effects: Partial transmittance using Beer-Lambert law
- Boundary handling: Automatic exclusion of domain boundary artifacts</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values representing the urban environment</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters (spatial resolution)</p></li>
<li><p><strong>building_svf_mesh</strong> (<em>trimesh.Trimesh</em>) – Building mesh with pre-calculated SVF values in metadata
Must have ‘svf’ array in mesh.metadata</p></li>
<li><p><strong>azimuth_degrees</strong> (<em>float</em>) – Sun azimuth angle in degrees (0=North, 90=East)</p></li>
<li><p><strong>elevation_degrees</strong> (<em>float</em>) – Sun elevation angle in degrees above horizon (0-90°)</p></li>
<li><p><strong>direct_normal_irradiance</strong> (<em>float</em>) – Direct normal irradiance (DNI) in W/m² from weather data</p></li>
<li><p><strong>diffuse_irradiance</strong> (<em>float</em>) – Diffuse horizontal irradiance (DHI) in W/m² from weather data</p></li>
<li><p><strong>**kwargs</strong> – <p>Additional parameters including:
- tree_k (float): Tree extinction coefficient (default: 0.6)</p>
<blockquote>
<div><p>Higher values mean trees block more light</p>
</div></blockquote>
<ul>
<li><dl class="simple">
<dt>tree_lad (float): Leaf area density in m^-1 (default: 1.0)</dt><dd><p>Affects light attenuation through tree canopies</p>
</dd>
</dl>
</li>
<li><p>progress_report (bool): Whether to print timing information (default: False)</p></li>
<li><p>obj_export (bool): Whether to export results as OBJ file</p></li>
<li><p>output_directory (str): Directory for file exports</p></li>
<li><p>output_file_name (str): Base filename for exports</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A copy of the input mesh with irradiance data stored in metadata:</dt><dd><ul class="simple">
<li><p>’svf’: Sky View Factor for each face (preserved from input)</p></li>
<li><p>’direct’: Direct solar irradiance for each face (W/m²)</p></li>
<li><p>’diffuse’: Diffuse solar irradiance for each face (W/m²)</p></li>
<li><p>’global’: Global solar irradiance for each face (W/m²)</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input mesh must have SVF values pre-calculated and stored in metadata.
Use get_surface_view_factor() to compute SVF before calling this function.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_cumulative_building_solar_irradiance">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_cumulative_building_solar_irradiance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">building_svf_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weather_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tz</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_cumulative_building_solar_irradiance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_cumulative_building_solar_irradiance" title="Link to this definition">¶</a></dt>
<dd><p>Calculate cumulative solar irradiance on building surfaces over a time period.
Uses the Numba-accelerated get_building_solar_irradiance for each time step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters.</p></li>
<li><p><strong>building_svf_mesh</strong> (<em>trimesh.Trimesh</em>) – Mesh with pre-calculated SVF in metadata.</p></li>
<li><p><strong>weather_df</strong> (<em>DataFrame</em>) – Weather data with DNI (W/m²) and DHI (W/m²).</p></li>
<li><p><strong>lon</strong> (<em>float</em>) – Longitude in degrees.</p></li>
<li><p><strong>lat</strong> (<em>float</em>) – Latitude in degrees.</p></li>
<li><p><strong>tz</strong> (<em>float</em>) – Timezone offset in hours.</p></li>
<li><p><strong>**kwargs</strong> – Additional parameters for time range, scaling, OBJ export, etc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A mesh with cumulative (Wh/m²) irradiance in metadata.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.get_building_global_solar_irradiance_using_epw">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">get_building_global_solar_irradiance_using_epw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meshsize</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'instantaneous'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">direct_normal_irradiance_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diffuse_irradiance_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#get_building_global_solar_irradiance_using_epw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.get_building_global_solar_irradiance_using_epw" title="Link to this definition">¶</a></dt>
<dd><p>Compute global solar irradiance on building surfaces using EPW weather data, either for a single time or cumulatively.</p>
<p>The function:
1. Optionally downloads and reads EPW weather data
2. Handles timezone conversions and solar position calculations
3. Computes either instantaneous or cumulative irradiance on building surfaces
4. Supports visualization and export options</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_data</strong> (<em>ndarray</em>) – 3D array of voxel values.</p></li>
<li><p><strong>meshsize</strong> (<em>float</em>) – Size of each voxel in meters.</p></li>
<li><p><strong>building_svf_mesh</strong> (<em>trimesh.Trimesh</em>) – Building mesh with pre-calculated SVF values in metadata.</p></li>
<li><p><strong>calc_type</strong> (<em>str</em>) – ‘instantaneous’ or ‘cumulative’.</p></li>
<li><p><strong>direct_normal_irradiance_scaling</strong> (<em>float</em>) – Scaling factor for direct normal irradiance.</p></li>
<li><p><strong>diffuse_irradiance_scaling</strong> (<em>float</em>) – Scaling factor for diffuse horizontal irradiance.</p></li>
<li><p><strong>**kwargs</strong> – Additional arguments including:
- download_nearest_epw (bool): Whether to download nearest EPW file
- epw_file_path (str): Path to EPW file
- rectangle_vertices (list): List of (lon,lat) coordinates for EPW download
- output_dir (str): Directory for EPW download
- calc_time (str): Time for instantaneous calculation (‘MM-DD HH:MM:SS’)
- period_start (str): Start time for cumulative calculation (‘MM-DD HH:MM:SS’)
- period_end (str): End time for cumulative calculation (‘MM-DD HH:MM:SS’)
- time_step_hours (float): Time step for cumulative calculation
- tree_k (float): Tree extinction coefficient
- tree_lad (float): Leaf area density in m^-1
- show_each_timestep (bool): Whether to show plots for each timestep
- nan_color (str): Color for NaN values in visualization
- colormap (str): Matplotlib colormap name
- vmin (float): Minimum value for colormap
- vmax (float): Maximum value for colormap
- obj_export (bool): Whether to export as OBJ file
- output_directory (str): Directory for OBJ export
- output_file_name (str): Filename for OBJ export
- save_mesh (bool): Whether to save the mesh data using pickle
- mesh_output_path (str): Path to save the mesh data (if save_mesh is True)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Building mesh with irradiance values stored in metadata.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.save_irradiance_mesh">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">save_irradiance_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">irradiance_mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#save_irradiance_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.save_irradiance_mesh" title="Link to this definition">¶</a></dt>
<dd><p>Save the irradiance mesh data to a file using pickle serialization.</p>
<p>This function provides persistent storage for computed irradiance results,
enabling reuse of expensive calculations and sharing of results between
analysis sessions. The mesh data includes all geometry, irradiance values,
and metadata required for visualization and further analysis.</p>
<p>Serialization Benefits:
- Preserves complete mesh structure with all computed data
- Enables offline analysis and visualization workflows
- Supports sharing results between different tools and users
- Avoids recomputation of expensive irradiance calculations</p>
<p>Data Preservation:
- All mesh geometry (vertices, faces, normals)
- Computed irradiance values (direct, diffuse, global)
- Sky View Factor data and other metadata
- Material properties and visualization settings</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>irradiance_mesh</strong> (<em>trimesh.Trimesh</em>) – Mesh with irradiance data in metadata
Should contain computed irradiance results</p></li>
<li><p><strong>output_file_path</strong> (<em>str</em>) – Path to save the mesh data file
Recommended extension: .pkl for clarity</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function automatically creates the output directory if it doesn’t exist.
Use pickle format for maximum compatibility with Python data structures.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.load_irradiance_mesh">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">load_irradiance_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_file_path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/solar.html#load_irradiance_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.load_irradiance_mesh" title="Link to this definition">¶</a></dt>
<dd><p>Load previously saved irradiance mesh data from a file.</p>
<p>This function restores complete mesh data including geometry, computed
irradiance values, and all associated metadata. It enables continuation
of analysis workflows and reuse of expensive computation results.</p>
<p>Restoration Capabilities:
- Complete mesh geometry with all topological information
- All computed irradiance data (direct, diffuse, global components)
- Sky View Factor values and analysis metadata
- Visualization settings and material properties</p>
<p>Workflow Integration:
- Load results from previous analysis sessions
- Share computed data between team members
- Perform post-processing and visualization
- Compare results from different scenarios</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_file_path</strong> (<em>str</em>) – Path to the saved mesh data file
Should be a file created by save_irradiance_mesh()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Complete mesh with all irradiance data in metadata</dt><dd><p>Ready for visualization, analysis, or further processing</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>trimesh.Trimesh</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The loaded mesh maintains all original data structure and can be used
immediately for visualization or additional analysis operations.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="voxcity.simulator.dummy_function">
<span class="sig-prename descclassname"><span class="pre">voxcity.simulator.</span></span><span class="sig-name descname"><span class="pre">dummy_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_string</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/voxcity/simulator/utils.html#dummy_function"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#voxcity.simulator.dummy_function" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="solar/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">voxcity.simulator.solar</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../geoprocessor/polygon/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">voxcity.geoprocessor.polygon</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Kunihiko Fujiwara
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">voxcity.simulator</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#package-contents">Package Contents</a><ul>
<li><a class="reference internal" href="#voxcity.simulator.find_building_containing_point"><code class="docutils literal notranslate"><span class="pre">find_building_containing_point()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_buildings_in_drawn_polygon"><code class="docutils literal notranslate"><span class="pre">get_buildings_in_drawn_polygon()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.create_voxel_mesh"><code class="docutils literal notranslate"><span class="pre">create_voxel_mesh()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.grid_to_obj"><code class="docutils literal notranslate"><span class="pre">grid_to_obj()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.export_obj"><code class="docutils literal notranslate"><span class="pre">export_obj()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.calculate_transmittance"><code class="docutils literal notranslate"><span class="pre">calculate_transmittance()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.trace_ray_generic"><code class="docutils literal notranslate"><span class="pre">trace_ray_generic()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_vi_generic"><code class="docutils literal notranslate"><span class="pre">compute_vi_generic()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_vi_map_generic"><code class="docutils literal notranslate"><span class="pre">compute_vi_map_generic()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_view_index"><code class="docutils literal notranslate"><span class="pre">get_view_index()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.mark_building_by_id"><code class="docutils literal notranslate"><span class="pre">mark_building_by_id()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.trace_ray_to_target"><code class="docutils literal notranslate"><span class="pre">trace_ray_to_target()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_visibility_to_all_landmarks"><code class="docutils literal notranslate"><span class="pre">compute_visibility_to_all_landmarks()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_visibility_map"><code class="docutils literal notranslate"><span class="pre">compute_visibility_map()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_landmark_visibility"><code class="docutils literal notranslate"><span class="pre">compute_landmark_visibility()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_landmark_visibility_map"><code class="docutils literal notranslate"><span class="pre">get_landmark_visibility_map()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_sky_view_factor_map"><code class="docutils literal notranslate"><span class="pre">get_sky_view_factor_map()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.rotate_vector_axis_angle"><code class="docutils literal notranslate"><span class="pre">rotate_vector_axis_angle()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_view_factor_for_all_faces"><code class="docutils literal notranslate"><span class="pre">compute_view_factor_for_all_faces()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_surface_view_factor"><code class="docutils literal notranslate"><span class="pre">get_surface_view_factor()</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">trace_ray_generic()</span></code></a></li>
<li><a class="reference internal" href="#id1"><code class="docutils literal notranslate"><span class="pre">compute_vi_map_generic()</span></code></a></li>
<li><a class="reference internal" href="#id2"><code class="docutils literal notranslate"><span class="pre">get_sky_view_factor_map()</span></code></a></li>
<li><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">get_surface_view_factor()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_nearest_epw_from_climate_onebuilding"><code class="docutils literal notranslate"><span class="pre">get_nearest_epw_from_climate_onebuilding()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.read_epw_for_solar_simulation"><code class="docutils literal notranslate"><span class="pre">read_epw_for_solar_simulation()</span></code></a></li>
<li><a class="reference internal" href="#id4"><code class="docutils literal notranslate"><span class="pre">grid_to_obj()</span></code></a></li>
<li><a class="reference internal" href="#id5"><code class="docutils literal notranslate"><span class="pre">export_obj()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_direct_solar_irradiance_map_binary"><code class="docutils literal notranslate"><span class="pre">compute_direct_solar_irradiance_map_binary()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_direct_solar_irradiance_map"><code class="docutils literal notranslate"><span class="pre">get_direct_solar_irradiance_map()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_diffuse_solar_irradiance_map"><code class="docutils literal notranslate"><span class="pre">get_diffuse_solar_irradiance_map()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_global_solar_irradiance_map"><code class="docutils literal notranslate"><span class="pre">get_global_solar_irradiance_map()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_solar_positions_astral"><code class="docutils literal notranslate"><span class="pre">get_solar_positions_astral()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_cumulative_global_solar_irradiance"><code class="docutils literal notranslate"><span class="pre">get_cumulative_global_solar_irradiance()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_global_solar_irradiance_using_epw"><code class="docutils literal notranslate"><span class="pre">get_global_solar_irradiance_using_epw()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.compute_solar_irradiance_for_all_faces"><code class="docutils literal notranslate"><span class="pre">compute_solar_irradiance_for_all_faces()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_building_solar_irradiance"><code class="docutils literal notranslate"><span class="pre">get_building_solar_irradiance()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_cumulative_building_solar_irradiance"><code class="docutils literal notranslate"><span class="pre">get_cumulative_building_solar_irradiance()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.get_building_global_solar_irradiance_using_epw"><code class="docutils literal notranslate"><span class="pre">get_building_global_solar_irradiance_using_epw()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.save_irradiance_mesh"><code class="docutils literal notranslate"><span class="pre">save_irradiance_mesh()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.load_irradiance_mesh"><code class="docutils literal notranslate"><span class="pre">load_irradiance_mesh()</span></code></a></li>
<li><a class="reference internal" href="#voxcity.simulator.dummy_function"><code class="docutils literal notranslate"><span class="pre">dummy_function()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=8a448e45"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>
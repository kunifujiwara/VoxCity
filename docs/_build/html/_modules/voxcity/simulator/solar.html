<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <link rel="shortcut icon" href="../../../_static/favicon.ico"/><!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>voxcity.simulator.solar - VoxCity Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=7edd21af" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">VoxCity Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../../_static/logo.png" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../../_static/logo.png" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">VoxCity Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html"><strong>VoxCity Demo</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step1-prepare-environment">Step1. Prepare environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step2-set-target-area-by-a-rectangle">Step2. Set target area by a rectangle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step3-set-variables">Step3 Set variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step4-get-voxcity-output">Step4 Get voxcity output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step5-export-files">Step5 Export files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#step6-urban-simulations">Step6 Urban simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#solar-radiation">6.1. Solar radiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../example.html#landmark-visibility">6.3. Landmark visibility</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../autoapi/voxcity/index.html">voxcity</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of voxcity</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/voxcity/downloader/index.html">voxcity.downloader</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of voxcity.downloader</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/downloader/citygml/index.html">voxcity.downloader.citygml</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/downloader/eubucco/index.html">voxcity.downloader.eubucco</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/downloader/gee/index.html">voxcity.downloader.gee</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/downloader/mbfp/index.html">voxcity.downloader.mbfp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/downloader/oemj/index.html">voxcity.downloader.oemj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/downloader/osm/index.html">voxcity.downloader.osm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/downloader/overture/index.html">voxcity.downloader.overture</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/voxcity/exporter/index.html">voxcity.exporter</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of voxcity.exporter</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/exporter/envimet/index.html">voxcity.exporter.envimet</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/exporter/magicavoxel/index.html">voxcity.exporter.magicavoxel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/exporter/obj/index.html">voxcity.exporter.obj</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/voxcity/generator/index.html">voxcity.generator</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/voxcity/geoprocessor/index.html">voxcity.geoprocessor</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of voxcity.geoprocessor</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/geoprocessor/draw/index.html">voxcity.geoprocessor.draw</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/geoprocessor/grid/index.html">voxcity.geoprocessor.grid</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/geoprocessor/mesh/index.html">voxcity.geoprocessor.mesh</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/geoprocessor/network/index.html">voxcity.geoprocessor.network</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/geoprocessor/polygon/index.html">voxcity.geoprocessor.polygon</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/voxcity/simulator/index.html">voxcity.simulator</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of voxcity.simulator</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/simulator/solar/index.html">voxcity.simulator.solar</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/voxcity/simulator/view/index.html">voxcity.simulator.view</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial:</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../examples/index.html">Use cases of VoxCity</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Use cases of VoxCity</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html"><strong>VoxCity Demo</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step1-prepare-environment">Step1. Prepare environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step2-set-target-area-by-a-rectangle">Step2. Set target area by a rectangle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step3-set-variables">Step3 Set variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step4-get-voxcity-output">Step4 Get voxcity output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step5-export-files">Step5 Export files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#step6-urban-simulations">Step6 Urban simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#solar-radiation">6.1. Solar radiation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/demo_basic.html#landmark-visibility">6.3. Landmark visibility</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Information:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">=======
History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">============
Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../conduct.html">====================================
Contributor Covenant Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for voxcity.simulator.solar</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Solar Irradiance Simulation Module</span>

<span class="sd">This module provides comprehensive solar irradiance calculations for urban environments,</span>
<span class="sd">including direct and diffuse solar radiation analysis with consideration for tree transmittance</span>
<span class="sd">and building shadows. It supports both instantaneous and cumulative irradiance calculations</span>
<span class="sd">using weather data from EPW files.</span>

<span class="sd">Key Features:</span>
<span class="sd">- Direct solar irradiance with ray tracing and shadow analysis</span>
<span class="sd">- Diffuse solar irradiance using Sky View Factor (SVF)</span>
<span class="sd">- Tree transmittance modeling using Beer-Lambert law</span>
<span class="sd">- Building surface irradiance calculation with 3D mesh support</span>
<span class="sd">- Weather data integration from EPW files</span>
<span class="sd">- Visualization and export capabilities</span>

<span class="sd">The module uses numba for performance optimization in computationally intensive calculations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytz</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astral</span><span class="w"> </span><span class="kn">import</span> <span class="n">Observer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astral.sun</span><span class="w"> </span><span class="kn">import</span> <span class="n">elevation</span><span class="p">,</span> <span class="n">azimuth</span>

<span class="c1"># Import custom modules for view analysis and weather data processing</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.view</span><span class="w"> </span><span class="kn">import</span> <span class="n">trace_ray_generic</span><span class="p">,</span> <span class="n">compute_vi_map_generic</span><span class="p">,</span> <span class="n">get_sky_view_factor_map</span><span class="p">,</span> <span class="n">get_surface_view_factor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..utils.weather</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_nearest_epw_from_climate_onebuilding</span><span class="p">,</span> <span class="n">read_epw_for_solar_simulation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..exporter.obj</span><span class="w"> </span><span class="kn">import</span> <span class="n">grid_to_obj</span><span class="p">,</span> <span class="n">export_obj</span>

<div class="viewcode-block" id="compute_direct_solar_irradiance_map_binary">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.compute_direct_solar_irradiance_map_binary">[docs]</a>
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_direct_solar_irradiance_map_binary</span><span class="p">(</span><span class="n">voxel_data</span><span class="p">,</span> <span class="n">sun_direction</span><span class="p">,</span> <span class="n">view_point_height</span><span class="p">,</span> <span class="n">hit_values</span><span class="p">,</span> <span class="n">meshsize</span><span class="p">,</span> <span class="n">tree_k</span><span class="p">,</span> <span class="n">tree_lad</span><span class="p">,</span> <span class="n">inclusion_mode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a map of direct solar irradiation accounting for tree transmittance.</span>

<span class="sd">    This function performs ray tracing from observer positions on the ground surface</span>
<span class="sd">    towards the sun to determine direct solar irradiance at each location. It accounts</span>
<span class="sd">    for shadows cast by buildings and vegetation, with special consideration for</span>
<span class="sd">    tree transmittance using the Beer-Lambert law.</span>

<span class="sd">    The function:</span>
<span class="sd">    1. Places observers at valid locations (empty voxels above ground)</span>
<span class="sd">    2. Casts rays from each observer in the sun direction</span>
<span class="sd">    3. Computes transmittance through trees using Beer-Lambert law</span>
<span class="sd">    4. Returns a 2D map of transmittance values</span>

<span class="sd">    Observer Placement Rules:</span>
<span class="sd">    - Observers are placed in empty voxels (value 0 or -2 for trees) above solid ground</span>
<span class="sd">    - Observers are NOT placed on buildings, vegetation, or water surfaces</span>
<span class="sd">    - Observer height is added above the detected ground surface</span>

<span class="sd">    Ray Tracing Process:</span>
<span class="sd">    - Rays are cast from each valid observer position toward the sun</span>
<span class="sd">    - Intersections with obstacles (non-sky voxels) are detected</span>
<span class="sd">    - Tree voxels provide partial transmittance rather than complete blocking</span>
<span class="sd">    - Final transmittance value represents solar energy reaching the surface</span>

<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values representing the urban environment.</span>
<span class="sd">                             Common values: 0=sky, 1-6=buildings, 7-9=special surfaces, -2=trees</span>
<span class="sd">        sun_direction (tuple): Direction vector of the sun (dx, dy, dz), should be normalized</span>
<span class="sd">        view_point_height (float): Observer height above ground surface in meters</span>
<span class="sd">        hit_values (tuple): Values considered non-obstacles if inclusion_mode=False</span>
<span class="sd">                           Typically (0,) meaning only sky voxels are transparent</span>
<span class="sd">        meshsize (float): Size of each voxel in meters (spatial resolution)</span>
<span class="sd">        tree_k (float): Tree extinction coefficient for Beer-Lambert law (higher = more opaque)</span>
<span class="sd">        tree_lad (float): Leaf area density in m^-1 (affects light attenuation through trees)</span>
<span class="sd">        inclusion_mode (bool): False here, meaning any voxel not in hit_values is an obstacle</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: 2D array of transmittance values (0.0-1.0)</span>
<span class="sd">                - 1.0 = full sun exposure</span>
<span class="sd">                - 0.0 = complete shadow</span>
<span class="sd">                - 0.0-1.0 = partial transmittance through trees</span>
<span class="sd">                - NaN = invalid observer position (cannot place observer)</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The returned map is vertically flipped to match standard visualization conventions</span>
<span class="sd">        where the origin is at the bottom-left corner.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Convert observer height from meters to voxel units</span>
    <span class="n">view_height_voxel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">view_point_height</span> <span class="o">/</span> <span class="n">meshsize</span><span class="p">)</span>
    
    <span class="c1"># Get dimensions of the voxel grid</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">voxel_data</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="c1"># Initialize irradiance map with NaN (invalid positions)</span>
    <span class="n">irradiance_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Normalize sun direction vector for consistent ray tracing</span>
    <span class="c1"># This ensures rays travel at unit speed through the voxel grid</span>
    <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sun_direction</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">sd_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sd_len</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">irradiance_map</span><span class="p">)</span>
    <span class="n">sd</span> <span class="o">/=</span> <span class="n">sd_len</span>

    <span class="c1"># Process each x,y position in parallel for performance</span>
    <span class="c1"># This is the main computational loop optimized with numba</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="n">found_observer</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="c1"># Search upward through the vertical column to find valid observer position</span>
            <span class="c1"># Start from z=1 to ensure we can check the voxel below</span>
            <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nz</span><span class="p">):</span>
                
                <span class="c1"># Check if current voxel is empty/tree and voxel below is solid</span>
                <span class="c1"># This identifies the ground surface where observers can be placed</span>
                <span class="k">if</span> <span class="n">voxel_data</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">voxel_data</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                    
                    <span class="c1"># Skip if standing on building/vegetation/water surfaces</span>
                    <span class="c1"># These are considered invalid observer locations</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">voxel_data</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">voxel_data</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">irradiance_map</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="n">found_observer</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Place observer at valid ground location and cast ray toward sun</span>
                        <span class="n">observer_location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">view_height_voxel</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                        
                        <span class="c1"># Trace ray from observer to sun, accounting for obstacles and tree transmittance</span>
                        <span class="n">hit</span><span class="p">,</span> <span class="n">transmittance</span> <span class="o">=</span> <span class="n">trace_ray_generic</span><span class="p">(</span><span class="n">voxel_data</span><span class="p">,</span> <span class="n">observer_location</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> 
                                                             <span class="n">hit_values</span><span class="p">,</span> <span class="n">meshsize</span><span class="p">,</span> <span class="n">tree_k</span><span class="p">,</span> <span class="n">tree_lad</span><span class="p">,</span> <span class="n">inclusion_mode</span><span class="p">)</span>
                        
                        <span class="c1"># Store transmittance value (0 if hit solid obstacle, 0-1 if through trees)</span>
                        <span class="n">irradiance_map</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">transmittance</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span> <span class="k">else</span> <span class="mf">0.0</span>
                        <span class="n">found_observer</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
            
            <span class="c1"># If no valid observer position found in this column, mark as invalid</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found_observer</span><span class="p">:</span>
                <span class="n">irradiance_map</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Flip map vertically to match visualization conventions (origin at bottom-left)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">irradiance_map</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_direct_solar_irradiance_map">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_direct_solar_irradiance_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_direct_solar_irradiance_map</span><span class="p">(</span><span class="n">voxel_data</span><span class="p">,</span> <span class="n">meshsize</span><span class="p">,</span> <span class="n">azimuth_degrees_ori</span><span class="p">,</span> <span class="n">elevation_degrees</span><span class="p">,</span> 
                                  <span class="n">direct_normal_irradiance</span><span class="p">,</span> <span class="n">show_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute direct solar irradiance map with tree transmittance.</span>
<span class="sd">    </span>
<span class="sd">    This function converts solar angles to a 3D direction vector, computes the binary</span>
<span class="sd">    transmittance map using ray tracing, and scales the results by actual solar irradiance</span>
<span class="sd">    values to produce physically meaningful irradiance measurements.</span>
<span class="sd">    </span>
<span class="sd">    Solar Geometry:</span>
<span class="sd">    - Azimuth: Horizontal angle measured from North (0°) clockwise to East (90°)</span>
<span class="sd">    - Elevation: Vertical angle above the horizon (0° = horizon, 90° = zenith)</span>
<span class="sd">    - The coordinate system is adjusted by 180° to match the voxel grid orientation</span>
<span class="sd">    </span>
<span class="sd">    Physics Background:</span>
<span class="sd">    - Direct Normal Irradiance (DNI): Solar energy on a surface perpendicular to sun rays</span>
<span class="sd">    - Horizontal irradiance: DNI scaled by sine of elevation angle</span>
<span class="sd">    - Tree transmittance: Applied using Beer-Lambert law for realistic light attenuation</span>
<span class="sd">    </span>
<span class="sd">    The function:</span>
<span class="sd">    1. Converts sun angles to direction vector using spherical coordinates</span>
<span class="sd">    2. Computes binary transmittance map accounting for shadows and tree effects</span>
<span class="sd">    3. Scales by direct normal irradiance and sun elevation for horizontal surfaces</span>
<span class="sd">    4. Optionally visualizes and exports results in various formats</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values representing the urban environment</span>
<span class="sd">        meshsize (float): Size of each voxel in meters (spatial resolution)</span>
<span class="sd">        azimuth_degrees_ori (float): Sun azimuth angle in degrees (0° = North, 90° = East)</span>
<span class="sd">        elevation_degrees (float): Sun elevation angle in degrees above horizon (0-90°)</span>
<span class="sd">        direct_normal_irradiance (float): Direct normal irradiance in W/m² (from weather data)</span>
<span class="sd">        show_plot (bool): Whether to display visualization of results</span>
<span class="sd">        **kwargs: Additional arguments including:</span>
<span class="sd">            - view_point_height (float): Observer height in meters (default: 1.5)</span>
<span class="sd">                Height above ground where irradiance is measured</span>
<span class="sd">            - colormap (str): Matplotlib colormap name for visualization (default: &#39;magma&#39;)</span>
<span class="sd">            - vmin (float): Minimum value for colormap scaling</span>
<span class="sd">            - vmax (float): Maximum value for colormap scaling  </span>
<span class="sd">            - tree_k (float): Tree extinction coefficient (default: 0.6)</span>
<span class="sd">                Higher values mean trees block more light</span>
<span class="sd">            - tree_lad (float): Leaf area density in m^-1 (default: 1.0)</span>
<span class="sd">                Affects light attenuation through tree canopies</span>
<span class="sd">            - obj_export (bool): Whether to export results as 3D OBJ file</span>
<span class="sd">            - output_directory (str): Directory for file exports</span>
<span class="sd">            - output_file_name (str): Base filename for exports</span>
<span class="sd">            - dem_grid (ndarray): Digital elevation model for 3D export</span>
<span class="sd">            - num_colors (int): Number of discrete colors for OBJ export</span>
<span class="sd">            - alpha (float): Transparency value for 3D visualization</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: 2D array of direct solar irradiance values in W/m²</span>
<span class="sd">                - Values represent energy flux on horizontal surfaces</span>
<span class="sd">                - NaN indicates invalid measurement locations</span>
<span class="sd">                - Range typically 0 to direct_normal_irradiance * sin(elevation)</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The azimuth is internally adjusted by 180° to match the coordinate system</span>
<span class="sd">        where the voxel grid&#39;s y-axis points in the opposite direction from geographic north.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract parameters with defaults for observer and visualization settings</span>
    <span class="n">view_point_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;view_point_height&quot;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="n">direct_normal_irradiance</span><span class="p">)</span>
    
    <span class="c1"># Get tree transmittance parameters for Beer-Lambert law calculations</span>
    <span class="n">tree_k</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tree_k&quot;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
    <span class="n">tree_lad</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tree_lad&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># Convert sun angles to 3D direction vector using spherical coordinates</span>
    <span class="c1"># Note: azimuth is adjusted by 180° to match coordinate system orientation</span>
    <span class="n">azimuth_degrees</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">-</span> <span class="n">azimuth_degrees_ori</span>
    <span class="n">azimuth_radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">azimuth_degrees</span><span class="p">)</span>
    <span class="n">elevation_radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">elevation_degrees</span><span class="p">)</span>
    
    <span class="c1"># Calculate direction vector components</span>
    <span class="c1"># dx, dy: horizontal components, dz: vertical component (upward positive)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">elevation_radians</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">azimuth_radians</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">elevation_radians</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">azimuth_radians</span><span class="p">)</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">elevation_radians</span><span class="p">)</span>
    <span class="n">sun_direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span>

    <span class="c1"># Define obstacle detection parameters for ray tracing</span>
    <span class="c1"># All non-zero voxels are obstacles except for trees which have transmittance</span>
    <span class="n">hit_values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>    <span class="c1"># Only sky voxels (value 0) are transparent</span>
    <span class="n">inclusion_mode</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Values NOT in hit_values are considered obstacles</span>

    <span class="c1"># Compute transmittance map using optimized ray tracing</span>
    <span class="n">transmittance_map</span> <span class="o">=</span> <span class="n">compute_direct_solar_irradiance_map_binary</span><span class="p">(</span>
        <span class="n">voxel_data</span><span class="p">,</span> <span class="n">sun_direction</span><span class="p">,</span> <span class="n">view_point_height</span><span class="p">,</span> <span class="n">hit_values</span><span class="p">,</span> 
        <span class="n">meshsize</span><span class="p">,</span> <span class="n">tree_k</span><span class="p">,</span> <span class="n">tree_lad</span><span class="p">,</span> <span class="n">inclusion_mode</span>
    <span class="p">)</span>

    <span class="c1"># Scale transmittance by solar irradiance and geometry</span>
    <span class="c1"># For horizontal surfaces: multiply by sine of elevation angle</span>
    <span class="n">sin_elev</span> <span class="o">=</span> <span class="n">dz</span>
    <span class="n">direct_map</span> <span class="o">=</span> <span class="n">transmittance_map</span> <span class="o">*</span> <span class="n">direct_normal_irradiance</span> <span class="o">*</span> <span class="n">sin_elev</span>

    <span class="c1"># Optional visualization of results</span>
    <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
        <span class="c1"># Set up colormap with special handling for invalid data</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightgray&#39;</span><span class="p">)</span>  <span class="c1"># NaN values shown in gray</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="c1"># plt.title(&quot;Horizontal Direct Solar Irradiance Map (0° = North)&quot;)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">direct_map</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Direct Solar Irradiance (W/m²)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Optional export to 3D OBJ format for external visualization</span>
    <span class="n">obj_export</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj_export&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">obj_export</span><span class="p">:</span>
        <span class="c1"># Get export parameters with defaults</span>
        <span class="n">dem_grid</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dem_grid&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">direct_map</span><span class="p">))</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_directory&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">)</span>
        <span class="n">output_file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_file_name&quot;</span><span class="p">,</span> <span class="s2">&quot;direct_solar_irradiance&quot;</span><span class="p">)</span>
        <span class="n">num_colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_colors&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        
        <span class="c1"># Export as colored 3D mesh</span>
        <span class="n">grid_to_obj</span><span class="p">(</span>
            <span class="n">direct_map</span><span class="p">,</span>
            <span class="n">dem_grid</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="p">,</span>
            <span class="n">output_file_name</span><span class="p">,</span>
            <span class="n">meshsize</span><span class="p">,</span>
            <span class="n">view_point_height</span><span class="p">,</span>
            <span class="n">colormap_name</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span>
            <span class="n">num_colors</span><span class="o">=</span><span class="n">num_colors</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">direct_map</span></div>


<div class="viewcode-block" id="get_diffuse_solar_irradiance_map">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_diffuse_solar_irradiance_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_diffuse_solar_irradiance_map</span><span class="p">(</span><span class="n">voxel_data</span><span class="p">,</span> <span class="n">meshsize</span><span class="p">,</span> <span class="n">diffuse_irradiance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">show_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute diffuse solar irradiance map using the Sky View Factor (SVF) with tree transmittance.</span>

<span class="sd">    This function calculates the diffuse component of solar radiation, which consists of</span>
<span class="sd">    sunlight scattered by the atmosphere and reaches surfaces from all directions across</span>
<span class="sd">    the sky hemisphere. The calculation is based on the Sky View Factor (SVF), which</span>
<span class="sd">    quantifies how much of the sky dome is visible from each location.</span>
<span class="sd">    </span>
<span class="sd">    Physics Background:</span>
<span class="sd">    - Diffuse radiation: Solar energy scattered by atmospheric particles and clouds</span>
<span class="sd">    - Sky View Factor (SVF): Fraction of sky hemisphere visible from a point (0.0 to 1.0)</span>
<span class="sd">    - Isotropic sky model: Assumes uniform diffuse radiation distribution across the sky</span>
<span class="sd">    - Tree effects: Partial transmittance through canopies reduces effective sky visibility</span>
<span class="sd">    </span>
<span class="sd">    SVF Characteristics:</span>
<span class="sd">    - SVF = 1.0: Completely open sky (maximum diffuse radiation)</span>
<span class="sd">    - SVF = 0.0: Completely blocked sky (no diffuse radiation)  </span>
<span class="sd">    - SVF = 0.5: Half of sky visible (typical for urban canyons)</span>
<span class="sd">    - Trees reduce SVF through partial light attenuation rather than complete blocking</span>

<span class="sd">    The function:</span>
<span class="sd">    1. Computes SVF map accounting for building shadows and tree transmittance</span>
<span class="sd">    2. Scales SVF by diffuse horizontal irradiance from weather data</span>
<span class="sd">    3. Optionally visualizes and exports results for analysis</span>

<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values representing the urban environment</span>
<span class="sd">        meshsize (float): Size of each voxel in meters (spatial resolution)</span>
<span class="sd">        diffuse_irradiance (float): Diffuse horizontal irradiance in W/m² (from weather data)</span>
<span class="sd">                                  Default 1.0 for normalized calculations</span>
<span class="sd">        show_plot (bool): Whether to display visualization of results</span>
<span class="sd">        **kwargs: Additional arguments including:</span>
<span class="sd">            - view_point_height (float): Observer height in meters (default: 1.5)</span>
<span class="sd">                Height above ground where measurements are taken</span>
<span class="sd">            - colormap (str): Matplotlib colormap name for visualization (default: &#39;magma&#39;)</span>
<span class="sd">            - vmin (float): Minimum value for colormap scaling</span>
<span class="sd">            - vmax (float): Maximum value for colormap scaling</span>
<span class="sd">            - tree_k (float): Tree extinction coefficient for transmittance calculations</span>
<span class="sd">                Higher values mean trees block more diffuse light</span>
<span class="sd">            - tree_lad (float): Leaf area density in m^-1</span>
<span class="sd">                Affects light attenuation through tree canopies</span>
<span class="sd">            - obj_export (bool): Whether to export results as 3D OBJ file</span>
<span class="sd">            - output_directory (str): Directory for file exports</span>
<span class="sd">            - output_file_name (str): Base filename for exports</span>
<span class="sd">            - dem_grid (ndarray): Digital elevation model for 3D export</span>
<span class="sd">            - num_colors (int): Number of discrete colors for OBJ export  </span>
<span class="sd">            - alpha (float): Transparency value for 3D visualization</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: 2D array of diffuse solar irradiance values in W/m²</span>
<span class="sd">                - Values represent diffuse energy flux on horizontal surfaces</span>
<span class="sd">                - Range: 0.0 to diffuse_irradiance (input parameter)</span>
<span class="sd">                - NaN indicates invalid measurement locations</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The SVF calculation internally handles tree transmittance effects, so trees</span>
<span class="sd">        contribute partial sky visibility rather than complete obstruction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Extract parameters with defaults for observer and visualization settings</span>
    <span class="n">view_point_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;view_point_height&quot;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="n">diffuse_irradiance</span><span class="p">)</span>
    
    <span class="c1"># Prepare parameters for SVF calculation with appropriate visualization settings</span>
    <span class="c1"># Pass tree transmittance parameters to SVF calculation</span>
    <span class="n">svf_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">svf_kwargs</span><span class="p">[</span><span class="s2">&quot;colormap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;BuPu_r&quot;</span>  <span class="c1"># Purple colormap for SVF visualization</span>
    <span class="n">svf_kwargs</span><span class="p">[</span><span class="s2">&quot;vmin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>             <span class="c1"># SVF ranges from 0 to 1</span>
    <span class="n">svf_kwargs</span><span class="p">[</span><span class="s2">&quot;vmax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Calculate Sky View Factor map accounting for all obstructions</span>
    <span class="c1"># SVF calculation now handles tree transmittance internally</span>
    <span class="n">SVF_map</span> <span class="o">=</span> <span class="n">get_sky_view_factor_map</span><span class="p">(</span><span class="n">voxel_data</span><span class="p">,</span> <span class="n">meshsize</span><span class="p">,</span> <span class="o">**</span><span class="n">svf_kwargs</span><span class="p">)</span>
    
    <span class="c1"># Convert SVF to diffuse irradiance by scaling with weather data</span>
    <span class="c1"># Each location receives diffuse radiation proportional to its sky visibility</span>
    <span class="n">diffuse_map</span> <span class="o">=</span> <span class="n">SVF_map</span> <span class="o">*</span> <span class="n">diffuse_irradiance</span>

    <span class="c1"># Optional visualization of diffuse irradiance results</span>
    <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
        <span class="c1"># Use parameters from kwargs for consistent visualization</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="n">diffuse_irradiance</span><span class="p">)</span>
        
        <span class="c1"># Set up colormap with special handling for invalid data</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightgray&#39;</span><span class="p">)</span>  <span class="c1"># NaN values shown in gray</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="c1"># plt.title(&quot;Diffuse Solar Irradiance Map&quot;)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">diffuse_map</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Diffuse Solar Irradiance (W/m²)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Optional export to 3D OBJ format for external visualization</span>
    <span class="n">obj_export</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj_export&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">obj_export</span><span class="p">:</span>
        <span class="c1"># Get export parameters with defaults</span>
        <span class="n">dem_grid</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dem_grid&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">diffuse_map</span><span class="p">))</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_directory&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">)</span>
        <span class="n">output_file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_file_name&quot;</span><span class="p">,</span> <span class="s2">&quot;diffuse_solar_irradiance&quot;</span><span class="p">)</span>
        <span class="n">num_colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_colors&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        
        <span class="c1"># Export as colored 3D mesh</span>
        <span class="n">grid_to_obj</span><span class="p">(</span>
            <span class="n">diffuse_map</span><span class="p">,</span>
            <span class="n">dem_grid</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="p">,</span>
            <span class="n">output_file_name</span><span class="p">,</span>
            <span class="n">meshsize</span><span class="p">,</span>
            <span class="n">view_point_height</span><span class="p">,</span>
            <span class="n">colormap_name</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span>
            <span class="n">num_colors</span><span class="o">=</span><span class="n">num_colors</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">diffuse_map</span></div>



<div class="viewcode-block" id="get_global_solar_irradiance_map">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_global_solar_irradiance_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_global_solar_irradiance_map</span><span class="p">(</span>
    <span class="n">voxel_data</span><span class="p">,</span>
    <span class="n">meshsize</span><span class="p">,</span>
    <span class="n">azimuth_degrees</span><span class="p">,</span>
    <span class="n">elevation_degrees</span><span class="p">,</span>
    <span class="n">direct_normal_irradiance</span><span class="p">,</span>
    <span class="n">diffuse_irradiance</span><span class="p">,</span>
    <span class="n">show_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute global solar irradiance (direct + diffuse) on a horizontal plane at each valid observer location.</span>

<span class="sd">    This function combines both direct and diffuse components of solar radiation to calculate</span>
<span class="sd">    the total solar irradiance at each location. Global horizontal irradiance (GHI) is the</span>
<span class="sd">    most commonly used metric for solar energy assessment and represents the total solar</span>
<span class="sd">    energy available on a horizontal surface.</span>
<span class="sd">    </span>
<span class="sd">    Global Irradiance Components:</span>
<span class="sd">    - Direct component: Solar radiation from the sun&#39;s disk, affected by shadows and obstacles</span>
<span class="sd">    - Diffuse component: Solar radiation scattered by the atmosphere, affected by sky view</span>
<span class="sd">    - Total irradiance: Sum of direct and diffuse components at each location</span>
<span class="sd">    </span>
<span class="sd">    Physical Considerations:</span>
<span class="sd">    - Direct radiation varies with sun position and local obstructions</span>
<span class="sd">    - Diffuse radiation varies with sky visibility (Sky View Factor)</span>
<span class="sd">    - Both components are affected by tree transmittance using Beer-Lambert law</span>
<span class="sd">    - Invalid locations (e.g., on water, buildings) are marked as NaN</span>

<span class="sd">    The function:</span>
<span class="sd">    1. Computes direct solar irradiance map accounting for sun position and shadows</span>
<span class="sd">    2. Computes diffuse solar irradiance map based on Sky View Factor</span>
<span class="sd">    3. Combines maps and optionally visualizes/exports results for analysis</span>

<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D voxel array representing the urban environment</span>
<span class="sd">        meshsize (float): Voxel size in meters (spatial resolution)</span>
<span class="sd">        azimuth_degrees (float): Sun azimuth angle in degrees (0° = North, 90° = East)</span>
<span class="sd">        elevation_degrees (float): Sun elevation angle in degrees above horizon (0-90°)</span>
<span class="sd">        direct_normal_irradiance (float): Direct normal irradiance in W/m² (from weather data)</span>
<span class="sd">        diffuse_irradiance (float): Diffuse horizontal irradiance in W/m² (from weather data)</span>
<span class="sd">        show_plot (bool): Whether to display visualization of results</span>
<span class="sd">        **kwargs: Additional arguments including:</span>
<span class="sd">            - view_point_height (float): Observer height in meters (default: 1.5)</span>
<span class="sd">                Height above ground where measurements are taken</span>
<span class="sd">            - colormap (str): Matplotlib colormap name for visualization (default: &#39;magma&#39;)</span>
<span class="sd">            - vmin (float): Minimum value for colormap scaling</span>
<span class="sd">            - vmax (float): Maximum value for colormap scaling</span>
<span class="sd">            - tree_k (float): Tree extinction coefficient for transmittance calculations</span>
<span class="sd">                Higher values mean trees block more light</span>
<span class="sd">            - tree_lad (float): Leaf area density in m^-1</span>
<span class="sd">                Affects light attenuation through tree canopies</span>
<span class="sd">            - obj_export (bool): Whether to export results as 3D OBJ file</span>
<span class="sd">            - output_directory (str): Directory for file exports</span>
<span class="sd">            - output_file_name (str): Base filename for exports</span>
<span class="sd">            - dem_grid (ndarray): Digital elevation model for 3D export</span>
<span class="sd">            - num_colors (int): Number of discrete colors for OBJ export</span>
<span class="sd">            - alpha (float): Transparency value for 3D visualization</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: 2D array of global solar irradiance values in W/m²</span>
<span class="sd">                - Values represent total solar energy flux on horizontal surfaces</span>
<span class="sd">                - Range: 0.0 to (direct_normal_irradiance * sin(elevation) + diffuse_irradiance)</span>
<span class="sd">                - NaN indicates invalid measurement locations</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        Global irradiance is the standard metric used for solar energy assessment</span>
<span class="sd">        and represents the maximum solar energy available at each location.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="c1"># Extract visualization parameters</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span>

    <span class="c1"># Create kwargs for individual component calculations</span>
    <span class="c1"># Both direct and diffuse calculations use the same base parameters</span>
    <span class="n">direct_diffuse_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">direct_diffuse_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s1">&#39;show_plot&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>   <span class="c1"># Show intermediate results for debugging</span>
        <span class="s1">&#39;obj_export&#39;</span><span class="p">:</span> <span class="kc">False</span>  <span class="c1"># Don&#39;t export intermediate results</span>
    <span class="p">})</span>

    <span class="c1"># Compute direct irradiance component</span>
    <span class="c1"># Accounts for sun position, shadows, and tree transmittance</span>
    <span class="n">direct_map</span> <span class="o">=</span> <span class="n">get_direct_solar_irradiance_map</span><span class="p">(</span>
        <span class="n">voxel_data</span><span class="p">,</span>
        <span class="n">meshsize</span><span class="p">,</span>
        <span class="n">azimuth_degrees</span><span class="p">,</span>
        <span class="n">elevation_degrees</span><span class="p">,</span>
        <span class="n">direct_normal_irradiance</span><span class="p">,</span>
        <span class="o">**</span><span class="n">direct_diffuse_kwargs</span>
    <span class="p">)</span>

    <span class="c1"># Compute diffuse irradiance component  </span>
    <span class="c1"># Based on Sky View Factor and atmospheric scattering</span>
    <span class="n">diffuse_map</span> <span class="o">=</span> <span class="n">get_diffuse_solar_irradiance_map</span><span class="p">(</span>
        <span class="n">voxel_data</span><span class="p">,</span>
        <span class="n">meshsize</span><span class="p">,</span>
        <span class="n">diffuse_irradiance</span><span class="o">=</span><span class="n">diffuse_irradiance</span><span class="p">,</span>
        <span class="o">**</span><span class="n">direct_diffuse_kwargs</span>
    <span class="p">)</span>

    <span class="c1"># Sum the two components to get total global irradiance</span>
    <span class="c1"># This represents the total solar energy available at each location</span>
    <span class="n">global_map</span> <span class="o">=</span> <span class="n">direct_map</span> <span class="o">+</span> <span class="n">diffuse_map</span>

    <span class="c1"># Determine colormap scaling range from actual data</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">global_map</span><span class="p">))</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">global_map</span><span class="p">))</span>

    <span class="c1"># Optional visualization of combined results</span>
    <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
        <span class="c1"># Set up colormap with special handling for invalid data</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightgray&#39;</span><span class="p">)</span>  <span class="c1"># NaN values shown in gray</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="c1"># plt.title(&quot;Global Solar Irradiance Map&quot;)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">global_map</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Global Solar Irradiance (W/m²)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Optional export to 3D OBJ format for external visualization</span>
    <span class="n">obj_export</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj_export&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">obj_export</span><span class="p">:</span>
        <span class="c1"># Get export parameters with defaults</span>
        <span class="n">dem_grid</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dem_grid&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">global_map</span><span class="p">))</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_directory&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">)</span>
        <span class="n">output_file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_file_name&quot;</span><span class="p">,</span> <span class="s2">&quot;global_solar_irradiance&quot;</span><span class="p">)</span>
        <span class="n">num_colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_colors&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">meshsize_param</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;meshsize&quot;</span><span class="p">,</span> <span class="n">meshsize</span><span class="p">)</span>
        <span class="n">view_point_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;view_point_height&quot;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
        
        <span class="c1"># Export as colored 3D mesh</span>
        <span class="n">grid_to_obj</span><span class="p">(</span>
            <span class="n">global_map</span><span class="p">,</span>
            <span class="n">dem_grid</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="p">,</span>
            <span class="n">output_file_name</span><span class="p">,</span>
            <span class="n">meshsize_param</span><span class="p">,</span>
            <span class="n">view_point_height</span><span class="p">,</span>
            <span class="n">colormap_name</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span>
            <span class="n">num_colors</span><span class="o">=</span><span class="n">num_colors</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">global_map</span></div>


<div class="viewcode-block" id="get_solar_positions_astral">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_solar_positions_astral">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_solar_positions_astral</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute solar azimuth and elevation using Astral for given times and location.</span>
<span class="sd">    </span>
<span class="sd">    This function uses the Astral astronomical library to calculate precise solar positions</span>
<span class="sd">    based on location coordinates and timestamps. The calculations account for Earth&#39;s</span>
<span class="sd">    orbital mechanics, axial tilt, and atmospheric refraction effects.</span>
<span class="sd">    </span>
<span class="sd">    Astronomical Background:</span>
<span class="sd">    - Solar position depends on date, time, and geographic location</span>
<span class="sd">    - Azimuth: Horizontal angle measured clockwise from North (0°-360°)</span>
<span class="sd">    - Elevation: Vertical angle above the horizon (-90° to +90°)</span>
<span class="sd">    - Calculations use standard astronomical algorithms (e.g., NREL SPA)</span>
<span class="sd">    </span>
<span class="sd">    Coordinate System:</span>
<span class="sd">    - Azimuth: 0° = North, 90° = East, 180° = South, 270° = West</span>
<span class="sd">    - Elevation: 0° = horizon, 90° = zenith, negative values = below horizon</span>
<span class="sd">    - All angles are in degrees for consistency with weather data formats</span>
<span class="sd">    </span>
<span class="sd">    The function:</span>
<span class="sd">    1. Creates an Astral observer at the specified geographic location</span>
<span class="sd">    2. Computes sun position for each timestamp in the input array</span>
<span class="sd">    3. Returns DataFrame with azimuth and elevation angles for further processing</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        times (DatetimeIndex): Array of timezone-aware datetime objects</span>
<span class="sd">                              Must include timezone information for accurate calculations</span>
<span class="sd">        lon (float): Longitude in degrees (positive = East, negative = West)</span>
<span class="sd">                    Range: -180° to +180°</span>
<span class="sd">        lat (float): Latitude in degrees (positive = North, negative = South)</span>
<span class="sd">                    Range: -90° to +90°</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame: DataFrame with columns &#39;azimuth&#39; and &#39;elevation&#39; containing solar positions</span>
<span class="sd">                  - Index: Input timestamps (timezone-aware)</span>
<span class="sd">                  - &#39;azimuth&#39;: Solar azimuth angles in degrees (0°-360°)</span>
<span class="sd">                  - &#39;elevation&#39;: Solar elevation angles in degrees (-90° to +90°)</span>
<span class="sd">                  - All values are float type for numerical calculations</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        Input times must be timezone-aware. The function preserves the original</span>
<span class="sd">        timezone information and performs calculations in the specified timezone.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create an astronomical observer at the specified geographic location</span>
    <span class="n">observer</span> <span class="o">=</span> <span class="n">Observer</span><span class="p">(</span><span class="n">latitude</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">longitude</span><span class="o">=</span><span class="n">lon</span><span class="p">)</span>
    
    <span class="c1"># Initialize result DataFrame with appropriate structure</span>
    <span class="n">df_pos</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;elevation&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Calculate solar position for each timestamp</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
        <span class="c1"># t is already timezone-aware; no need to replace tzinfo</span>
        <span class="c1"># Calculate solar elevation (vertical angle above horizon)</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">elevation</span><span class="p">(</span><span class="n">observer</span><span class="o">=</span><span class="n">observer</span><span class="p">,</span> <span class="n">dateandtime</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
        
        <span class="c1"># Calculate solar azimuth (horizontal angle from North)</span>
        <span class="n">az</span> <span class="o">=</span> <span class="n">azimuth</span><span class="p">(</span><span class="n">observer</span><span class="o">=</span><span class="n">observer</span><span class="p">,</span> <span class="n">dateandtime</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
        
        <span class="c1"># Store results in DataFrame</span>
        <span class="n">df_pos</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;elevation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">el</span>
        <span class="n">df_pos</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">az</span>

    <span class="k">return</span> <span class="n">df_pos</span></div>


<div class="viewcode-block" id="get_cumulative_global_solar_irradiance">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_cumulative_global_solar_irradiance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_cumulative_global_solar_irradiance</span><span class="p">(</span>
    <span class="n">voxel_data</span><span class="p">,</span>
    <span class="n">meshsize</span><span class="p">,</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span>
    <span class="n">direct_normal_irradiance_scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">diffuse_irradiance_scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute cumulative global solar irradiance over a specified period using data from an EPW file.</span>

<span class="sd">    This function performs time-series analysis of solar irradiance by processing weather data</span>
<span class="sd">    over a user-defined period and accumulating irradiance values at each location. The result</span>
<span class="sd">    represents the total solar energy received during the specified time period, which is</span>
<span class="sd">    essential for seasonal analysis, solar panel positioning, and energy yield predictions.</span>
<span class="sd">    </span>
<span class="sd">    Cumulative Analysis Concept:</span>
<span class="sd">    - Instantaneous irradiance (W/m²): Power at a specific moment</span>
<span class="sd">    - Cumulative irradiance (Wh/m²): Energy accumulated over time</span>
<span class="sd">    - Integration: Sum of (irradiance × time_step) for all timesteps</span>
<span class="sd">    - Applications: Annual energy yield, seasonal variations, optimal siting</span>
<span class="sd">    </span>
<span class="sd">    Time Period Processing:</span>
<span class="sd">    - Supports flexible time ranges (daily, seasonal, annual analysis)</span>
<span class="sd">    - Handles timezone conversions between local and UTC time</span>
<span class="sd">    - Filters weather data based on user-specified start/end times</span>
<span class="sd">    - Accounts for leap years and varying daylight hours</span>
<span class="sd">    </span>
<span class="sd">    Performance Optimization:</span>
<span class="sd">    - Pre-calculates diffuse map once (scales linearly with DHI)</span>
<span class="sd">    - Processes direct component for each timestep (varies with sun position)</span>
<span class="sd">    - Uses efficient memory management for large time series</span>
<span class="sd">    - Provides optional progress monitoring for long calculations</span>

<span class="sd">    The function:</span>
<span class="sd">    1. Filters EPW data for specified time period with timezone handling</span>
<span class="sd">    2. Computes sun positions for each timestep using astronomical calculations</span>
<span class="sd">    3. Calculates and accumulates global irradiance maps over the entire period</span>
<span class="sd">    4. Handles tree transmittance and provides visualization/export options</span>

<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values representing the urban environment</span>
<span class="sd">        meshsize (float): Size of each voxel in meters (spatial resolution)</span>
<span class="sd">        df (DataFrame): EPW weather data with columns &#39;DNI&#39;, &#39;DHI&#39; and datetime index</span>
<span class="sd">                       Must include complete meteorological dataset</span>
<span class="sd">        lon (float): Longitude in degrees for solar position calculations</span>
<span class="sd">        lat (float): Latitude in degrees for solar position calculations  </span>
<span class="sd">        tz (float): Timezone offset in hours from UTC (positive = East of UTC)</span>
<span class="sd">        direct_normal_irradiance_scaling (float): Scaling factor for direct normal irradiance</span>
<span class="sd">                                                 Allows sensitivity analysis or unit conversions</span>
<span class="sd">        diffuse_irradiance_scaling (float): Scaling factor for diffuse horizontal irradiance</span>
<span class="sd">                                          Allows sensitivity analysis or unit conversions</span>
<span class="sd">        **kwargs: Additional arguments including:</span>
<span class="sd">            - view_point_height (float): Observer height in meters (default: 1.5)</span>
<span class="sd">                Height above ground where measurements are taken</span>
<span class="sd">            - start_time (str): Start time in format &#39;MM-DD HH:MM:SS&#39;</span>
<span class="sd">                Defines beginning of analysis period (default: &quot;01-01 05:00:00&quot;)</span>
<span class="sd">            - end_time (str): End time in format &#39;MM-DD HH:MM:SS&#39;  </span>
<span class="sd">                Defines end of analysis period (default: &quot;01-01 20:00:00&quot;)</span>
<span class="sd">            - tree_k (float): Tree extinction coefficient for transmittance calculations</span>
<span class="sd">                Higher values mean trees block more light</span>
<span class="sd">            - tree_lad (float): Leaf area density in m^-1</span>
<span class="sd">                Affects light attenuation through tree canopies</span>
<span class="sd">            - show_plot (bool): Whether to show final accumulated results</span>
<span class="sd">            - show_each_timestep (bool): Whether to show plots for each timestep</span>
<span class="sd">                Useful for debugging but significantly increases computation time</span>
<span class="sd">            - colormap (str): Matplotlib colormap name for visualization</span>
<span class="sd">            - vmin (float): Minimum value for colormap scaling</span>
<span class="sd">            - vmax (float): Maximum value for colormap scaling</span>
<span class="sd">            - obj_export (bool): Whether to export results as 3D OBJ file</span>
<span class="sd">            - output_directory (str): Directory for file exports</span>
<span class="sd">            - output_file_name (str): Base filename for exports</span>
<span class="sd">            - dem_grid (ndarray): Digital elevation model for 3D export</span>
<span class="sd">            - num_colors (int): Number of discrete colors for OBJ export</span>
<span class="sd">            - alpha (float): Transparency value for 3D visualization</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: 2D array of cumulative global solar irradiance values in W/m²·hour</span>
<span class="sd">                - Values represent total solar energy received during the analysis period</span>
<span class="sd">                - Range depends on period length and local climate conditions</span>
<span class="sd">                - NaN indicates invalid measurement locations (e.g., on buildings, water)</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The function efficiently handles large time series by pre-computing the diffuse</span>
<span class="sd">        component once and scaling it for each timestep, significantly reducing</span>
<span class="sd">        computation time for long-term analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract parameters with defaults for observer positioning and visualization</span>
    <span class="n">view_point_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;view_point_height&quot;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start_time&quot;</span><span class="p">,</span> <span class="s2">&quot;01-01 05:00:00&quot;</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;end_time&quot;</span><span class="p">,</span> <span class="s2">&quot;01-01 20:00:00&quot;</span><span class="p">)</span>

    <span class="c1"># Validate input data</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No data in EPW file.&quot;</span><span class="p">)</span>

    <span class="c1"># Parse start and end times without year (supports multi-year analysis)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">start_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="n">end_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start_time and end_time must be in format &#39;MM-DD HH:MM:SS&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ve</span>

    <span class="c1"># Add hour of year column for efficient time filtering</span>
    <span class="c1"># Hour 1 = January 1st, 00:00; Hour 8760 = December 31st, 23:00</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;hour_of_year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">dayofyear</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="c1"># Convert parsed dates to day of year and hour for filtering</span>
    <span class="n">start_doy</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span><span class="o">.</span><span class="n">tm_yday</span>
    <span class="n">end_doy</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span><span class="o">.</span><span class="n">tm_yday</span>
    
    <span class="n">start_hour</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_doy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">end_hour</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_doy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Handle period crossing year boundary (e.g., Dec 15 to Jan 15)</span>
    <span class="k">if</span> <span class="n">start_hour</span> <span class="o">&lt;=</span> <span class="n">end_hour</span><span class="p">:</span>
        <span class="c1"># Normal period within single year</span>
        <span class="n">df_period</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;hour_of_year&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_hour</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;hour_of_year&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_hour</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Period crosses year boundary - include end and beginning of year</span>
        <span class="n">df_period</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;hour_of_year&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">start_hour</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;hour_of_year&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end_hour</span><span class="p">)]</span>

    <span class="c1"># Apply minute-level filtering within start/end hours for precision</span>
    <span class="n">df_period</span> <span class="o">=</span> <span class="n">df_period</span><span class="p">[</span>
        <span class="p">((</span><span class="n">df_period</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">!=</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df_period</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">minute</span> <span class="o">&gt;=</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">minute</span><span class="p">))</span> <span class="o">&amp;</span>
        <span class="p">((</span><span class="n">df_period</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">!=</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">df_period</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">minute</span> <span class="o">&lt;=</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">minute</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="c1"># Validate filtered data</span>
    <span class="k">if</span> <span class="n">df_period</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No EPW data in the specified period.&quot;</span><span class="p">)</span>

    <span class="c1"># Handle timezone conversion for accurate solar position calculations</span>
    <span class="c1"># Convert local time (from EPW) to UTC for astronomical calculations</span>
    <span class="n">offset_minutes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tz</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">local_tz</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">FixedOffset</span><span class="p">(</span><span class="n">offset_minutes</span><span class="p">)</span>
    <span class="n">df_period_local</span> <span class="o">=</span> <span class="n">df_period</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">local_tz</span><span class="p">)</span>
    <span class="n">df_period_utc</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">UTC</span><span class="p">)</span>

    <span class="c1"># Compute solar positions for entire analysis period</span>
    <span class="c1"># This is done once to optimize performance</span>
    <span class="n">solar_positions</span> <span class="o">=</span> <span class="n">get_solar_positions_astral</span><span class="p">(</span><span class="n">df_period_utc</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>

    <span class="c1"># Prepare parameters for efficient diffuse irradiance calculation</span>
    <span class="c1"># Create kwargs for diffuse calculation with visualization disabled</span>
    <span class="n">diffuse_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">diffuse_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s1">&#39;show_plot&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;obj_export&#39;</span><span class="p">:</span> <span class="kc">False</span>
    <span class="p">})</span>

    <span class="c1"># Pre-compute base diffuse map once with unit irradiance</span>
    <span class="c1"># This map will be scaled by actual DHI values for each timestep</span>
    <span class="n">base_diffuse_map</span> <span class="o">=</span> <span class="n">get_diffuse_solar_irradiance_map</span><span class="p">(</span>
        <span class="n">voxel_data</span><span class="p">,</span>
        <span class="n">meshsize</span><span class="p">,</span>
        <span class="n">diffuse_irradiance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">diffuse_kwargs</span>
    <span class="p">)</span>

    <span class="c1"># Initialize accumulation arrays for energy integration</span>
    <span class="n">cumulative_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">voxel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">voxel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">mask_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">voxel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">voxel_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Prepare parameters for direct irradiance calculations</span>
    <span class="c1"># Create kwargs for direct calculation with visualization disabled</span>
    <span class="n">direct_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">direct_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s1">&#39;show_plot&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;view_point_height&#39;</span><span class="p">:</span> <span class="n">view_point_height</span><span class="p">,</span>
        <span class="s1">&#39;obj_export&#39;</span><span class="p">:</span> <span class="kc">False</span>
    <span class="p">})</span>

    <span class="c1"># Main processing loop: iterate through each timestep in the analysis period</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">time_utc</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df_period_utc</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()):</span>
        <span class="c1"># Apply scaling factors to weather data</span>
        <span class="c1"># Allows for sensitivity analysis or unit conversions</span>
        <span class="n">DNI</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;DNI&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">direct_normal_irradiance_scaling</span>
        <span class="n">DHI</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;DHI&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">diffuse_irradiance_scaling</span>
        <span class="n">time_local</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Get solar position for timestep</span>
        <span class="n">solpos</span> <span class="o">=</span> <span class="n">solar_positions</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">time_utc</span><span class="p">]</span>
        <span class="n">azimuth_degrees</span> <span class="o">=</span> <span class="n">solpos</span><span class="p">[</span><span class="s1">&#39;azimuth&#39;</span><span class="p">]</span>
        <span class="n">elevation_degrees</span> <span class="o">=</span> <span class="n">solpos</span><span class="p">[</span><span class="s1">&#39;elevation&#39;</span><span class="p">]</span>        

        <span class="c1"># Compute direct irradiance map with transmittance</span>
        <span class="n">direct_map</span> <span class="o">=</span> <span class="n">get_direct_solar_irradiance_map</span><span class="p">(</span>
            <span class="n">voxel_data</span><span class="p">,</span>
            <span class="n">meshsize</span><span class="p">,</span>
            <span class="n">azimuth_degrees</span><span class="p">,</span>
            <span class="n">elevation_degrees</span><span class="p">,</span>
            <span class="n">direct_normal_irradiance</span><span class="o">=</span><span class="n">DNI</span><span class="p">,</span>
            <span class="o">**</span><span class="n">direct_kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Scale base diffuse map by actual DHI</span>
        <span class="n">diffuse_map</span> <span class="o">=</span> <span class="n">base_diffuse_map</span> <span class="o">*</span> <span class="n">DHI</span>

        <span class="c1"># Combine direct and diffuse components</span>
        <span class="n">global_map</span> <span class="o">=</span> <span class="n">direct_map</span> <span class="o">+</span> <span class="n">diffuse_map</span>

        <span class="c1"># Update valid pixel mask</span>
        <span class="n">mask_map</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">global_map</span><span class="p">)</span>

        <span class="c1"># Replace NaN with 0 for accumulation</span>
        <span class="n">global_map_filled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">global_map</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">cumulative_map</span> <span class="o">+=</span> <span class="n">global_map_filled</span>

        <span class="c1"># Optional timestep visualization</span>
        <span class="n">show_each_timestep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;show_each_timestep&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_each_timestep</span><span class="p">:</span>
            <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">direct_normal_irradiance_scaling</span><span class="p">,</span> <span class="n">diffuse_irradiance_scaling</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightgray&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="c1"># plt.title(f&quot;Global Solar Irradiance at {time_local.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&quot;)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">global_map</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Global Solar Irradiance (W/m²)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Apply mask to final result</span>
    <span class="n">cumulative_map</span><span class="p">[</span><span class="o">~</span><span class="n">mask_map</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Final visualization</span>
    <span class="n">show_plot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;show_plot&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
        <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">cumulative_map</span><span class="p">))</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">cumulative_map</span><span class="p">))</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightgray&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="c1"># plt.title(&quot;Cumulative Global Solar Irradiance Map&quot;)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cumulative_map</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cumulative Global Solar Irradiance (W/m²·hour)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># Optional OBJ export</span>
    <span class="n">obj_export</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj_export&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">obj_export</span><span class="p">:</span>
        <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s2">&quot;magma&quot;</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">cumulative_map</span><span class="p">))</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">cumulative_map</span><span class="p">))</span>
        <span class="n">dem_grid</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dem_grid&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cumulative_map</span><span class="p">))</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_directory&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">)</span>
        <span class="n">output_file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_file_name&quot;</span><span class="p">,</span> <span class="s2">&quot;cummurative_global_solar_irradiance&quot;</span><span class="p">)</span>
        <span class="n">num_colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;num_colors&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">grid_to_obj</span><span class="p">(</span>
            <span class="n">cumulative_map</span><span class="p">,</span>
            <span class="n">dem_grid</span><span class="p">,</span>
            <span class="n">output_dir</span><span class="p">,</span>
            <span class="n">output_file_name</span><span class="p">,</span>
            <span class="n">meshsize</span><span class="p">,</span>
            <span class="n">view_point_height</span><span class="p">,</span>
            <span class="n">colormap_name</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span>
            <span class="n">num_colors</span><span class="o">=</span><span class="n">num_colors</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">cumulative_map</span></div>


<div class="viewcode-block" id="get_global_solar_irradiance_using_epw">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_global_solar_irradiance_using_epw">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_global_solar_irradiance_using_epw</span><span class="p">(</span>
    <span class="n">voxel_data</span><span class="p">,</span>
    <span class="n">meshsize</span><span class="p">,</span>
    <span class="n">calc_type</span><span class="o">=</span><span class="s1">&#39;instantaneous&#39;</span><span class="p">,</span>
    <span class="n">direct_normal_irradiance_scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">diffuse_irradiance_scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute global solar irradiance using EPW weather data, either for a single time or cumulatively over a period.</span>

<span class="sd">    The function:</span>
<span class="sd">    1. Optionally downloads and reads EPW weather data</span>
<span class="sd">    2. Handles timezone conversions and solar position calculations</span>
<span class="sd">    3. Computes either instantaneous or cumulative irradiance maps</span>
<span class="sd">    4. Supports visualization and export options</span>

<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values.</span>
<span class="sd">        meshsize (float): Size of each voxel in meters.</span>
<span class="sd">        calc_type (str): &#39;instantaneous&#39; or &#39;cumulative&#39;.</span>
<span class="sd">        direct_normal_irradiance_scaling (float): Scaling factor for direct normal irradiance.</span>
<span class="sd">        diffuse_irradiance_scaling (float): Scaling factor for diffuse horizontal irradiance.</span>
<span class="sd">        **kwargs: Additional arguments including:</span>
<span class="sd">            - download_nearest_epw (bool): Whether to download nearest EPW file</span>
<span class="sd">            - epw_file_path (str): Path to EPW file</span>
<span class="sd">            - rectangle_vertices (list): List of (lat,lon) coordinates for EPW download</span>
<span class="sd">            - output_dir (str): Directory for EPW download</span>
<span class="sd">            - calc_time (str): Time for instantaneous calculation (&#39;MM-DD HH:MM:SS&#39;)</span>
<span class="sd">            - start_time (str): Start time for cumulative calculation</span>
<span class="sd">            - end_time (str): End time for cumulative calculation</span>
<span class="sd">            - start_hour (int): Starting hour for daily time window (0-23)</span>
<span class="sd">            - end_hour (int): Ending hour for daily time window (0-23)</span>
<span class="sd">            - view_point_height (float): Observer height in meters</span>
<span class="sd">            - tree_k (float): Tree extinction coefficient</span>
<span class="sd">            - tree_lad (float): Leaf area density in m^-1</span>
<span class="sd">            - show_plot (bool): Whether to show visualization</span>
<span class="sd">            - show_each_timestep (bool): Whether to show timestep plots</span>
<span class="sd">            - colormap (str): Matplotlib colormap name</span>
<span class="sd">            - obj_export (bool): Whether to export as OBJ file</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: 2D array of solar irradiance values (W/m²).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">view_point_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;view_point_height&quot;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="n">colormap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;colormap&quot;</span><span class="p">,</span> <span class="s1">&#39;magma&#39;</span><span class="p">)</span>

    <span class="c1"># Get EPW file</span>
    <span class="n">download_nearest_epw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;download_nearest_epw&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">rectangle_vertices</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rectangle_vertices&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">epw_file_path</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epw_file_path&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">download_nearest_epw</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rectangle_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rectangle_vertices is required to download nearest EPW file&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate center point of rectangle</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">rectangle_vertices</span><span class="p">]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">rectangle_vertices</span><span class="p">]</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">target_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_lon</span><span class="p">,</span> <span class="n">center_lat</span><span class="p">)</span>

            <span class="c1"># Optional: specify maximum distance in kilometers</span>
            <span class="n">max_distance</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># None for no limit</span>

            <span class="n">output_dir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_dir&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">)</span>

            <span class="n">epw_file_path</span><span class="p">,</span> <span class="n">weather_data</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">get_nearest_epw_from_climate_onebuilding</span><span class="p">(</span>
                <span class="n">longitude</span><span class="o">=</span><span class="n">center_lon</span><span class="p">,</span>
                <span class="n">latitude</span><span class="o">=</span><span class="n">center_lat</span><span class="p">,</span>
                <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span>
                <span class="n">max_distance</span><span class="o">=</span><span class="n">max_distance</span><span class="p">,</span>
                <span class="n">extract_zip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">load_data</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

    <span class="c1"># Read EPW data</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">elevation_m</span> <span class="o">=</span> <span class="n">read_epw_for_solar_simulation</span><span class="p">(</span><span class="n">epw_file_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No data in EPW file.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">calc_type</span> <span class="o">==</span> <span class="s1">&#39;instantaneous&#39;</span><span class="p">:</span>

        <span class="n">calc_time</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;calc_time&quot;</span><span class="p">,</span> <span class="s2">&quot;01-01 12:00:00&quot;</span><span class="p">)</span>

        <span class="c1"># Parse start and end times without year</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">calc_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">calc_time</span><span class="p">,</span> <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;calc_time must be in format &#39;MM-DD HH:MM:SS&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ve</span>

        <span class="n">df_period</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="n">calc_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">day</span> <span class="o">==</span> <span class="n">calc_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">==</span> <span class="n">calc_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">df_period</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No EPW data at the specified time.&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare timezone conversion</span>
        <span class="n">offset_minutes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tz</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
        <span class="n">local_tz</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">FixedOffset</span><span class="p">(</span><span class="n">offset_minutes</span><span class="p">)</span>
        <span class="n">df_period_local</span> <span class="o">=</span> <span class="n">df_period</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">local_tz</span><span class="p">)</span>
        <span class="n">df_period_utc</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">UTC</span><span class="p">)</span>

        <span class="c1"># Compute solar positions</span>
        <span class="n">solar_positions</span> <span class="o">=</span> <span class="n">get_solar_positions_astral</span><span class="p">(</span><span class="n">df_period_utc</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="n">direct_normal_irradiance</span> <span class="o">=</span> <span class="n">df_period_utc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;DNI&#39;</span><span class="p">]</span>
        <span class="n">diffuse_irradiance</span> <span class="o">=</span> <span class="n">df_period_utc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;DHI&#39;</span><span class="p">]</span>
        <span class="n">azimuth_degrees</span> <span class="o">=</span> <span class="n">solar_positions</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;azimuth&#39;</span><span class="p">]</span>
        <span class="n">elevation_degrees</span> <span class="o">=</span> <span class="n">solar_positions</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;elevation&#39;</span><span class="p">]</span>    
        <span class="n">solar_map</span> <span class="o">=</span> <span class="n">get_global_solar_irradiance_map</span><span class="p">(</span>
            <span class="n">voxel_data</span><span class="p">,</span>                 <span class="c1"># 3D voxel grid representing the urban environment</span>
            <span class="n">meshsize</span><span class="p">,</span>                   <span class="c1"># Size of each grid cell in meters</span>
            <span class="n">azimuth_degrees</span><span class="p">,</span>            <span class="c1"># Sun&#39;s azimuth angle</span>
            <span class="n">elevation_degrees</span><span class="p">,</span>          <span class="c1"># Sun&#39;s elevation angle</span>
            <span class="n">direct_normal_irradiance</span><span class="p">,</span>   <span class="c1"># Direct Normal Irradiance value</span>
            <span class="n">diffuse_irradiance</span><span class="p">,</span>         <span class="c1"># Diffuse irradiance value</span>
            <span class="n">show_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>             <span class="c1"># Display visualization of results</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">calc_type</span> <span class="o">==</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">:</span>
        <span class="c1"># Get time window parameters</span>
        <span class="n">start_hour</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start_hour&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Default to midnight</span>
        <span class="n">end_hour</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;end_hour&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>     <span class="c1"># Default to 11 PM</span>
        
        <span class="c1"># Filter dataframe for specified hours</span>
        <span class="n">df_filtered</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">&gt;=</span> <span class="n">start_hour</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">&lt;=</span> <span class="n">end_hour</span><span class="p">)]</span>
        
        <span class="n">solar_map</span> <span class="o">=</span> <span class="n">get_cumulative_global_solar_irradiance</span><span class="p">(</span>
            <span class="n">voxel_data</span><span class="p">,</span>
            <span class="n">meshsize</span><span class="p">,</span>
            <span class="n">df_filtered</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">solar_map</span> </div>


<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">trimesh</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">njit</span>

<span class="c1">##############################################################################</span>
<span class="c1"># 1) New Numba helper: per-face solar irradiance computation</span>
<span class="c1">##############################################################################</span>
<div class="viewcode-block" id="compute_solar_irradiance_for_all_faces">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.compute_solar_irradiance_for_all_faces">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_solar_irradiance_for_all_faces</span><span class="p">(</span>
    <span class="n">face_centers</span><span class="p">,</span>
    <span class="n">face_normals</span><span class="p">,</span>
    <span class="n">face_svf</span><span class="p">,</span>
    <span class="n">sun_direction</span><span class="p">,</span>
    <span class="n">direct_normal_irradiance</span><span class="p">,</span>
    <span class="n">diffuse_irradiance</span><span class="p">,</span>
    <span class="n">voxel_data</span><span class="p">,</span>
    <span class="n">meshsize</span><span class="p">,</span>
    <span class="n">tree_k</span><span class="p">,</span>
    <span class="n">tree_lad</span><span class="p">,</span>
    <span class="n">hit_values</span><span class="p">,</span>
    <span class="n">inclusion_mode</span><span class="p">,</span>
    <span class="n">grid_bounds_real</span><span class="p">,</span>
    <span class="n">boundary_epsilon</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numba-compiled function to compute direct, diffuse, and global solar irradiance</span>
<span class="sd">    for each face in a 3D building mesh.</span>
<span class="sd">    </span>
<span class="sd">    This optimized function processes all mesh faces in parallel to calculate solar</span>
<span class="sd">    irradiance components. It handles both direct radiation (dependent on sun position</span>
<span class="sd">    and surface orientation) and diffuse radiation (dependent on sky visibility).</span>
<span class="sd">    The function is compiled with Numba for high-performance computation on large meshes.</span>
<span class="sd">    </span>
<span class="sd">    Surface Irradiance Physics:</span>
<span class="sd">    - Direct component: DNI × cos(incidence_angle) × transmittance</span>
<span class="sd">    - Diffuse component: DHI × sky_view_factor</span>
<span class="sd">    - Incidence angle: Angle between sun direction and surface normal</span>
<span class="sd">    - Transmittance: Attenuation factor from obstacles and vegetation</span>
<span class="sd">    </span>
<span class="sd">    Boundary Condition Handling:</span>
<span class="sd">    - Vertical boundary faces are excluded (mesh edges touching domain boundaries)</span>
<span class="sd">    - Invalid faces (NaN SVF) are skipped to maintain data consistency</span>
<span class="sd">    - Surface orientation affects direct radiation calculation</span>
<span class="sd">    </span>
<span class="sd">    Performance Optimizations:</span>
<span class="sd">    - Numba JIT compilation for near C-speed execution</span>
<span class="sd">    - Parallel processing of face calculations</span>
<span class="sd">    - Efficient geometric computations using vectorized operations</span>
<span class="sd">    - Memory-optimized array operations</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        face_centers (float64[:, :]): (N x 3) array of face center coordinates in real-world units</span>
<span class="sd">        face_normals (float64[:, :]): (N x 3) array of outward-pointing unit normal vectors</span>
<span class="sd">        face_svf (float64[:]): (N,) array of Sky View Factor values for each face (0.0-1.0)</span>
<span class="sd">        sun_direction (float64[:]): (3,) array for normalized sun direction vector (dx, dy, dz)</span>
<span class="sd">        direct_normal_irradiance (float): Direct normal irradiance (DNI) in W/m²</span>
<span class="sd">        diffuse_irradiance (float): Diffuse horizontal irradiance (DHI) in W/m²</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values for obstacle detection</span>
<span class="sd">        meshsize (float): Size of each voxel in meters (spatial resolution)</span>
<span class="sd">        tree_k (float): Tree extinction coefficient for Beer-Lambert law</span>
<span class="sd">        tree_lad (float): Leaf area density in m^-1</span>
<span class="sd">        hit_values (tuple): Values considered &#39;sky&#39; for ray tracing (e.g. (0,))</span>
<span class="sd">        inclusion_mode (bool): Whether hit_values are included (True) or excluded (False)</span>
<span class="sd">        grid_bounds_real (float64[2,3]): Domain boundaries [[x_min,y_min,z_min],[x_max,y_max,z_max]]</span>
<span class="sd">        boundary_epsilon (float): Distance threshold for boundary face detection</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: Three float64[N] arrays containing:</span>
<span class="sd">            - direct_irr: Direct solar irradiance for each face (W/m²)</span>
<span class="sd">            - diffuse_irr: Diffuse solar irradiance for each face (W/m²)  </span>
<span class="sd">            - global_irr: Global solar irradiance for each face (W/m²)</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        This function is optimized with Numba and should not be called directly.</span>
<span class="sd">        Use the higher-level wrapper functions for normal operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_faces</span> <span class="o">=</span> <span class="n">face_centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Initialize output arrays for each irradiance component</span>
    <span class="n">face_direct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">face_diffuse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">face_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="c1"># Extract domain boundaries for boundary face detection</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">z_min</span> <span class="o">=</span> <span class="n">grid_bounds_real</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">grid_bounds_real</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">grid_bounds_real</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_max</span> <span class="o">=</span> <span class="n">grid_bounds_real</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">grid_bounds_real</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">grid_bounds_real</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># Process each face individually (Numba optimizes this loop)</span>
    <span class="k">for</span> <span class="n">fidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_faces</span><span class="p">):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">face_centers</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">face_normals</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>
        <span class="n">svf</span>    <span class="o">=</span> <span class="n">face_svf</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>
        
        <span class="c1"># Check for vertical boundary faces that should be excluded</span>
        <span class="c1"># These are mesh edges at domain boundaries, not actual building surfaces</span>
        <span class="n">is_vertical</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># Nearly vertical normal</span>
        
        <span class="c1"># Check if face center is at domain boundary</span>
        <span class="n">on_x_min</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">boundary_epsilon</span><span class="p">)</span>
        <span class="n">on_y_min</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">boundary_epsilon</span><span class="p">)</span>
        <span class="n">on_x_max</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">boundary_epsilon</span><span class="p">)</span>
        <span class="n">on_y_max</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">boundary_epsilon</span><span class="p">)</span>
        
        <span class="n">is_boundary_vertical</span> <span class="o">=</span> <span class="n">is_vertical</span> <span class="ow">and</span> <span class="p">(</span><span class="n">on_x_min</span> <span class="ow">or</span> <span class="n">on_y_min</span> <span class="ow">or</span> <span class="n">on_x_max</span> <span class="ow">or</span> <span class="n">on_y_max</span><span class="p">)</span>
        
        <span class="c1"># Skip boundary faces to avoid artifacts</span>
        <span class="k">if</span> <span class="n">is_boundary_vertical</span><span class="p">:</span>
            <span class="n">face_direct</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">face_diffuse</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">face_global</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">continue</span>
        
        <span class="c1"># Skip faces with invalid SVF data</span>
        <span class="k">if</span> <span class="n">svf</span> <span class="o">!=</span> <span class="n">svf</span><span class="p">:</span>  <span class="c1"># NaN check in Numba-compatible way</span>
            <span class="n">face_direct</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">face_diffuse</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">face_global</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">continue</span>
        
        <span class="c1"># Calculate direct irradiance component</span>
        <span class="c1"># Only surfaces oriented towards the sun receive direct radiation</span>
        <span class="n">cos_incidence</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sun_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                        <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sun_direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                        <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">sun_direction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="n">direct_val</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">cos_incidence</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># Surface faces towards sun</span>
            <span class="c1"># Offset ray origin slightly along normal to avoid self-intersection</span>
            <span class="n">offset_vox</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># Small offset in voxel units</span>
            <span class="n">ray_origin_x</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">meshsize</span> <span class="o">+</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">offset_vox</span>
            <span class="n">ray_origin_y</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">meshsize</span> <span class="o">+</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">offset_vox</span>
            <span class="n">ray_origin_z</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">meshsize</span> <span class="o">+</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">offset_vox</span>
            
            <span class="c1"># Cast ray toward the sun to check for obstructions</span>
            <span class="n">hit_detected</span><span class="p">,</span> <span class="n">transmittance</span> <span class="o">=</span> <span class="n">trace_ray_generic</span><span class="p">(</span>
                <span class="n">voxel_data</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ray_origin_x</span><span class="p">,</span> <span class="n">ray_origin_y</span><span class="p">,</span> <span class="n">ray_origin_z</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                <span class="n">sun_direction</span><span class="p">,</span>
                <span class="n">hit_values</span><span class="p">,</span>
                <span class="n">meshsize</span><span class="p">,</span>
                <span class="n">tree_k</span><span class="p">,</span>
                <span class="n">tree_lad</span><span class="p">,</span>
                <span class="n">inclusion_mode</span>
            <span class="p">)</span>
            
            <span class="c1"># Calculate direct irradiance if path to sun is clear/partially clear</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hit_detected</span><span class="p">:</span>
                <span class="n">direct_val</span> <span class="o">=</span> <span class="n">direct_normal_irradiance</span> <span class="o">*</span> <span class="n">cos_incidence</span> <span class="o">*</span> <span class="n">transmittance</span>
        
        <span class="c1"># Calculate diffuse irradiance component using Sky View Factor</span>
        <span class="c1"># All surfaces receive diffuse radiation proportional to their sky visibility</span>
        <span class="n">diffuse_val</span> <span class="o">=</span> <span class="n">svf</span> <span class="o">*</span> <span class="n">diffuse_irradiance</span>
        
        <span class="c1"># Ensure diffuse irradiance doesn&#39;t exceed theoretical maximum</span>
        <span class="k">if</span> <span class="n">diffuse_val</span> <span class="o">&gt;</span> <span class="n">diffuse_irradiance</span><span class="p">:</span>
            <span class="n">diffuse_val</span> <span class="o">=</span> <span class="n">diffuse_irradiance</span>
        
        <span class="c1"># Store results for this face</span>
        <span class="n">face_direct</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>  <span class="o">=</span> <span class="n">direct_val</span>
        <span class="n">face_diffuse</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffuse_val</span>
        <span class="n">face_global</span><span class="p">[</span><span class="n">fidx</span><span class="p">]</span>  <span class="o">=</span> <span class="n">direct_val</span> <span class="o">+</span> <span class="n">diffuse_val</span>
    
    <span class="k">return</span> <span class="n">face_direct</span><span class="p">,</span> <span class="n">face_diffuse</span><span class="p">,</span> <span class="n">face_global</span></div>



<span class="c1">##############################################################################</span>
<span class="c1"># 2) Modified get_building_solar_irradiance: main Python wrapper</span>
<span class="c1">##############################################################################</span>
<div class="viewcode-block" id="get_building_solar_irradiance">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_building_solar_irradiance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_building_solar_irradiance</span><span class="p">(</span>
    <span class="n">voxel_data</span><span class="p">,</span>
    <span class="n">meshsize</span><span class="p">,</span>
    <span class="n">building_svf_mesh</span><span class="p">,</span>
    <span class="n">azimuth_degrees</span><span class="p">,</span>
    <span class="n">elevation_degrees</span><span class="p">,</span>
    <span class="n">direct_normal_irradiance</span><span class="p">,</span>
    <span class="n">diffuse_irradiance</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate solar irradiance on building surfaces using Sky View Factor (SVF) analysis,</span>
<span class="sd">    with high-performance computation accelerated by Numba JIT compilation.</span>
<span class="sd">    </span>
<span class="sd">    This function performs detailed solar irradiance analysis on 3D building surfaces</span>
<span class="sd">    represented as triangulated meshes. It calculates both direct and diffuse components</span>
<span class="sd">    of solar radiation for each mesh face, accounting for surface orientation, shadows,</span>
<span class="sd">    and sky visibility. The computation is optimized for large urban models using</span>
<span class="sd">    efficient algorithms and parallel processing.</span>
<span class="sd">    </span>
<span class="sd">    Mesh-Based Analysis Advantages:</span>
<span class="sd">    - Surface-specific calculations for facades, roofs, and complex geometries</span>
<span class="sd">    - Accurate accounting of surface orientation and local shading effects</span>
<span class="sd">    - Integration with 3D visualization and CAD workflows</span>
<span class="sd">    - Detailed irradiance data for building energy modeling</span>
<span class="sd">    </span>
<span class="sd">    Performance Features:</span>
<span class="sd">    - Numba JIT compilation for near C-speed execution</span>
<span class="sd">    - Parallel processing of mesh faces</span>
<span class="sd">    - Efficient ray tracing with tree transmittance</span>
<span class="sd">    - Memory-optimized operations for large datasets</span>
<span class="sd">    </span>
<span class="sd">    Physical Modeling:</span>
<span class="sd">    - Direct irradiance: Based on sun position and surface orientation</span>
<span class="sd">    - Diffuse irradiance: Based on Sky View Factor from each surface</span>
<span class="sd">    - Tree effects: Partial transmittance using Beer-Lambert law</span>
<span class="sd">    - Boundary handling: Automatic exclusion of domain boundary artifacts</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values representing the urban environment</span>
<span class="sd">        meshsize (float): Size of each voxel in meters (spatial resolution)</span>
<span class="sd">        building_svf_mesh (trimesh.Trimesh): Building mesh with pre-calculated SVF values in metadata</span>
<span class="sd">                                           Must have &#39;svf&#39; array in mesh.metadata</span>
<span class="sd">        azimuth_degrees (float): Sun azimuth angle in degrees (0=North, 90=East)</span>
<span class="sd">        elevation_degrees (float): Sun elevation angle in degrees above horizon (0-90°)</span>
<span class="sd">        direct_normal_irradiance (float): Direct normal irradiance (DNI) in W/m² from weather data</span>
<span class="sd">        diffuse_irradiance (float): Diffuse horizontal irradiance (DHI) in W/m² from weather data</span>
<span class="sd">        **kwargs: Additional parameters including:</span>
<span class="sd">            - tree_k (float): Tree extinction coefficient (default: 0.6)</span>
<span class="sd">                Higher values mean trees block more light</span>
<span class="sd">            - tree_lad (float): Leaf area density in m^-1 (default: 1.0)</span>
<span class="sd">                Affects light attenuation through tree canopies</span>
<span class="sd">            - progress_report (bool): Whether to print timing information (default: False)</span>
<span class="sd">            - obj_export (bool): Whether to export results as OBJ file</span>
<span class="sd">            - output_directory (str): Directory for file exports</span>
<span class="sd">            - output_file_name (str): Base filename for exports</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        trimesh.Trimesh: A copy of the input mesh with irradiance data stored in metadata:</span>
<span class="sd">                        - &#39;svf&#39;: Sky View Factor for each face (preserved from input)</span>
<span class="sd">                        - &#39;direct&#39;: Direct solar irradiance for each face (W/m²)</span>
<span class="sd">                        - &#39;diffuse&#39;: Diffuse solar irradiance for each face (W/m²)</span>
<span class="sd">                        - &#39;global&#39;: Global solar irradiance for each face (W/m²)</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The input mesh must have SVF values pre-calculated and stored in metadata.</span>
<span class="sd">        Use get_surface_view_factor() to compute SVF before calling this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
    
    <span class="c1"># Extract tree transmittance parameters with defaults</span>
    <span class="n">tree_k</span>          <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tree_k&quot;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
    <span class="n">tree_lad</span>        <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tree_lad&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">progress_report</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;progress_report&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># Define sky detection parameters for ray tracing</span>
    <span class="n">hit_values</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>    <span class="c1"># &#39;0&#39; = sky voxel value</span>
    <span class="n">inclusion_mode</span> <span class="o">=</span> <span class="kc">False</span>   <span class="c1"># Treat non-sky values as obstacles</span>
    
    <span class="c1"># Convert solar angles to 3D direction vector using spherical coordinates</span>
    <span class="n">az_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">180</span> <span class="o">-</span> <span class="n">azimuth_degrees</span><span class="p">)</span>  <span class="c1"># Adjust for coordinate system</span>
    <span class="n">el_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">elevation_degrees</span><span class="p">)</span>
    <span class="n">sun_dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">el_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">az_rad</span><span class="p">)</span>
    <span class="n">sun_dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">el_rad</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">az_rad</span><span class="p">)</span>
    <span class="n">sun_dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">el_rad</span><span class="p">)</span>
    <span class="n">sun_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sun_dx</span><span class="p">,</span> <span class="n">sun_dy</span><span class="p">,</span> <span class="n">sun_dz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="c1"># Extract mesh geometry data for processing</span>
    <span class="n">face_centers</span> <span class="o">=</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">triangles_center</span>  <span class="c1"># Center point of each face</span>
    <span class="n">face_normals</span> <span class="o">=</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">face_normals</span>      <span class="c1"># Normal vector for each face</span>
    
    <span class="c1"># Extract Sky View Factor data from mesh metadata</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">building_svf_mesh</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;svf&#39;</span> <span class="ow">in</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">):</span>
        <span class="n">face_svf</span> <span class="o">=</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;svf&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Initialize with zeros if SVF not available (should be pre-calculated)</span>
        <span class="n">face_svf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="c1"># Set up domain boundaries for boundary face detection</span>
    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">voxel_data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">grid_bounds_voxel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="n">grid_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">grid_bounds_real</span> <span class="o">=</span> <span class="n">grid_bounds_voxel</span> <span class="o">*</span> <span class="n">meshsize</span>
    <span class="n">boundary_epsilon</span> <span class="o">=</span> <span class="n">meshsize</span> <span class="o">*</span> <span class="mf">0.05</span>  <span class="c1"># Small tolerance for boundary detection</span>
    
    <span class="c1"># Call high-performance Numba-compiled calculation function</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">face_direct</span><span class="p">,</span> <span class="n">face_diffuse</span><span class="p">,</span> <span class="n">face_global</span> <span class="o">=</span> <span class="n">compute_solar_irradiance_for_all_faces</span><span class="p">(</span>
        <span class="n">face_centers</span><span class="p">,</span>
        <span class="n">face_normals</span><span class="p">,</span>
        <span class="n">face_svf</span><span class="p">,</span>
        <span class="n">sun_direction</span><span class="p">,</span>
        <span class="n">direct_normal_irradiance</span><span class="p">,</span>
        <span class="n">diffuse_irradiance</span><span class="p">,</span>
        <span class="n">voxel_data</span><span class="p">,</span>
        <span class="n">meshsize</span><span class="p">,</span>
        <span class="n">tree_k</span><span class="p">,</span>
        <span class="n">tree_lad</span><span class="p">,</span>
        <span class="n">hit_values</span><span class="p">,</span>
        <span class="n">inclusion_mode</span><span class="p">,</span>
        <span class="n">grid_bounds_real</span><span class="p">,</span>
        <span class="n">boundary_epsilon</span>
    <span class="p">)</span>
    
    <span class="c1"># Report performance timing if requested</span>
    <span class="k">if</span> <span class="n">progress_report</span><span class="p">:</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Numba-based solar irradiance calculation took </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    
    <span class="c1"># Create a copy of the input mesh to store results</span>
    <span class="n">irradiance_mesh</span> <span class="o">=</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">irradiance_mesh</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">):</span>
        <span class="n">irradiance_mesh</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># Store results</span>
    <span class="n">irradiance_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;svf&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="n">face_svf</span>
    <span class="n">irradiance_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;direct&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">face_direct</span>
    <span class="n">irradiance_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;diffuse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">face_diffuse</span>
    <span class="n">irradiance_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;global&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">face_global</span>
    
    <span class="n">irradiance_mesh</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Solar Irradiance (W/m²)&quot;</span>
    
    <span class="c1"># # Optional OBJ export</span>
    <span class="c1"># obj_export = kwargs.get(&quot;obj_export&quot;, False)</span>
    <span class="c1"># if obj_export:</span>
    <span class="c1">#     _export_solar_irradiance_mesh(</span>
    <span class="c1">#         irradiance_mesh,</span>
    <span class="c1">#         face_global,</span>
    <span class="c1">#         **kwargs</span>
    <span class="c1">#     )</span>
    
    <span class="k">return</span> <span class="n">irradiance_mesh</span></div>


<span class="c1">##############################################################################</span>
<span class="c1"># 4) Modified get_cumulative_building_solar_irradiance</span>
<span class="c1">##############################################################################</span>
<div class="viewcode-block" id="get_cumulative_building_solar_irradiance">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_cumulative_building_solar_irradiance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_cumulative_building_solar_irradiance</span><span class="p">(</span>
    <span class="n">voxel_data</span><span class="p">,</span>
    <span class="n">meshsize</span><span class="p">,</span>
    <span class="n">building_svf_mesh</span><span class="p">,</span>
    <span class="n">weather_df</span><span class="p">,</span>
    <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate cumulative solar irradiance on building surfaces over a time period.</span>
<span class="sd">    Uses the Numba-accelerated get_building_solar_irradiance for each time step.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values.</span>
<span class="sd">        meshsize (float): Size of each voxel in meters.</span>
<span class="sd">        building_svf_mesh (trimesh.Trimesh): Mesh with pre-calculated SVF in metadata.</span>
<span class="sd">        weather_df (DataFrame): Weather data with DNI (W/m²) and DHI (W/m²).</span>
<span class="sd">        lon (float): Longitude in degrees.</span>
<span class="sd">        lat (float): Latitude in degrees.</span>
<span class="sd">        tz (float): Timezone offset in hours.</span>
<span class="sd">        **kwargs: Additional parameters for time range, scaling, OBJ export, etc.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        trimesh.Trimesh: A mesh with cumulative (Wh/m²) irradiance in metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pytz</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
    
    <span class="n">period_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;period_start&quot;</span><span class="p">,</span> <span class="s2">&quot;01-01 00:00:00&quot;</span><span class="p">)</span>
    <span class="n">period_end</span>   <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;period_end&quot;</span><span class="p">,</span>   <span class="s2">&quot;12-31 23:59:59&quot;</span><span class="p">)</span>
    <span class="n">time_step_hours</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time_step_hours&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">direct_normal_irradiance_scaling</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;direct_normal_irradiance_scaling&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">diffuse_irradiance_scaling</span>       <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;diffuse_irradiance_scaling&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    
    <span class="c1"># Parse times, create local tz</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">start_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">period_start</span><span class="p">,</span> <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="n">end_dt</span>   <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">period_end</span><span class="p">,</span>   <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time must be in format &#39;MM-DD HH:MM:SS&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ve</span>
    
    <span class="n">offset_minutes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tz</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">local_tz</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">FixedOffset</span><span class="p">(</span><span class="n">offset_minutes</span><span class="p">)</span>
    
    <span class="c1"># Filter weather_df</span>
    <span class="n">df_period</span> <span class="o">=</span> <span class="n">weather_df</span><span class="p">[</span>
        <span class="p">((</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">&gt;</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">|</span>
         <span class="p">((</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">&amp;</span>
          <span class="p">(</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">day</span> <span class="o">&gt;=</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span> <span class="o">&amp;</span>
          <span class="p">(</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">&gt;=</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)))</span> <span class="o">&amp;</span>
        <span class="p">((</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">&lt;</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">|</span>
         <span class="p">((</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">&amp;</span>
          <span class="p">(</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">day</span> <span class="o">&lt;=</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span> <span class="o">&amp;</span>
          <span class="p">(</span><span class="n">weather_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">&lt;=</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)))</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">df_period</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No weather data in specified period.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Convert to local time, then to UTC</span>
    <span class="n">df_period_local</span> <span class="o">=</span> <span class="n">df_period</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">local_tz</span><span class="p">)</span>
    <span class="n">df_period_utc</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">UTC</span><span class="p">)</span>
    
    <span class="c1"># Get solar positions</span>
    <span class="c1"># You presumably have a get_solar_positions_astral(...) that returns az/elev</span>
    <span class="n">solar_positions</span> <span class="o">=</span> <span class="n">get_solar_positions_astral</span><span class="p">(</span><span class="n">df_period_utc</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
    
    <span class="c1"># Prepare arrays for accumulation</span>
    <span class="n">n_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="n">face_cum_direct</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">face_cum_diffuse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">face_cum_global</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    
    <span class="n">boundary_mask</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Iterate over each timestep</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">time_utc</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df_period_utc</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()):</span>
        <span class="n">DNI</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;DNI&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">direct_normal_irradiance_scaling</span>
        <span class="n">DHI</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;DHI&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">diffuse_irradiance_scaling</span>
        
        <span class="c1"># Sun angles</span>
        <span class="n">az_deg</span> <span class="o">=</span> <span class="n">solar_positions</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">time_utc</span><span class="p">,</span> <span class="s1">&#39;azimuth&#39;</span><span class="p">]</span>
        <span class="n">el_deg</span> <span class="o">=</span> <span class="n">solar_positions</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">time_utc</span><span class="p">,</span> <span class="s1">&#39;elevation&#39;</span><span class="p">]</span>
        
        <span class="c1"># Skip if sun below horizon</span>
        <span class="k">if</span> <span class="n">el_deg</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Call instantaneous function (Numba-accelerated inside)</span>
        <span class="n">irr_mesh</span> <span class="o">=</span> <span class="n">get_building_solar_irradiance</span><span class="p">(</span>
            <span class="n">voxel_data</span><span class="p">,</span>
            <span class="n">meshsize</span><span class="p">,</span>
            <span class="n">building_svf_mesh</span><span class="p">,</span>
            <span class="n">az_deg</span><span class="p">,</span>
            <span class="n">el_deg</span><span class="p">,</span>
            <span class="n">DNI</span><span class="p">,</span>
            <span class="n">DHI</span><span class="p">,</span>
            <span class="n">show_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># or any other flags</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
        <span class="c1"># Extract arrays</span>
        <span class="n">face_dir</span>  <span class="o">=</span> <span class="n">irr_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;direct&#39;</span><span class="p">]</span>
        <span class="n">face_diff</span> <span class="o">=</span> <span class="n">irr_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;diffuse&#39;</span><span class="p">]</span>
        <span class="n">face_glob</span> <span class="o">=</span> <span class="n">irr_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;global&#39;</span><span class="p">]</span>
        
        <span class="c1"># If first time, note boundary mask from NaNs</span>
        <span class="k">if</span> <span class="n">boundary_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">boundary_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">face_glob</span><span class="p">)</span>
        
        <span class="c1"># Convert from W/m² to Wh/m² by multiplying time_step_hours</span>
        <span class="n">face_cum_direct</span>  <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">face_dir</span><span class="p">)</span>  <span class="o">*</span> <span class="n">time_step_hours</span>
        <span class="n">face_cum_diffuse</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">face_diff</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_step_hours</span>
        <span class="n">face_cum_global</span>  <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">face_glob</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_step_hours</span>
    
    <span class="c1"># Reapply NaN for boundary</span>
    <span class="k">if</span> <span class="n">boundary_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">face_cum_direct</span><span class="p">[</span><span class="n">boundary_mask</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">face_cum_diffuse</span><span class="p">[</span><span class="n">boundary_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">face_cum_global</span><span class="p">[</span><span class="n">boundary_mask</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="c1"># Create a new mesh with cumulative results</span>
    <span class="n">cumulative_mesh</span> <span class="o">=</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cumulative_mesh</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">):</span>
        <span class="n">cumulative_mesh</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="c1"># If original mesh had SVF</span>
    <span class="k">if</span> <span class="s1">&#39;svf&#39;</span> <span class="ow">in</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
        <span class="n">cumulative_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;svf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;svf&#39;</span><span class="p">]</span>
    
    <span class="n">cumulative_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;direct&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">face_cum_direct</span>
    <span class="n">cumulative_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;diffuse&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">face_cum_diffuse</span>
    <span class="n">cumulative_mesh</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;global&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">face_cum_global</span>
    
    <span class="n">cumulative_mesh</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Cumulative Solar Irradiance (Wh/m²)&quot;</span>
    
    <span class="c1"># Optional export</span>
    <span class="c1"># obj_export = kwargs.get(&quot;obj_export&quot;, False)</span>
    <span class="c1"># if obj_export:</span>
    <span class="c1">#     _export_solar_irradiance_mesh(</span>
    <span class="c1">#         cumulative_mesh,</span>
    <span class="c1">#         face_cum_global,</span>
    <span class="c1">#         **kwargs</span>
    <span class="c1">#     )</span>
    
    <span class="k">return</span> <span class="n">cumulative_mesh</span></div>


<div class="viewcode-block" id="get_building_global_solar_irradiance_using_epw">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.get_building_global_solar_irradiance_using_epw">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_building_global_solar_irradiance_using_epw</span><span class="p">(</span>
    <span class="n">voxel_data</span><span class="p">,</span>
    <span class="n">meshsize</span><span class="p">,</span>
    <span class="n">calc_type</span><span class="o">=</span><span class="s1">&#39;instantaneous&#39;</span><span class="p">,</span>
    <span class="n">direct_normal_irradiance_scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">diffuse_irradiance_scaling</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute global solar irradiance on building surfaces using EPW weather data, either for a single time or cumulatively.</span>

<span class="sd">    The function:</span>
<span class="sd">    1. Optionally downloads and reads EPW weather data</span>
<span class="sd">    2. Handles timezone conversions and solar position calculations</span>
<span class="sd">    3. Computes either instantaneous or cumulative irradiance on building surfaces</span>
<span class="sd">    4. Supports visualization and export options</span>

<span class="sd">    Args:</span>
<span class="sd">        voxel_data (ndarray): 3D array of voxel values.</span>
<span class="sd">        meshsize (float): Size of each voxel in meters.</span>
<span class="sd">        building_svf_mesh (trimesh.Trimesh): Building mesh with pre-calculated SVF values in metadata.</span>
<span class="sd">        calc_type (str): &#39;instantaneous&#39; or &#39;cumulative&#39;.</span>
<span class="sd">        direct_normal_irradiance_scaling (float): Scaling factor for direct normal irradiance.</span>
<span class="sd">        diffuse_irradiance_scaling (float): Scaling factor for diffuse horizontal irradiance.</span>
<span class="sd">        **kwargs: Additional arguments including:</span>
<span class="sd">            - download_nearest_epw (bool): Whether to download nearest EPW file</span>
<span class="sd">            - epw_file_path (str): Path to EPW file</span>
<span class="sd">            - rectangle_vertices (list): List of (lon,lat) coordinates for EPW download</span>
<span class="sd">            - output_dir (str): Directory for EPW download</span>
<span class="sd">            - calc_time (str): Time for instantaneous calculation (&#39;MM-DD HH:MM:SS&#39;)</span>
<span class="sd">            - period_start (str): Start time for cumulative calculation (&#39;MM-DD HH:MM:SS&#39;)</span>
<span class="sd">            - period_end (str): End time for cumulative calculation (&#39;MM-DD HH:MM:SS&#39;)</span>
<span class="sd">            - time_step_hours (float): Time step for cumulative calculation</span>
<span class="sd">            - tree_k (float): Tree extinction coefficient</span>
<span class="sd">            - tree_lad (float): Leaf area density in m^-1</span>
<span class="sd">            - show_each_timestep (bool): Whether to show plots for each timestep</span>
<span class="sd">            - nan_color (str): Color for NaN values in visualization</span>
<span class="sd">            - colormap (str): Matplotlib colormap name</span>
<span class="sd">            - vmin (float): Minimum value for colormap</span>
<span class="sd">            - vmax (float): Maximum value for colormap</span>
<span class="sd">            - obj_export (bool): Whether to export as OBJ file</span>
<span class="sd">            - output_directory (str): Directory for OBJ export</span>
<span class="sd">            - output_file_name (str): Filename for OBJ export</span>
<span class="sd">            - save_mesh (bool): Whether to save the mesh data using pickle</span>
<span class="sd">            - mesh_output_path (str): Path to save the mesh data (if save_mesh is True)</span>

<span class="sd">    Returns:</span>
<span class="sd">        trimesh.Trimesh: Building mesh with irradiance values stored in metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pytz</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
    
    <span class="c1"># Get EPW file</span>
    <span class="n">download_nearest_epw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;download_nearest_epw&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">rectangle_vertices</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rectangle_vertices&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">epw_file_path</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epw_file_path&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">building_id_grid</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;building_id_grid&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">download_nearest_epw</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rectangle_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rectangle_vertices is required to download nearest EPW file&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate center point of rectangle</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">rectangle_vertices</span><span class="p">]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">rectangle_vertices</span><span class="p">]</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">lons</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            
            <span class="c1"># Optional: specify maximum distance in kilometers</span>
            <span class="n">max_distance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_distance&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># None for no limit</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_dir&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">)</span>

            <span class="n">epw_file_path</span><span class="p">,</span> <span class="n">weather_data</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">get_nearest_epw_from_climate_onebuilding</span><span class="p">(</span>
                <span class="n">longitude</span><span class="o">=</span><span class="n">center_lon</span><span class="p">,</span>
                <span class="n">latitude</span><span class="o">=</span><span class="n">center_lat</span><span class="p">,</span>
                <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span>
                <span class="n">max_distance</span><span class="o">=</span><span class="n">max_distance</span><span class="p">,</span>
                <span class="n">extract_zip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">load_data</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

    <span class="c1"># Read EPW data</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">elevation_m</span> <span class="o">=</span> <span class="n">read_epw_for_solar_simulation</span><span class="p">(</span><span class="n">epw_file_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No data in EPW file.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Step 1: Calculate Sky View Factor for building surfaces</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing Sky View Factor for building surfaces...&quot;</span><span class="p">)</span>
    <span class="n">building_svf_mesh</span> <span class="o">=</span> <span class="n">get_surface_view_factor</span><span class="p">(</span>
        <span class="n">voxel_data</span><span class="p">,</span>  <span class="c1"># Your 3D voxel grid</span>
        <span class="n">meshsize</span><span class="p">,</span>      <span class="c1"># Size of each voxel in meters</span>
        <span class="n">value_name</span> <span class="o">=</span> <span class="s1">&#39;svf&#39;</span><span class="p">,</span>
        <span class="n">target_values</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
        <span class="n">inclusion_mode</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">building_id_grid</span><span class="o">=</span><span class="n">building_id_grid</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing Solar Irradiance for building surfaces...&quot;</span><span class="p">)</span>
    <span class="n">result_mesh</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">calc_type</span> <span class="o">==</span> <span class="s1">&#39;instantaneous&#39;</span><span class="p">:</span>
        <span class="n">calc_time</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;calc_time&quot;</span><span class="p">,</span> <span class="s2">&quot;01-01 12:00:00&quot;</span><span class="p">)</span>

        <span class="c1"># Parse calculation time without year</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">calc_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">calc_time</span><span class="p">,</span> <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;calc_time must be in format &#39;MM-DD HH:MM:SS&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ve</span>

        <span class="n">df_period</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="n">calc_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">day</span> <span class="o">==</span> <span class="n">calc_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">==</span> <span class="n">calc_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">df_period</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No EPW data at the specified time.&quot;</span><span class="p">)</span>

        <span class="c1"># Prepare timezone conversion</span>
        <span class="n">offset_minutes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tz</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
        <span class="n">local_tz</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">FixedOffset</span><span class="p">(</span><span class="n">offset_minutes</span><span class="p">)</span>
        <span class="n">df_period_local</span> <span class="o">=</span> <span class="n">df_period</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">local_tz</span><span class="p">)</span>
        <span class="n">df_period_utc</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">UTC</span><span class="p">)</span>

        <span class="c1"># Compute solar positions</span>
        <span class="n">solar_positions</span> <span class="o">=</span> <span class="n">get_solar_positions_astral</span><span class="p">(</span><span class="n">df_period_utc</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        
        <span class="c1"># Scale irradiance values</span>
        <span class="n">direct_normal_irradiance</span> <span class="o">=</span> <span class="n">df_period_utc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;DNI&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">direct_normal_irradiance_scaling</span>
        <span class="n">diffuse_irradiance</span> <span class="o">=</span> <span class="n">df_period_utc</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;DHI&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">diffuse_irradiance_scaling</span>
        
        <span class="c1"># Get solar position</span>
        <span class="n">azimuth_degrees</span> <span class="o">=</span> <span class="n">solar_positions</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;azimuth&#39;</span><span class="p">]</span>
        <span class="n">elevation_degrees</span> <span class="o">=</span> <span class="n">solar_positions</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;elevation&#39;</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time: </span><span class="si">{</span><span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sun position: Azimuth </span><span class="si">{</span><span class="n">azimuth_degrees</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">°, Elevation </span><span class="si">{</span><span class="n">elevation_degrees</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">°&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DNI: </span><span class="si">{</span><span class="n">direct_normal_irradiance</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> W/m², DHI: </span><span class="si">{</span><span class="n">diffuse_irradiance</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> W/m²&quot;</span><span class="p">)</span>
        
        <span class="c1"># Skip if sun is below horizon</span>
        <span class="k">if</span> <span class="n">elevation_degrees</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sun is below horizon, skipping calculation.&quot;</span><span class="p">)</span>
            <span class="n">result_mesh</span> <span class="o">=</span> <span class="n">building_svf_mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute irradiance</span>
            <span class="n">result_mesh</span> <span class="o">=</span> <span class="n">get_building_solar_irradiance</span><span class="p">(</span>
                <span class="n">voxel_data</span><span class="p">,</span>
                <span class="n">meshsize</span><span class="p">,</span>
                <span class="n">building_svf_mesh</span><span class="p">,</span>
                <span class="n">azimuth_degrees</span><span class="p">,</span>
                <span class="n">elevation_degrees</span><span class="p">,</span>
                <span class="n">direct_normal_irradiance</span><span class="p">,</span>
                <span class="n">diffuse_irradiance</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

    <span class="k">elif</span> <span class="n">calc_type</span> <span class="o">==</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">:</span>
        <span class="c1"># Set default parameters</span>
        <span class="n">period_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;period_start&quot;</span><span class="p">,</span> <span class="s2">&quot;01-01 00:00:00&quot;</span><span class="p">)</span>
        <span class="n">period_end</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;period_end&quot;</span><span class="p">,</span> <span class="s2">&quot;12-31 23:59:59&quot;</span><span class="p">)</span>
        <span class="n">time_step_hours</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time_step_hours&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        
        <span class="c1"># Parse start and end times without year</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">period_start</span><span class="p">,</span> <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
            <span class="n">end_dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">period_end</span><span class="p">,</span> <span class="s2">&quot;%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time must be in format &#39;MM-DD HH:MM:SS&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">ve</span>
        
        <span class="c1"># Create local timezone</span>
        <span class="n">offset_minutes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tz</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
        <span class="n">local_tz</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">FixedOffset</span><span class="p">(</span><span class="n">offset_minutes</span><span class="p">)</span>
        
        <span class="c1"># Filter weather data by month, day, hour</span>
        <span class="n">df_period</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span>
            <span class="p">((</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">&gt;</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">|</span> 
             <span class="p">((</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">day</span> <span class="o">&gt;=</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span> <span class="o">&amp;</span> 
              <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">&gt;=</span> <span class="n">start_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)))</span> <span class="o">&amp;</span>
            <span class="p">((</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">&lt;</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">|</span> 
             <span class="p">((</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">month</span> <span class="o">==</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">month</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">day</span> <span class="o">&lt;=</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">day</span><span class="p">)</span> <span class="o">&amp;</span> 
              <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">hour</span> <span class="o">&lt;=</span> <span class="n">end_dt</span><span class="o">.</span><span class="n">hour</span><span class="p">)))</span>
        <span class="p">]</span>
        
        <span class="k">if</span> <span class="n">df_period</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No weather data available for the specified period.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Convert to local timezone and then to UTC for solar position calculation</span>
        <span class="n">df_period_local</span> <span class="o">=</span> <span class="n">df_period</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">local_tz</span><span class="p">)</span>
        <span class="n">df_period_utc</span> <span class="o">=</span> <span class="n">df_period_local</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">UTC</span><span class="p">)</span>
        
        <span class="c1"># Get solar positions for all times</span>
        <span class="n">solar_positions</span> <span class="o">=</span> <span class="n">get_solar_positions_astral</span><span class="p">(</span><span class="n">df_period_utc</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        
        <span class="c1"># Create a copy of kwargs without time_step_hours to avoid duplicate argument</span>
        <span class="n">kwargs_copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;time_step_hours&#39;</span> <span class="ow">in</span> <span class="n">kwargs_copy</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">kwargs_copy</span><span class="p">[</span><span class="s1">&#39;time_step_hours&#39;</span><span class="p">]</span>
        
        <span class="c1"># Get cumulative irradiance - adapt to match expected function signature</span>
        <span class="n">result_mesh</span> <span class="o">=</span> <span class="n">get_cumulative_building_solar_irradiance</span><span class="p">(</span>
            <span class="n">voxel_data</span><span class="p">,</span>
            <span class="n">meshsize</span><span class="p">,</span>
            <span class="n">building_svf_mesh</span><span class="p">,</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span>  <span class="c1"># Pass only the required 7 positional arguments</span>
            <span class="n">period_start</span><span class="o">=</span><span class="n">period_start</span><span class="p">,</span>
            <span class="n">period_end</span><span class="o">=</span><span class="n">period_end</span><span class="p">,</span>
            <span class="n">time_step_hours</span><span class="o">=</span><span class="n">time_step_hours</span><span class="p">,</span>
            <span class="n">direct_normal_irradiance_scaling</span><span class="o">=</span><span class="n">direct_normal_irradiance_scaling</span><span class="p">,</span>
            <span class="n">diffuse_irradiance_scaling</span><span class="o">=</span><span class="n">diffuse_irradiance_scaling</span><span class="p">,</span>
            <span class="n">colormap</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;colormap&#39;</span><span class="p">,</span> <span class="s1">&#39;jet&#39;</span><span class="p">),</span>
            <span class="n">show_each_timestep</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;show_each_timestep&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">obj_export</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;obj_export&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
            <span class="n">output_directory</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output_directory&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">),</span>
            <span class="n">output_file_name</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output_file_name&#39;</span><span class="p">,</span> <span class="s1">&#39;cumulative_solar&#39;</span><span class="p">)</span>
        <span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;calc_type must be either &#39;instantaneous&#39; or &#39;cumulative&#39;&quot;</span><span class="p">)</span>
    
    <span class="c1"># Save mesh data if requested</span>
    <span class="n">save_mesh</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;save_mesh&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_mesh</span><span class="p">:</span>
        <span class="n">mesh_output_path</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mesh_output_path&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh_output_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Generate default path if none provided</span>
            <span class="n">output_directory</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_directory&quot;</span><span class="p">,</span> <span class="s2">&quot;output&quot;</span><span class="p">)</span>
            <span class="n">output_file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_file_name&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">calc_type</span><span class="si">}</span><span class="s2">_solar_irradiance&quot;</span><span class="p">)</span>
            <span class="n">mesh_output_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_directory</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">output_file_name</span><span class="si">}</span><span class="s2">.pkl&quot;</span>
        
        <span class="n">save_irradiance_mesh</span><span class="p">(</span><span class="n">result_mesh</span><span class="p">,</span> <span class="n">mesh_output_path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved irradiance mesh data to: </span><span class="si">{</span><span class="n">mesh_output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result_mesh</span></div>


<div class="viewcode-block" id="save_irradiance_mesh">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.save_irradiance_mesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">save_irradiance_mesh</span><span class="p">(</span><span class="n">irradiance_mesh</span><span class="p">,</span> <span class="n">output_file_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save the irradiance mesh data to a file using pickle serialization.</span>
<span class="sd">    </span>
<span class="sd">    This function provides persistent storage for computed irradiance results,</span>
<span class="sd">    enabling reuse of expensive calculations and sharing of results between</span>
<span class="sd">    analysis sessions. The mesh data includes all geometry, irradiance values,</span>
<span class="sd">    and metadata required for visualization and further analysis.</span>
<span class="sd">    </span>
<span class="sd">    Serialization Benefits:</span>
<span class="sd">    - Preserves complete mesh structure with all computed data</span>
<span class="sd">    - Enables offline analysis and visualization workflows</span>
<span class="sd">    - Supports sharing results between different tools and users</span>
<span class="sd">    - Avoids recomputation of expensive irradiance calculations</span>
<span class="sd">    </span>
<span class="sd">    Data Preservation:</span>
<span class="sd">    - All mesh geometry (vertices, faces, normals)</span>
<span class="sd">    - Computed irradiance values (direct, diffuse, global)</span>
<span class="sd">    - Sky View Factor data and other metadata</span>
<span class="sd">    - Material properties and visualization settings</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        irradiance_mesh (trimesh.Trimesh): Mesh with irradiance data in metadata</span>
<span class="sd">                                          Should contain computed irradiance results</span>
<span class="sd">        output_file_path (str): Path to save the mesh data file</span>
<span class="sd">                               Recommended extension: .pkl for clarity</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The function automatically creates the output directory if it doesn&#39;t exist.</span>
<span class="sd">        Use pickle format for maximum compatibility with Python data structures.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

    <span class="c1"># Create output directory structure if it doesn&#39;t exist</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">output_file_path</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Serialize mesh data using pickle for complete data preservation</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">irradiance_mesh</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_irradiance_mesh">
<a class="viewcode-back" href="../../../autoapi/voxcity/simulator/solar/index.html#voxcity.simulator.load_irradiance_mesh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_irradiance_mesh</span><span class="p">(</span><span class="n">input_file_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load previously saved irradiance mesh data from a file.</span>
<span class="sd">    </span>
<span class="sd">    This function restores complete mesh data including geometry, computed</span>
<span class="sd">    irradiance values, and all associated metadata. It enables continuation</span>
<span class="sd">    of analysis workflows and reuse of expensive computation results.</span>
<span class="sd">    </span>
<span class="sd">    Restoration Capabilities:</span>
<span class="sd">    - Complete mesh geometry with all topological information</span>
<span class="sd">    - All computed irradiance data (direct, diffuse, global components)</span>
<span class="sd">    - Sky View Factor values and analysis metadata</span>
<span class="sd">    - Visualization settings and material properties</span>
<span class="sd">    </span>
<span class="sd">    Workflow Integration:</span>
<span class="sd">    - Load results from previous analysis sessions</span>
<span class="sd">    - Share computed data between team members</span>
<span class="sd">    - Perform post-processing and visualization</span>
<span class="sd">    - Compare results from different scenarios</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        input_file_path (str): Path to the saved mesh data file</span>
<span class="sd">                              Should be a file created by save_irradiance_mesh()</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        trimesh.Trimesh: Complete mesh with all irradiance data in metadata</span>
<span class="sd">                        Ready for visualization, analysis, or further processing</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        The loaded mesh maintains all original data structure and can be used</span>
<span class="sd">        immediately for visualization or additional analysis operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
    
    <span class="c1"># Deserialize mesh data preserving all original structure</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">input_file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">irradiance_mesh</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">irradiance_mesh</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Kunihiko Fujiwara
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=8a448e45"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>
voxcity.simulator.solar
=======================

.. py:module:: voxcity.simulator.solar

.. autoapi-nested-parse::

   Solar Irradiance Simulation Module

   This module provides comprehensive solar irradiance calculations for urban environments,
   including direct and diffuse solar radiation analysis with consideration for tree transmittance
   and building shadows. It supports both instantaneous and cumulative irradiance calculations
   using weather data from EPW files.

   Key Features:
   - Direct solar irradiance with ray tracing and shadow analysis
   - Diffuse solar irradiance using Sky View Factor (SVF)
   - Tree transmittance modeling using Beer-Lambert law
   - Building surface irradiance calculation with 3D mesh support
   - Weather data integration from EPW files
   - Visualization and export capabilities

   The module uses numba for performance optimization in computationally intensive calculations.



Functions
---------

.. autoapisummary::

   voxcity.simulator.solar.compute_direct_solar_irradiance_map_binary
   voxcity.simulator.solar.get_direct_solar_irradiance_map
   voxcity.simulator.solar.get_diffuse_solar_irradiance_map
   voxcity.simulator.solar.get_global_solar_irradiance_map
   voxcity.simulator.solar.get_solar_positions_astral
   voxcity.simulator.solar.get_cumulative_global_solar_irradiance
   voxcity.simulator.solar.get_global_solar_irradiance_using_epw
   voxcity.simulator.solar.compute_solar_irradiance_for_all_faces
   voxcity.simulator.solar.get_building_solar_irradiance
   voxcity.simulator.solar.get_cumulative_building_solar_irradiance
   voxcity.simulator.solar.get_building_global_solar_irradiance_using_epw
   voxcity.simulator.solar.save_irradiance_mesh
   voxcity.simulator.solar.load_irradiance_mesh


Module Contents
---------------

.. py:function:: compute_direct_solar_irradiance_map_binary(voxel_data, sun_direction, view_point_height, hit_values, meshsize, tree_k, tree_lad, inclusion_mode)

   Compute a map of direct solar irradiation accounting for tree transmittance.

   This function performs ray tracing from observer positions on the ground surface
   towards the sun to determine direct solar irradiance at each location. It accounts
   for shadows cast by buildings and vegetation, with special consideration for
   tree transmittance using the Beer-Lambert law.

   The function:
   1. Places observers at valid locations (empty voxels above ground)
   2. Casts rays from each observer in the sun direction
   3. Computes transmittance through trees using Beer-Lambert law
   4. Returns a 2D map of transmittance values

   Observer Placement Rules:
   - Observers are placed in empty voxels (value 0 or -2 for trees) above solid ground
   - Observers are NOT placed on buildings, vegetation, or water surfaces
   - Observer height is added above the detected ground surface

   Ray Tracing Process:
   - Rays are cast from each valid observer position toward the sun
   - Intersections with obstacles (non-sky voxels) are detected
   - Tree voxels provide partial transmittance rather than complete blocking
   - Final transmittance value represents solar energy reaching the surface

   :param voxel_data: 3D array of voxel values representing the urban environment.
                      Common values: 0=sky, 1-6=buildings, 7-9=special surfaces, -2=trees
   :type voxel_data: ndarray
   :param sun_direction: Direction vector of the sun (dx, dy, dz), should be normalized
   :type sun_direction: tuple
   :param view_point_height: Observer height above ground surface in meters
   :type view_point_height: float
   :param hit_values: Values considered non-obstacles if inclusion_mode=False
                      Typically (0,) meaning only sky voxels are transparent
   :type hit_values: tuple
   :param meshsize: Size of each voxel in meters (spatial resolution)
   :type meshsize: float
   :param tree_k: Tree extinction coefficient for Beer-Lambert law (higher = more opaque)
   :type tree_k: float
   :param tree_lad: Leaf area density in m^-1 (affects light attenuation through trees)
   :type tree_lad: float
   :param inclusion_mode: False here, meaning any voxel not in hit_values is an obstacle
   :type inclusion_mode: bool

   :returns:

             2D array of transmittance values (0.0-1.0)
                     - 1.0 = full sun exposure
                     - 0.0 = complete shadow
                     - 0.0-1.0 = partial transmittance through trees
                     - NaN = invalid observer position (cannot place observer)
   :rtype: ndarray

   .. note::

      The returned map is vertically flipped to match standard visualization conventions
      where the origin is at the bottom-left corner.


.. py:function:: get_direct_solar_irradiance_map(voxel_data, meshsize, azimuth_degrees_ori, elevation_degrees, direct_normal_irradiance, show_plot=False, **kwargs)

   Compute direct solar irradiance map with tree transmittance.

   This function converts solar angles to a 3D direction vector, computes the binary
   transmittance map using ray tracing, and scales the results by actual solar irradiance
   values to produce physically meaningful irradiance measurements.

   Solar Geometry:
   - Azimuth: Horizontal angle measured from North (0°) clockwise to East (90°)
   - Elevation: Vertical angle above the horizon (0° = horizon, 90° = zenith)
   - The coordinate system is adjusted by 180° to match the voxel grid orientation

   Physics Background:
   - Direct Normal Irradiance (DNI): Solar energy on a surface perpendicular to sun rays
   - Horizontal irradiance: DNI scaled by sine of elevation angle
   - Tree transmittance: Applied using Beer-Lambert law for realistic light attenuation

   The function:
   1. Converts sun angles to direction vector using spherical coordinates
   2. Computes binary transmittance map accounting for shadows and tree effects
   3. Scales by direct normal irradiance and sun elevation for horizontal surfaces
   4. Optionally visualizes and exports results in various formats

   :param voxel_data: 3D array of voxel values representing the urban environment
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters (spatial resolution)
   :type meshsize: float
   :param azimuth_degrees_ori: Sun azimuth angle in degrees (0° = North, 90° = East)
   :type azimuth_degrees_ori: float
   :param elevation_degrees: Sun elevation angle in degrees above horizon (0-90°)
   :type elevation_degrees: float
   :param direct_normal_irradiance: Direct normal irradiance in W/m² (from weather data)
   :type direct_normal_irradiance: float
   :param show_plot: Whether to display visualization of results
   :type show_plot: bool
   :param \*\*kwargs: Additional arguments including:
                      - view_point_height (float): Observer height in meters (default: 1.5)
                          Height above ground where irradiance is measured
                      - colormap (str): Matplotlib colormap name for visualization (default: 'magma')
                      - vmin (float): Minimum value for colormap scaling
                      - vmax (float): Maximum value for colormap scaling
                      - tree_k (float): Tree extinction coefficient (default: 0.6)
                          Higher values mean trees block more light
                      - tree_lad (float): Leaf area density in m^-1 (default: 1.0)
                          Affects light attenuation through tree canopies
                      - obj_export (bool): Whether to export results as 3D OBJ file
                      - output_directory (str): Directory for file exports
                      - output_file_name (str): Base filename for exports
                      - dem_grid (ndarray): Digital elevation model for 3D export
                      - num_colors (int): Number of discrete colors for OBJ export
                      - alpha (float): Transparency value for 3D visualization

   :returns:

             2D array of direct solar irradiance values in W/m²
                     - Values represent energy flux on horizontal surfaces
                     - NaN indicates invalid measurement locations
                     - Range typically 0 to direct_normal_irradiance * sin(elevation)
   :rtype: ndarray

   .. note::

      The azimuth is internally adjusted by 180° to match the coordinate system
      where the voxel grid's y-axis points in the opposite direction from geographic north.


.. py:function:: get_diffuse_solar_irradiance_map(voxel_data, meshsize, diffuse_irradiance=1.0, show_plot=False, **kwargs)

   Compute diffuse solar irradiance map using the Sky View Factor (SVF) with tree transmittance.

   This function calculates the diffuse component of solar radiation, which consists of
   sunlight scattered by the atmosphere and reaches surfaces from all directions across
   the sky hemisphere. The calculation is based on the Sky View Factor (SVF), which
   quantifies how much of the sky dome is visible from each location.

   Physics Background:
   - Diffuse radiation: Solar energy scattered by atmospheric particles and clouds
   - Sky View Factor (SVF): Fraction of sky hemisphere visible from a point (0.0 to 1.0)
   - Isotropic sky model: Assumes uniform diffuse radiation distribution across the sky
   - Tree effects: Partial transmittance through canopies reduces effective sky visibility

   SVF Characteristics:
   - SVF = 1.0: Completely open sky (maximum diffuse radiation)
   - SVF = 0.0: Completely blocked sky (no diffuse radiation)
   - SVF = 0.5: Half of sky visible (typical for urban canyons)
   - Trees reduce SVF through partial light attenuation rather than complete blocking

   The function:
   1. Computes SVF map accounting for building shadows and tree transmittance
   2. Scales SVF by diffuse horizontal irradiance from weather data
   3. Optionally visualizes and exports results for analysis

   :param voxel_data: 3D array of voxel values representing the urban environment
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters (spatial resolution)
   :type meshsize: float
   :param diffuse_irradiance: Diffuse horizontal irradiance in W/m² (from weather data)
                              Default 1.0 for normalized calculations
   :type diffuse_irradiance: float
   :param show_plot: Whether to display visualization of results
   :type show_plot: bool
   :param \*\*kwargs: Additional arguments including:
                      - view_point_height (float): Observer height in meters (default: 1.5)
                          Height above ground where measurements are taken
                      - colormap (str): Matplotlib colormap name for visualization (default: 'magma')
                      - vmin (float): Minimum value for colormap scaling
                      - vmax (float): Maximum value for colormap scaling
                      - tree_k (float): Tree extinction coefficient for transmittance calculations
                          Higher values mean trees block more diffuse light
                      - tree_lad (float): Leaf area density in m^-1
                          Affects light attenuation through tree canopies
                      - obj_export (bool): Whether to export results as 3D OBJ file
                      - output_directory (str): Directory for file exports
                      - output_file_name (str): Base filename for exports
                      - dem_grid (ndarray): Digital elevation model for 3D export
                      - num_colors (int): Number of discrete colors for OBJ export
                      - alpha (float): Transparency value for 3D visualization

   :returns:

             2D array of diffuse solar irradiance values in W/m²
                     - Values represent diffuse energy flux on horizontal surfaces
                     - Range: 0.0 to diffuse_irradiance (input parameter)
                     - NaN indicates invalid measurement locations
   :rtype: ndarray

   .. note::

      The SVF calculation internally handles tree transmittance effects, so trees
      contribute partial sky visibility rather than complete obstruction.


.. py:function:: get_global_solar_irradiance_map(voxel_data, meshsize, azimuth_degrees, elevation_degrees, direct_normal_irradiance, diffuse_irradiance, show_plot=False, **kwargs)

   Compute global solar irradiance (direct + diffuse) on a horizontal plane at each valid observer location.

   This function combines both direct and diffuse components of solar radiation to calculate
   the total solar irradiance at each location. Global horizontal irradiance (GHI) is the
   most commonly used metric for solar energy assessment and represents the total solar
   energy available on a horizontal surface.

   Global Irradiance Components:
   - Direct component: Solar radiation from the sun's disk, affected by shadows and obstacles
   - Diffuse component: Solar radiation scattered by the atmosphere, affected by sky view
   - Total irradiance: Sum of direct and diffuse components at each location

   Physical Considerations:
   - Direct radiation varies with sun position and local obstructions
   - Diffuse radiation varies with sky visibility (Sky View Factor)
   - Both components are affected by tree transmittance using Beer-Lambert law
   - Invalid locations (e.g., on water, buildings) are marked as NaN

   The function:
   1. Computes direct solar irradiance map accounting for sun position and shadows
   2. Computes diffuse solar irradiance map based on Sky View Factor
   3. Combines maps and optionally visualizes/exports results for analysis

   :param voxel_data: 3D voxel array representing the urban environment
   :type voxel_data: ndarray
   :param meshsize: Voxel size in meters (spatial resolution)
   :type meshsize: float
   :param azimuth_degrees: Sun azimuth angle in degrees (0° = North, 90° = East)
   :type azimuth_degrees: float
   :param elevation_degrees: Sun elevation angle in degrees above horizon (0-90°)
   :type elevation_degrees: float
   :param direct_normal_irradiance: Direct normal irradiance in W/m² (from weather data)
   :type direct_normal_irradiance: float
   :param diffuse_irradiance: Diffuse horizontal irradiance in W/m² (from weather data)
   :type diffuse_irradiance: float
   :param show_plot: Whether to display visualization of results
   :type show_plot: bool
   :param \*\*kwargs: Additional arguments including:
                      - view_point_height (float): Observer height in meters (default: 1.5)
                          Height above ground where measurements are taken
                      - colormap (str): Matplotlib colormap name for visualization (default: 'magma')
                      - vmin (float): Minimum value for colormap scaling
                      - vmax (float): Maximum value for colormap scaling
                      - tree_k (float): Tree extinction coefficient for transmittance calculations
                          Higher values mean trees block more light
                      - tree_lad (float): Leaf area density in m^-1
                          Affects light attenuation through tree canopies
                      - obj_export (bool): Whether to export results as 3D OBJ file
                      - output_directory (str): Directory for file exports
                      - output_file_name (str): Base filename for exports
                      - dem_grid (ndarray): Digital elevation model for 3D export
                      - num_colors (int): Number of discrete colors for OBJ export
                      - alpha (float): Transparency value for 3D visualization

   :returns:

             2D array of global solar irradiance values in W/m²
                     - Values represent total solar energy flux on horizontal surfaces
                     - Range: 0.0 to (direct_normal_irradiance * sin(elevation) + diffuse_irradiance)
                     - NaN indicates invalid measurement locations
   :rtype: ndarray

   .. note::

      Global irradiance is the standard metric used for solar energy assessment
      and represents the maximum solar energy available at each location.


.. py:function:: get_solar_positions_astral(times, lon, lat)

   Compute solar azimuth and elevation using Astral for given times and location.

   This function uses the Astral astronomical library to calculate precise solar positions
   based on location coordinates and timestamps. The calculations account for Earth's
   orbital mechanics, axial tilt, and atmospheric refraction effects.

   Astronomical Background:
   - Solar position depends on date, time, and geographic location
   - Azimuth: Horizontal angle measured clockwise from North (0°-360°)
   - Elevation: Vertical angle above the horizon (-90° to +90°)
   - Calculations use standard astronomical algorithms (e.g., NREL SPA)

   Coordinate System:
   - Azimuth: 0° = North, 90° = East, 180° = South, 270° = West
   - Elevation: 0° = horizon, 90° = zenith, negative values = below horizon
   - All angles are in degrees for consistency with weather data formats

   The function:
   1. Creates an Astral observer at the specified geographic location
   2. Computes sun position for each timestamp in the input array
   3. Returns DataFrame with azimuth and elevation angles for further processing

   :param times: Array of timezone-aware datetime objects
                 Must include timezone information for accurate calculations
   :type times: DatetimeIndex
   :param lon: Longitude in degrees (positive = East, negative = West)
               Range: -180° to +180°
   :type lon: float
   :param lat: Latitude in degrees (positive = North, negative = South)
               Range: -90° to +90°
   :type lat: float

   :returns:

             DataFrame with columns 'azimuth' and 'elevation' containing solar positions
                       - Index: Input timestamps (timezone-aware)
                       - 'azimuth': Solar azimuth angles in degrees (0°-360°)
                       - 'elevation': Solar elevation angles in degrees (-90° to +90°)
                       - All values are float type for numerical calculations
   :rtype: DataFrame

   .. note::

      Input times must be timezone-aware. The function preserves the original
      timezone information and performs calculations in the specified timezone.


.. py:function:: get_cumulative_global_solar_irradiance(voxel_data, meshsize, df, lon, lat, tz, direct_normal_irradiance_scaling=1.0, diffuse_irradiance_scaling=1.0, **kwargs)

   Compute cumulative global solar irradiance over a specified period using data from an EPW file.

   This function performs time-series analysis of solar irradiance by processing weather data
   over a user-defined period and accumulating irradiance values at each location. The result
   represents the total solar energy received during the specified time period, which is
   essential for seasonal analysis, solar panel positioning, and energy yield predictions.

   Cumulative Analysis Concept:
   - Instantaneous irradiance (W/m²): Power at a specific moment
   - Cumulative irradiance (Wh/m²): Energy accumulated over time
   - Integration: Sum of (irradiance × time_step) for all timesteps
   - Applications: Annual energy yield, seasonal variations, optimal siting

   Time Period Processing:
   - Supports flexible time ranges (daily, seasonal, annual analysis)
   - Handles timezone conversions between local and UTC time
   - Filters weather data based on user-specified start/end times
   - Accounts for leap years and varying daylight hours

   Performance Optimization:
   - Pre-calculates diffuse map once (scales linearly with DHI)
   - Processes direct component for each timestep (varies with sun position)
   - Uses efficient memory management for large time series
   - Provides optional progress monitoring for long calculations

   The function:
   1. Filters EPW data for specified time period with timezone handling
   2. Computes sun positions for each timestep using astronomical calculations
   3. Calculates and accumulates global irradiance maps over the entire period
   4. Handles tree transmittance and provides visualization/export options

   :param voxel_data: 3D array of voxel values representing the urban environment
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters (spatial resolution)
   :type meshsize: float
   :param df: EPW weather data with columns 'DNI', 'DHI' and datetime index
              Must include complete meteorological dataset
   :type df: DataFrame
   :param lon: Longitude in degrees for solar position calculations
   :type lon: float
   :param lat: Latitude in degrees for solar position calculations
   :type lat: float
   :param tz: Timezone offset in hours from UTC (positive = East of UTC)
   :type tz: float
   :param direct_normal_irradiance_scaling: Scaling factor for direct normal irradiance
                                            Allows sensitivity analysis or unit conversions
   :type direct_normal_irradiance_scaling: float
   :param diffuse_irradiance_scaling: Scaling factor for diffuse horizontal irradiance
                                      Allows sensitivity analysis or unit conversions
   :type diffuse_irradiance_scaling: float
   :param \*\*kwargs: Additional arguments including:
                      - view_point_height (float): Observer height in meters (default: 1.5)
                          Height above ground where measurements are taken
                      - start_time (str): Start time in format 'MM-DD HH:MM:SS'
                          Defines beginning of analysis period (default: "01-01 05:00:00")
                      - end_time (str): End time in format 'MM-DD HH:MM:SS'
                          Defines end of analysis period (default: "01-01 20:00:00")
                      - tree_k (float): Tree extinction coefficient for transmittance calculations
                          Higher values mean trees block more light
                      - tree_lad (float): Leaf area density in m^-1
                          Affects light attenuation through tree canopies
                      - show_plot (bool): Whether to show final accumulated results
                      - show_each_timestep (bool): Whether to show plots for each timestep
                          Useful for debugging but significantly increases computation time
                      - colormap (str): Matplotlib colormap name for visualization
                      - vmin (float): Minimum value for colormap scaling
                      - vmax (float): Maximum value for colormap scaling
                      - obj_export (bool): Whether to export results as 3D OBJ file
                      - output_directory (str): Directory for file exports
                      - output_file_name (str): Base filename for exports
                      - dem_grid (ndarray): Digital elevation model for 3D export
                      - num_colors (int): Number of discrete colors for OBJ export
                      - alpha (float): Transparency value for 3D visualization

   :returns:

             2D array of cumulative global solar irradiance values in W/m²·hour
                     - Values represent total solar energy received during the analysis period
                     - Range depends on period length and local climate conditions
                     - NaN indicates invalid measurement locations (e.g., on buildings, water)
   :rtype: ndarray

   .. note::

      The function efficiently handles large time series by pre-computing the diffuse
      component once and scaling it for each timestep, significantly reducing
      computation time for long-term analysis.


.. py:function:: get_global_solar_irradiance_using_epw(voxel_data, meshsize, calc_type='instantaneous', direct_normal_irradiance_scaling=1.0, diffuse_irradiance_scaling=1.0, **kwargs)

   Compute global solar irradiance using EPW weather data, either for a single time or cumulatively over a period.

   The function:
   1. Optionally downloads and reads EPW weather data
   2. Handles timezone conversions and solar position calculations
   3. Computes either instantaneous or cumulative irradiance maps
   4. Supports visualization and export options

   :param voxel_data: 3D array of voxel values.
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters.
   :type meshsize: float
   :param calc_type: 'instantaneous' or 'cumulative'.
   :type calc_type: str
   :param direct_normal_irradiance_scaling: Scaling factor for direct normal irradiance.
   :type direct_normal_irradiance_scaling: float
   :param diffuse_irradiance_scaling: Scaling factor for diffuse horizontal irradiance.
   :type diffuse_irradiance_scaling: float
   :param \*\*kwargs: Additional arguments including:
                      - download_nearest_epw (bool): Whether to download nearest EPW file
                      - epw_file_path (str): Path to EPW file
                      - rectangle_vertices (list): List of (lat,lon) coordinates for EPW download
                      - output_dir (str): Directory for EPW download
                      - calc_time (str): Time for instantaneous calculation ('MM-DD HH:MM:SS')
                      - start_time (str): Start time for cumulative calculation
                      - end_time (str): End time for cumulative calculation
                      - start_hour (int): Starting hour for daily time window (0-23)
                      - end_hour (int): Ending hour for daily time window (0-23)
                      - view_point_height (float): Observer height in meters
                      - tree_k (float): Tree extinction coefficient
                      - tree_lad (float): Leaf area density in m^-1
                      - show_plot (bool): Whether to show visualization
                      - show_each_timestep (bool): Whether to show timestep plots
                      - colormap (str): Matplotlib colormap name
                      - obj_export (bool): Whether to export as OBJ file

   :returns: 2D array of solar irradiance values (W/m²).
   :rtype: ndarray


.. py:function:: compute_solar_irradiance_for_all_faces(face_centers, face_normals, face_svf, sun_direction, direct_normal_irradiance, diffuse_irradiance, voxel_data, meshsize, tree_k, tree_lad, hit_values, inclusion_mode, grid_bounds_real, boundary_epsilon)

   Numba-compiled function to compute direct, diffuse, and global solar irradiance
   for each face in a 3D building mesh.

   This optimized function processes all mesh faces in parallel to calculate solar
   irradiance components. It handles both direct radiation (dependent on sun position
   and surface orientation) and diffuse radiation (dependent on sky visibility).
   The function is compiled with Numba for high-performance computation on large meshes.

   Surface Irradiance Physics:
   - Direct component: DNI × cos(incidence_angle) × transmittance
   - Diffuse component: DHI × sky_view_factor
   - Incidence angle: Angle between sun direction and surface normal
   - Transmittance: Attenuation factor from obstacles and vegetation

   Boundary Condition Handling:
   - Vertical boundary faces are excluded (mesh edges touching domain boundaries)
   - Invalid faces (NaN SVF) are skipped to maintain data consistency
   - Surface orientation affects direct radiation calculation

   Performance Optimizations:
   - Numba JIT compilation for near C-speed execution
   - Parallel processing of face calculations
   - Efficient geometric computations using vectorized operations
   - Memory-optimized array operations

   :param face_centers (float64[: , :]): (N x 3) array of face center coordinates in real-world units
   :param face_normals (float64[: , :]): (N x 3) array of outward-pointing unit normal vectors
   :param face_svf (float64[: ]): (N,) array of Sky View Factor values for each face (0.0-1.0)
   :param sun_direction (float64[: ]): (3,) array for normalized sun direction vector (dx, dy, dz)
   :param direct_normal_irradiance: Direct normal irradiance (DNI) in W/m²
   :type direct_normal_irradiance: float
   :param diffuse_irradiance: Diffuse horizontal irradiance (DHI) in W/m²
   :type diffuse_irradiance: float
   :param voxel_data: 3D array of voxel values for obstacle detection
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters (spatial resolution)
   :type meshsize: float
   :param tree_k: Tree extinction coefficient for Beer-Lambert law
   :type tree_k: float
   :param tree_lad: Leaf area density in m^-1
   :type tree_lad: float
   :param hit_values: Values considered 'sky' for ray tracing (e.g. (0,))
   :type hit_values: tuple
   :param inclusion_mode: Whether hit_values are included (True) or excluded (False)
   :type inclusion_mode: bool
   :param grid_bounds_real: Domain boundaries [[x_min,y_min,z_min],[x_max,y_max,z_max]]
   :type grid_bounds_real: float64[2,3]
   :param boundary_epsilon: Distance threshold for boundary face detection
   :type boundary_epsilon: float

   :returns:

             Three float64[N] arrays containing:
                 - direct_irr: Direct solar irradiance for each face (W/m²)
                 - diffuse_irr: Diffuse solar irradiance for each face (W/m²)
                 - global_irr: Global solar irradiance for each face (W/m²)
   :rtype: tuple

   .. note::

      This function is optimized with Numba and should not be called directly.
      Use the higher-level wrapper functions for normal operation.


.. py:function:: get_building_solar_irradiance(voxel_data, meshsize, building_svf_mesh, azimuth_degrees, elevation_degrees, direct_normal_irradiance, diffuse_irradiance, **kwargs)

   Calculate solar irradiance on building surfaces using Sky View Factor (SVF) analysis,
   with high-performance computation accelerated by Numba JIT compilation.

   This function performs detailed solar irradiance analysis on 3D building surfaces
   represented as triangulated meshes. It calculates both direct and diffuse components
   of solar radiation for each mesh face, accounting for surface orientation, shadows,
   and sky visibility. The computation is optimized for large urban models using
   efficient algorithms and parallel processing.

   Mesh-Based Analysis Advantages:
   - Surface-specific calculations for facades, roofs, and complex geometries
   - Accurate accounting of surface orientation and local shading effects
   - Integration with 3D visualization and CAD workflows
   - Detailed irradiance data for building energy modeling

   Performance Features:
   - Numba JIT compilation for near C-speed execution
   - Parallel processing of mesh faces
   - Efficient ray tracing with tree transmittance
   - Memory-optimized operations for large datasets

   Physical Modeling:
   - Direct irradiance: Based on sun position and surface orientation
   - Diffuse irradiance: Based on Sky View Factor from each surface
   - Tree effects: Partial transmittance using Beer-Lambert law
   - Boundary handling: Automatic exclusion of domain boundary artifacts

   :param voxel_data: 3D array of voxel values representing the urban environment
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters (spatial resolution)
   :type meshsize: float
   :param building_svf_mesh: Building mesh with pre-calculated SVF values in metadata
                             Must have 'svf' array in mesh.metadata
   :type building_svf_mesh: trimesh.Trimesh
   :param azimuth_degrees: Sun azimuth angle in degrees (0=North, 90=East)
   :type azimuth_degrees: float
   :param elevation_degrees: Sun elevation angle in degrees above horizon (0-90°)
   :type elevation_degrees: float
   :param direct_normal_irradiance: Direct normal irradiance (DNI) in W/m² from weather data
   :type direct_normal_irradiance: float
   :param diffuse_irradiance: Diffuse horizontal irradiance (DHI) in W/m² from weather data
   :type diffuse_irradiance: float
   :param \*\*kwargs: Additional parameters including:
                      - tree_k (float): Tree extinction coefficient (default: 0.6)
                          Higher values mean trees block more light
                      - tree_lad (float): Leaf area density in m^-1 (default: 1.0)
                          Affects light attenuation through tree canopies
                      - progress_report (bool): Whether to print timing information (default: False)
                      - obj_export (bool): Whether to export results as OBJ file
                      - output_directory (str): Directory for file exports
                      - output_file_name (str): Base filename for exports

   :returns:

             A copy of the input mesh with irradiance data stored in metadata:
                             - 'svf': Sky View Factor for each face (preserved from input)
                             - 'direct': Direct solar irradiance for each face (W/m²)
                             - 'diffuse': Diffuse solar irradiance for each face (W/m²)
                             - 'global': Global solar irradiance for each face (W/m²)
   :rtype: trimesh.Trimesh

   .. note::

      The input mesh must have SVF values pre-calculated and stored in metadata.
      Use get_surface_view_factor() to compute SVF before calling this function.


.. py:function:: get_cumulative_building_solar_irradiance(voxel_data, meshsize, building_svf_mesh, weather_df, lon, lat, tz, **kwargs)

   Calculate cumulative solar irradiance on building surfaces over a time period.
   Uses the Numba-accelerated get_building_solar_irradiance for each time step.

   :param voxel_data: 3D array of voxel values.
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters.
   :type meshsize: float
   :param building_svf_mesh: Mesh with pre-calculated SVF in metadata.
   :type building_svf_mesh: trimesh.Trimesh
   :param weather_df: Weather data with DNI (W/m²) and DHI (W/m²).
   :type weather_df: DataFrame
   :param lon: Longitude in degrees.
   :type lon: float
   :param lat: Latitude in degrees.
   :type lat: float
   :param tz: Timezone offset in hours.
   :type tz: float
   :param \*\*kwargs: Additional parameters for time range, scaling, OBJ export, etc.

   :returns: A mesh with cumulative (Wh/m²) irradiance in metadata.
   :rtype: trimesh.Trimesh


.. py:function:: get_building_global_solar_irradiance_using_epw(voxel_data, meshsize, calc_type='instantaneous', direct_normal_irradiance_scaling=1.0, diffuse_irradiance_scaling=1.0, **kwargs)

   Compute global solar irradiance on building surfaces using EPW weather data, either for a single time or cumulatively.

   The function:
   1. Optionally downloads and reads EPW weather data
   2. Handles timezone conversions and solar position calculations
   3. Computes either instantaneous or cumulative irradiance on building surfaces
   4. Supports visualization and export options

   :param voxel_data: 3D array of voxel values.
   :type voxel_data: ndarray
   :param meshsize: Size of each voxel in meters.
   :type meshsize: float
   :param building_svf_mesh: Building mesh with pre-calculated SVF values in metadata.
   :type building_svf_mesh: trimesh.Trimesh
   :param calc_type: 'instantaneous' or 'cumulative'.
   :type calc_type: str
   :param direct_normal_irradiance_scaling: Scaling factor for direct normal irradiance.
   :type direct_normal_irradiance_scaling: float
   :param diffuse_irradiance_scaling: Scaling factor for diffuse horizontal irradiance.
   :type diffuse_irradiance_scaling: float
   :param \*\*kwargs: Additional arguments including:
                      - download_nearest_epw (bool): Whether to download nearest EPW file
                      - epw_file_path (str): Path to EPW file
                      - rectangle_vertices (list): List of (lon,lat) coordinates for EPW download
                      - output_dir (str): Directory for EPW download
                      - calc_time (str): Time for instantaneous calculation ('MM-DD HH:MM:SS')
                      - period_start (str): Start time for cumulative calculation ('MM-DD HH:MM:SS')
                      - period_end (str): End time for cumulative calculation ('MM-DD HH:MM:SS')
                      - time_step_hours (float): Time step for cumulative calculation
                      - tree_k (float): Tree extinction coefficient
                      - tree_lad (float): Leaf area density in m^-1
                      - show_each_timestep (bool): Whether to show plots for each timestep
                      - nan_color (str): Color for NaN values in visualization
                      - colormap (str): Matplotlib colormap name
                      - vmin (float): Minimum value for colormap
                      - vmax (float): Maximum value for colormap
                      - obj_export (bool): Whether to export as OBJ file
                      - output_directory (str): Directory for OBJ export
                      - output_file_name (str): Filename for OBJ export
                      - save_mesh (bool): Whether to save the mesh data using pickle
                      - mesh_output_path (str): Path to save the mesh data (if save_mesh is True)

   :returns: Building mesh with irradiance values stored in metadata.
   :rtype: trimesh.Trimesh


.. py:function:: save_irradiance_mesh(irradiance_mesh, output_file_path)

   Save the irradiance mesh data to a file using pickle serialization.

   This function provides persistent storage for computed irradiance results,
   enabling reuse of expensive calculations and sharing of results between
   analysis sessions. The mesh data includes all geometry, irradiance values,
   and metadata required for visualization and further analysis.

   Serialization Benefits:
   - Preserves complete mesh structure with all computed data
   - Enables offline analysis and visualization workflows
   - Supports sharing results between different tools and users
   - Avoids recomputation of expensive irradiance calculations

   Data Preservation:
   - All mesh geometry (vertices, faces, normals)
   - Computed irradiance values (direct, diffuse, global)
   - Sky View Factor data and other metadata
   - Material properties and visualization settings

   :param irradiance_mesh: Mesh with irradiance data in metadata
                           Should contain computed irradiance results
   :type irradiance_mesh: trimesh.Trimesh
   :param output_file_path: Path to save the mesh data file
                            Recommended extension: .pkl for clarity
   :type output_file_path: str

   .. note::

      The function automatically creates the output directory if it doesn't exist.
      Use pickle format for maximum compatibility with Python data structures.


.. py:function:: load_irradiance_mesh(input_file_path)

   Load previously saved irradiance mesh data from a file.

   This function restores complete mesh data including geometry, computed
   irradiance values, and all associated metadata. It enables continuation
   of analysis workflows and reuse of expensive computation results.

   Restoration Capabilities:
   - Complete mesh geometry with all topological information
   - All computed irradiance data (direct, diffuse, global components)
   - Sky View Factor values and analysis metadata
   - Visualization settings and material properties

   Workflow Integration:
   - Load results from previous analysis sessions
   - Share computed data between team members
   - Perform post-processing and visualization
   - Compare results from different scenarios

   :param input_file_path: Path to the saved mesh data file
                           Should be a file created by save_irradiance_mesh()
   :type input_file_path: str

   :returns:

             Complete mesh with all irradiance data in metadata
                             Ready for visualization, analysis, or further processing
   :rtype: trimesh.Trimesh

   .. note::

      The loaded mesh maintains all original data structure and can be used
      immediately for visualization or additional analysis operations.


